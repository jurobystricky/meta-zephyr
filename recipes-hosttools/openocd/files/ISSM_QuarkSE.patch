diff --git a/AUTHORS.ChangeLog b/AUTHORS.ChangeLog
deleted file mode 100644
index b2b5e6b..0000000
--- a/AUTHORS.ChangeLog
+++ /dev/null
@@ -1,10 +0,0 @@
-drath:Dominic Rath <Dominic.Rath@gmx.de>
-mlu:Magnus Lundin <lundin@mlu.mine.nu>
-mifi:Michael Fischer <fischermi@t-online.de>
-ntfreak:Spencer Oliver <spen@spen-soft.co.uk>
-duane:Duane Ellis <openocd@duaneellis.com>
-oharboe:Ã˜yvind Harboe <oyvind.harboe@zylin.com>
-kc8apf:Rick Altherr <kc8apf@users.berlios.de>
-zwelch:Zachary T Welch <zw@superlucidity.net>
-vpalatin:Vincent Palatin <vpalatin@users.berlios.de>
-bodylove:Carsten Schlote <schlote@vahanus.net>
diff --git a/NEWS-0.2.0 b/NEWS-0.2.0
deleted file mode 100644
index 7426926..0000000
--- a/NEWS-0.2.0
+++ /dev/null
@@ -1,80 +0,0 @@
-The OpenOCD 0.2.0 source archive release includes numerous improvements
-that were made since the initial 0.1.0 source archive release.  Many
-contributors helped make this release a great success, and the community
-of developers and maintainers look forward to any response.
-
-In addition to the list of changes below, countless bug fixing and
-cleaning was performed across the tree.  Various TCL command parameters
-must past stricter value checks, and many more error conditions have
-been handled correctly.  These efforts helped to make the 0.2.0 release
-more stable and robust, though some changes may expose latent bugs in
-your existing configuration scripts.
-
-This release does not maintain backward compatibility in all respects,
-so some target or configuration scripts may need to be updated.  In some
-cases, you may also see warnings; resolve those, because they indicate
-commands that will be removed in the future.
-
-The following areas of OpenOCD functionality changed in this release:
-
-JTAG Layer:
-- Improves modularity: core, TCL, driver commands, and interface have
-  been separated, encapsulated, and documented for developers.  Mostly.
-- Improves JTAG TAP transition tables:
-   * Makes TAP paths variable length, rather than being fixed at 7 steps.
-   * Fixes problems with some targets that did not like longer paths.
-- Improves JTAG driver/minidriver modularity and encapsulation.
-- New drivers:
-   * Adds stub minidriver for developing new embedded JTAG interfaces.
-- Improves drivers:
-   * ft2232+ftd2xx:
-      + Adds initial high-speed device support: --enable-ftd2xx-highspeed
-      + Supports more types of FTDI-based devices.
-   * jlink:
-      + Works with more versions of the firmware (v3 and newer)
-      + Supports dynamically detects device capabilities and limits
-   * vsllink:
-      + Supports very long scan chains
-   * amtjtagaccel:
-      + Fixes broken ID code detection problems.
-
-Target Layer:
-- New devices: AVR, FA526
-- Improved support: ARM ADI, ARM11, MIPS
-- Numerous other bug fixes and improvements
-
-Flash Layer:
-- Improved drivers: mflash
-- New drivers: AT91SAM3, AVR, Davinci NAND
-
-Board, Interface, and Target Configuration Scripts:
-- Many new and improved targets and boards are now available.
-- Better separation of "board" and "target" configuration
-- Moved all TCL files to top-level "tcl" directory in the source tree
-- Installation moved from '$pkglibdir/' to '$pkgdatadir/scripts/'.
-- Site-specific files should be installed under '$pkgdatadir/site/';
-  files that exist this tree will be used in preference to default
-  distribution configurations in '$pkgdatadir/scripts/'.
-
-Documentation:
-- Updated User Guide:     http://openocd.berlios.de/doc/html/index.html
-   * Partially re-written and re-organized.
-   * Standardized presentation for all commands.
-   * Covers many drivers and commands that were previously omitted.
-   * New index for commands and drivers.
-- Added Developer Manual: http://openocd.berlios.de/doc/doxygen/index.html
-   * Now includes architecture, technical primers, style guides, and more.
-   * Available in-tree and on-line.
-
-Build and Release:
-- Increased configuration and compilation warning coverage.
-   * Use --disable-werror to work around build errors caused by warnings.
-- Use libtool to produce helper libraries as a step toward "libopenocd".
-- New processes and scripting to facilitate future source releases.
-
-For more details about what has changed since 0.1.0, see the ChangeLog
-associated with this release.
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES files in the source archive).
diff --git a/NEWS-0.3.0 b/NEWS-0.3.0
deleted file mode 100644
index 80e8823..0000000
--- a/NEWS-0.3.0
+++ /dev/null
@@ -1,82 +0,0 @@
-This file should include highlights of the changes made in the
-OpenOCD openocd-0.3.0 source archive release.  See the repository
-history for details about what changed, including bugfixes and
-other issues not mentioned here.
-
-JTAG Layer:
-    FT2232H (high speed USB) support doesn't need separate configuration
-    New FT2232H JTAG adapters:  Amontec, Olimex, Signalyzer
-    New reset_config options for SRST gating the JTAG clock (or not)
-    TAP declaration no longer requires ircapture and mask attributes
-    Scan chain setup should be more robust, with better diagnostics
-    New TAP events:
-	"post-reset" for TAP-invariant setup code (TAPs not usable yet)
-	"setup" for use once TAPs are addressable (e.g. with ICEpick)
-    Overridable Tcl "init_reset" and "jtag_init" procedures
-    Simple "autoprobe" mechanism to help simplify server setup
-
-Boundary Scan:
-    SVF bugfixes ... parsing fixes, better STATE switch conformance
-    XSVF bugfixes ... be more correct, handle Xilinx tool output
-
-Target Layer:
-    Warn on use of obsolete numeric target IDs
-    New commands for use with Cortex-M3 processors:
-	"cortex_m3 disassemble" ... Thumb2 disassembly (UAL format)
-	"cortex_m3 vector_catch" ... traps certain hardware faults
-		without tying up breakpoint resources
-    If you're willing to help debug it
-	VERY EARLY Cortex-A8 and ARMv7A support
-	Updated BeagleBoard.org hardware support
-	you may need to explicitly "reset" after connect-to-Beagle
-    New commands for use with XScale processors: "xscale vector_table"
-    ARM
-	bugfixes to single-stepping Thumb code
-	ETM: unavailable registers are not listed
-	ETB, ETM: report actual hardware status
-    ARM9
-	name change:  "arm9 vector_catch" not "arm9tdmi vector_catch"
-    ARM11
-	single stepping support for i.MX31
-	bugfix for missing "arm11" prefix on "arm11 memwrite ..."
-    GDB support
-	gdb_attach command is gone
-
-Flash Layer:
-    The lpc2000 driver handles the new NXP LPC1700 (Cortex-M3) chips
-    New drivers:
-	lpc2900, for NXP LPC2900 chips (ARM968 based)
-	mx3_nand, for imx31
-    New "last" flag for NOR "flash erase_sector" and "flash protect"
-    The "nand erase N" command now erases all of bank N
-    Speed up davinci_nand by about 3x
-
-Board, Target, and Interface Configuration Scripts:
-    Amontec JTAGkey2 support
-    Cleanup and additions for the TI/Luminary Stellaris scripts
-    LPC1768 target (and flash) support
-	Keil MCB1700 eval board
-    Samsung s3c2450
-	Mini2440 board
-    Numeric TAP and Target identifiers now trigger warnings
-    PXA255 partially enumerates
-
-Documentation:
-    Capture more debugging and setup advice
-    Notes on target source code changes that may help debugging
-
-Build and Release:
-    Repository moved from SVN at Berlios to GIT at SourceForge
-    Clean builds on (32-bit) Cygwin
-    Clean builds on 64-bit MinGW
-
-For more details about what has changed since the last release,
-see the git repository history.  With gitweb, you can browse that
-in various levels of detail.
-
-For older NEWS, see the NEWS files associated with each release
-(i.e. NEWS-<version>).
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES files in the source archive).
diff --git a/NEWS-0.4.0 b/NEWS-0.4.0
deleted file mode 100644
index cbd5526..0000000
--- a/NEWS-0.4.0
+++ /dev/null
@@ -1,98 +0,0 @@
-This file includes highlights of the changes made in the
-OpenOCD 0.4.0 source archive release.  See the repository
-history for details about what changed, including bugfixes
-and other issues not mentioned here.
-
-JTAG Layer:
-	Support KT-Link JTAG adapter.
-	Support USB-JTAG, Altera USB-Blaster and compatibles.
-
-Boundary Scan:
-
-Target Layer:
-	General
-		- Removed commands which have been obsolete for at least
-		  a year (from both documentation and, sometimes, code).
-		- new "reset-assert" event, for systems without SRST
-	ARM
-		- supports "reset-assert" event (except on Cortex-M3)
-		- renamed "armv4_5" command prefix as "arm"
-		- recognize TrustZone "Secure Monitor" mode
-		- "arm regs" command output changed
-		- register names use "sp" not "r13"
-		- add top-level "mcr" and "mrc" commands, replacing
-		  various core-specific operations
-		- basic semihosting support (ARM7/ARM9 only, for now)
-	ARM11
-		- Should act much more like other ARM cores:
-		   * Preliminary ETM and ETB hookup
-		   * accelerated "flash erase_check"
-		   * accelerated GDB memory checksum
-		   * support "arm regs" command
-		   * can access all core modes and registers
-		   * watchpoint support
-		- Shares some core debug code with Cortex-A8
-	Cortex-A8
-		- Should act much more like other ARM cores:
-		   * support "arm regs" command
-		   * can access all core modes and registers
-		   * watchpoint support
-		- Shares some core debug code with ARM11
-	Cortex-M3
-		- Exposed DWT registers like cycle counter
-		- vector_catch settings not clobbered by resets
-		- no longer interferes with firmware's fault handling
-	ETM, ETB
-		- "trigger_percent" command moved ETM --> ETB
-		- "etm trigger_debug" command added
-	MIPS
-		- use fastdata writes
-	Freescale DSP563xx cores (partial support)
-
-Flash Layer:
-	'flash bank' and 'nand device' take <bank_name> as first argument.
-	With this, flash/NAND commands allow referencing banks by name:
-		- <bank_name>: reference the bank with its defined name
-		- <driver_name>[.N]: reference the driver's Nth bank
-	New 'nand verify' command to check bank against an image file.
-	The "flash erase_address" command now rejects partial sectors;
-		previously it would silently erase extra data.  If you
-		want to erase the rest of the first and/or last sectors
-		instead of failing, you must pass an explicit "pad" flag.
-	New at91sam9 NAND controller driver.
-	New s3c64xx NAND controller driver.
-
-Board, Target, and Interface Configuration Scripts:
-	ARM9
-		- ETM and ETB hookup for iMX2* targets
-	Add $HOME/.openocd to the search path.
-	Handle Rev C of LM3S811 eval boards.
-		- use "luminary-lm3s811.cfg" for older boards
-		- use "luminary.cfg" for RevC and newer
-
-Core Jim/TCL Scripting:
-	New 'usage' command to provide terse command help.
-	Improved command 'help' command output (sorted and indented).
-	Improved command handling:
-		- Most boolean settings now accept any of the following:
-		  on/off, enable/disable, true/false, yes/no, 1/0
-		- More error checking and reporting.
-
-Documentation:
-	New built-in command development documentation and primer.
-
-Build and Release:
-	Use --enable-doxygen-pdf to build PDF developer documentation.
-	Consider upgrading to libftdi 0.17 if you use that library; it
-		includes bugfixes which improve FT2232H support.
-
-For more details about what has changed since the last release,
-see the git repository history.  With gitweb, you can browse that
-in various levels of detail.
-
-For older NEWS, see the NEWS files associated with each release
-(i.e. NEWS-<version>).
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES.txt files in the source archive).
diff --git a/NEWS-0.5.0 b/NEWS-0.5.0
deleted file mode 100644
index add6c1e..0000000
--- a/NEWS-0.5.0
+++ /dev/null
@@ -1,74 +0,0 @@
-This file includes highlights of the changes made in the
-OpenOCD 0.5.0 source archive release.  See the repository
-history for details about what changed, including bugfixes
-and other issues not mentioned here.
-
-JTAG Layer:
-	New driver for "Bus Pirate"
-	Rename various commands so they're not JTAG-specific
-	   There are migration procedures for most of these, but you should
-	   convert your scripts to the new names, since those procedures
-	   will not be around forever.
-		jtag jinterface ... is now adapter_name
-	   	jtag_khz	... is now adapter_khz
-		jtag_nsrst_delay ... is now adapter_nsrst_delay
-		jtag_nsrst_assert_width ... is now adapter_nsrst_assert_width
-	Support Voipac VPACLink JTAG Adapter.
-
-Boundary Scan:
-
-Transport framework core ... supporting future work for SWD, SPI, and other
-non-JTAG ways to debug targets or program flash.
-
-Target Layer:
-	ARM:
-		- basic semihosting support for ARMv7M.
-		- renamed "armv7m" command prefix as "arm"
-	MIPS:
-		- "ejtag_srst" variant removed. The same functionality is
-		  obtained by using "reset_config none".
-		- added PIC32MX software reset support, this means srst is not
-		  required to be connected anymore.
-	OTHER:
-		- preliminary AVR32 AP7000 support.
-
-Flash Layer:
-	New "stellaris recover" command, implements the procedure
-		to recover locked devices (restoring non-volatile
-		state to the factory defaults, including erasing
-		the flash and its protection bits, and possibly
-		re-enabling hardware debugging).
-	PIC32MX now uses algorithm for flash programming, this
-		has increased the performance by approx 96%.
-	New 'pic32mx unlock' cmd to remove readout protection.
-	New STM32 Value Line Support.
-	New 'virtual' flash driver, used to associate other addresses
-		with a flash bank. See pic32mx.cfg for usage.
-	New iMX27 NAND flash controller driver.
-
-Board, Target, and Interface Configuration Scripts:
-	Support IAR LPC1768 kickstart board (by Olimex)
-	Support Voipac PXA270/PXA270M module.
-	New $PARPORTADDR tcl variable used to change default
-		parallel port address used.
-	Remove lm3s811.cfg; use "stellaris.cfg" instead
-
-Core Jim/TCL Scripting:
-	New "add_script_search_dir" command, behaviour is the same
-		as the "-s" cmd line option.
-
-Documentation:
-
-Build and Release:
-
-For more details about what has changed since the last release,
-see the git repository history.  With gitweb, you can browse that
-in various levels of detail.
-
-For older NEWS, see the NEWS files associated with each release
-(i.e. NEWS-<version>).
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES.txt files in the source archive).
-
diff --git a/NEWS-0.6.0 b/NEWS-0.6.0
deleted file mode 100644
index 0acd242..0000000
--- a/NEWS-0.6.0
+++ /dev/null
@@ -1,54 +0,0 @@
-This file includes highlights of the changes made in the
-OpenOCD  source archive release.  See the
-repository history for details about what changed, including
-bugfixes and other issues not mentioned here.
-
-JTAG Layer:
-	New STLINK V1/V2 JTAG/SWD adapter support.
-	New OSJTAG adapter support.
-	New Tincantools Flyswatter2 support.
-	Improved ULINK driver.
-	Improved RLINK driver.
-	Support for adapters based on FT232H chips.
-	New experimental driver for FTDI based adapters, using libusb-1.0 in asynchronous mode.
-
-Boundary Scan:
-
-Target Layer:
-	New Cortex-M0 support.
-	New Cortex-M4 support.
-	Improved Working area algorithm.
-	New RTOS support. Currently linux, FreeRTOS, ThreadX and eCos.
-	Connecting under reset to Cortex-Mx and MIPS chips.
-
-Flash Layer:
-	New SST39WF1601 support.
-	New EN29LV800BB support.
-	New async algorithm support for selected targets, stm32, stellaris and pic32.
-	New Atmel SAM3S, SAM3N support.
-	New ST STM32L support.
-	New Microchip PIC32MX1xx/2xx support.
-	New Freescale Kinetis K40 support.
-
-Board, Target, and Interface Configuration Scripts:
-	Support Dangerous Prototypes Bus Blaster.
-	Support ST SPEAr Family.
-	Support Gumstix Verdex boards.
-	Support TI Beaglebone.
-
-Documentation:
-	Improved HACKING info for submitting patches.
-	Fixed numerous broken links.
-
-Build and Release:
-
-For more details about what has changed since the last release,
-see the git repository history.  With gitweb, you can browse that
-in various levels of detail.
-
-For older NEWS, see the NEWS files associated with each release
-(i.e. NEWS-<version>).
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES.txt files in the source archive).
diff --git a/README b/README
index 065994a..eee713d 100644
--- a/README
+++ b/README
@@ -117,7 +117,7 @@ Debug targets
 
 ARM11, ARM7, ARM9, AVR32, Cortex-A, Cortex-R, Cortex-M,
 Feroceon/Dragonite, DSP563xx, DSP5680xx, FA526, MIPS EJTAG, NDS32,
-XScale.
+XScale, Intel Quark.
 
 Flash drivers
 -------------
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..4663d92
--- /dev/null
+++ b/README.md
@@ -0,0 +1,4 @@
+OpenOCD
+=======
+
+The development tree for OpenOCD for the Synopsys DesignWare ARC processor family
\ No newline at end of file
diff --git a/doc/README.ARC b/doc/README.ARC
new file mode 100755
index 0000000..b33bdbb
--- /dev/null
+++ b/doc/README.ARC
@@ -0,0 +1,372 @@
+ARC Bookshelf: Plain text OpenOCD Getting Started manual
+========================================================
+
+Content:
+
+1. How to build OpenOCD on Linux
+2. How to build OpenOCD for Windows (cross compile on Linux)
+3. How to use OpenOCD on Linux
+4. How to use OpenOCD on Windows
+5. Advanced debug commands
+6. Some useful ARC development commands
+7. Find your way in the source code
+8. Digilent cable installation instructions
+9. How to program a bit-file into FPGA with the Digilent HS cable
+
+Important notes:
+
+1. This document uses term "Digilent HS" to refer to both HS1 and HS2 cables.
+   Statements that are applicable only to selected cable mention it explicitly.
+2. There is NO Flash support in ARC OpenOCD.
+
+
+1. How to build OpenOCD on Linux
+--------------------------------
+
+Install prerequisites: libtool, autoconf, automake, GCC, Git, makeinfo, libusb
+and its development package. Command to install those on Ubuntu 12.04/14.04 build
+host:
+
+    $ sudo apt-get install libtool git-core build-essential autoconf automake
+    texinfo libusb-1.0-dev pkg-config
+
+Command to install prerequisites on RHEL 6:
+
+    $ sudo yum install libtool gcc autoconf automake texinfo libusbx-devel
+
+Optional dependencies required to build documentation are: asciidoc and
+texinfo-tex.
+
+Download OpenOCD sources:
+
+    $ git clone https://github.com/foss-for-synopsys-dwc-arc-processors/openocd
+    $ cd openocd
+
+Configure OpenOCD. Consult `configure --help` and generic OpenOCD documentation
+for details. For ARC you would want to have an ftdi driver.
+
+    $ ./bootstrap
+    $ ./configure --enable-ftdi --disable-doxygen-html
+
+Notes:
+  * if documentation is required, remove the option `--disable-doxygen-html`
+  * for development activities, add those options:
+    `--enable-verbose --enable-verbose-jtag-io`
+  * if build fails and there in error log there is something about "warnings
+    treated as errors", then try to configure with option `--disable-werror`.
+
+Now build and install:
+    $ make
+    $ sudo make install
+
+It is possible to run OpenOCD from build directory, without installing, however
+this is out of scope of this document.
+
+Finally you need to configure udev rules in such way that OpenOCD would be able
+to claim your JTAG debug cable. In common case for ARC this is an FTDI-based
+device. If you already have libftdi package installed on your system, then
+required rules are already provided to udev. Otherwise create file
+`/etc/udev/rules.d/99-ftdi.rules` with the following contents:
+
+    # allow users to claim the device
+    # Digilent HS1 and similiar products
+    SUBSYSTEM=="usb", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6010", MODE="0664", GROUP="plugdev"
+    # Digilent HS2
+    SUBSYSTEM=="usb", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6014", MODE="0664", GROUP="plugdev"
+
+You also can use file `contrib/openocd.udev` supplied with OpenOCD sources,
+however this file doesn't work with Digilent HS2, though on the other hand it
+mentions many other FTDI-based devices.
+
+Then either reboot your system or reload udev configuration and reconnect debug
+cable to the host computer:
+
+    $ sudo udevadm control --reload-rules
+    # Disconnect JTAG cable from host, then connect again.
+
+
+2. How to build OpenOCD for Windows (cross compile on Linux)
+------------------------------------------------------------
+
+There are two ways to use OpenOCD with FTDI-based debug cables: with an
+obsolete ft2232 interface and proprietary FTD2xx drivers (further down called
+ft2232/ftd2xx) or with new ftdi interface and libusb driver (further down
+called ftdi/libusb).
+
+Since ft2232 interface is considered obsolete by OpenOCD developers in general
+it is suggested to use ftdi/libusb combination, however on Windows this
+requires replacing the original FTDI drivers with open source ones. This will
+render Digilent cable unusable by Digilent tools, like Adept.  Consequently you
+have to choose depending on your requirements. It is also has to be mentioned
+that in practice ftdi/libusb is much faster on Windows than ft2232/ftd2xx.
+
+Install the same prerequisites like for Linux build (except for libusb-dev) and
+MinGW on your system:
+
+    $ sudo apt-get install libtool git-core build-essential autoconf automake
+    texinfo
+
+Install MinGW cross-compiler to your system:
+
+    $ sudo apt-get install gcc-mingw-w64
+
+If you are going to use libusb drivers, then download libusb or
+[libusbsx](http://libusbx.org/) sources. Configure and build them with MinGW
+compiler. It is recommended to build only static libusb, so that OpenOCD will
+not need this library's dll file to be copied around:
+
+    $ tar xaf libusbx-1.0.18-rc1.tar.bz2
+    $ cd libusbx-1.0.18-rc1
+    $ ./configure --host=i686-w64-mingw32 --build=x86_64-linux-gnu \
+      --prefix=</libusbx/install/path> --disable-shared --disable-static
+    $ make
+    $ make install
+
+If you are planing to use FTD2xx drivers, then download them from [FTDI
+site](http://www.ftdichip.com/Drivers/D2XX.htm). Unzip them:
+
+    $ mkdir ftd2xx
+    $ cd ftd2xx
+    $ unzip ../CDM\ 2.08.30\ WHQL\ Certified.zip
+    $ unzip CDM\ v2.08.30\ WHQL\ Certified.zip
+
+Download OpenOCD sources:
+
+    $ git clone https://github.com/foss-for-synopsys-dwc-arc-processors/openocd
+    $ cd openocd
+    $ ./bootstrap
+
+Configure OpenOCD. Consult `configure --help` and generic OpenOCD documentation
+for details. This command line is recommended for ARC with libusb/ftdi:
+
+    $ PKG_CONFIG_PATH=</libusbx/install/path>/lib/pkgconfig ./configure \
+      --enable-ftdi --host=i686-w64-mingw32 --build=x86_64-linux-gnu \
+      --disable-werror --prefix=<openocd/install/path>
+
+Note that it is required to set PKG_CONFIG_PATH, otherwise configure script
+will detect host libusb installation, instead of the one cross-compiled for
+Windows.
+
+To configure for FTD2xx drivers:
+
+    $ ./configure --enable-ft2232_ftd2xx --host=i686-w64-mingw32 \
+      --build=x86_64-linux-gnu --disable-werror --prefix=</openocd/install/path> \
+      --with-ftd2xx-win32-zipdir=</directory/where/you've/unzipped/ftd2xx>
+
+It is highly recommended to remove libusb-1.0-dev package from your host
+system, otherwise configure script will use information from your host system
+when configuring, but compiler will not be able to link Windows' openocd binary
+with libusb for Linux. Alternative is to compile with both interfaces. In the
+latter case add `--enable-ft2232_ftd2xx --with-ftd2xx-win32-zipdir=...` to the
+command line for libusb/ftdi.
+
+Build and install:
+
+    $ make
+    $ make install
+
+If your application uses libusb and is being linked dynamically (this is by
+default), copy </libusbx/install/path>/bin/libusb-1.0.dll to the OpenOCD bin
+directory. Copy OpenOCD installation to Window host.
+
+
+3. How to use OpenOCD on Linux
+-----------------------------------------------------------
+
+> Connection host is a host that is connected to the debug target via USB cable
+> and runs OpenOCD. Debug host is a hsot that runs GDB, which connects to the
+> OpenOCD with TCP connection. Ehily typically it is the same host, they
+> actually can be different host and it is important to distinguish them.
+
+Connect debug target to the connection host. AXS10x products and EM Starter Kit
+have built-in debug cable, the don't require a separate Digilent HS cable. HS
+is required only for other debug targets like ML-509 board, etc.
+
+Run lsusb application to ensure that FTDI device is there:
+
+    $ lsusb
+
+In case of HS1, EM Starter Kit and AXS10x there should line like this:
+
+    Bus 001 Device 002: ID 0403:6010 Future Technology Devices International, Ltd FT2232C Dual USB-UART/FIFO IC
+
+In case if HS2 there should be line like this:
+
+    Bus 001 Device 003: ID 0403:6014 Future Technology Devices International, Ltd FT232H Single HS USB-UART/FIFO IC
+
+Note that exact lines could differ from host to host.
+
+Run OpenOCD:
+
+    $ openocd -f <openocd.cfg>
+
+Valid openocd.cfg files are installed into
+`/usr/local/share/openocd/scripts/board/`:
+ * snps_em_sk.cfg - DW ARC EM Starter Kit
+ * snps_axs101.cfg - DW ARC AXS101 Software Development platform
+
+On the debug host (PC with GDB) start an ELF32 GDB debugger:
+
+    $ arc-elf32-gdb ./<elf_app_to_debug>
+
+Make the connection between arc-elf32-gdb and OpenOCD:
+
+    (gdb) target remote <connection host ip address>:3333
+
+Load image to be debugged (./<app_to_debug>.elf) into the target memory:
+
+    (gdb) load
+
+Set breakpoints at functions main and exit:
+
+    (gdb) break main
+    (gdb) break exit
+
+Start the execution on target of the image to debug, to reach function main:
+
+  (gdb) continue
+
+Resume execution to reach function exit:
+
+  (gdb) continue
+
+
+4. How to use OpenOCD on Windows
+--------------------------------
+
+If you are using libusb/ftdi combination, then you have to download WinUSB
+driver and replace FTDI drivers for Digilent cables or EM Starter Kit with it.
+Refer to [this page](https://github.com/libusbx/libusbx/wiki/Windows-Backend)
+for details. In a nutshell, download [Zadig](http://zadig.akeo.ie/), run it and
+use it to install WinUSB driver for FTDI device. If your FTDI device is not
+shown by Zadig, then tick "List all devices" in "Options". Note that antivirus
+might complain about driver files created by Zadig. After installing the driver
+everything is the same as on Linux: run OpenOCD, connect to it with GDB, etc.
+
+To use ft2232/ftd2xx combination, download [Digilent Adept
+utility](http://www.digilentinc.com/Products/Detail.cfm?Prod=ADEPT2) and use it
+to install latest FTDI drivers. Then you need to change OpenOCD configuration
+file, because by default it uses ftdi/libusb combination. Refer to "How to use
+OpenOCD on Linux" for a list of available files. In your configuration script
+replace line `source [find interface/ftdi/digilent-hs1.cfg]` with line `source
+[find interface/digilent-hs1.cfg]`. If you are using Digilent HS2, then use
+files named `digilent-hs2.cfg`.  Everything else is the same as for Linux or
+for ftdi/libusb combination.
+
+
+5. Advanced debug commands
+--------------------------
+
+With the GDB "monitor" command, you have "direct" access to the core without
+any interference from GDB anymore! With other words, GDB has no notion of
+changes in core state when using the so called  monitor commands (but it is
+very powerful). In GDB, connect to the OpenOCD target and type following command to get a list of available monitor commands:
+
+    (gdb) monitor help
+
+To get a list of some ARC-specific commands, run:
+
+    (gdb) monitor help arc
+
+
+6. Some useful ARC development commands
+---------------------------------------
+
+Some command that might be useful during development:
+
+    $ arc-elf32-readelf u-boot.elf
+    $ arc-elf32-readelf -S u-boot.elf
+    $ arc-elf32-readelf u-boot.elf
+    $ arc-elf32-readelf -x --hex-dump=.text u-boot.elf | more
+    $ arc-elf32-readelf -x --hex-dump=1 u-boot.elf | more
+    $ arc-elf32-readelf -x 1 u-boot.elf | more
+
+
+7. Find your way in the source code
+-----------------------------------
+
+Automake makefile entry starts from: src/target/Makefile.am
+
+In src/target is the ARC specific code base:
+
+	Top and bottom interfaces into OpenOCD:
+
+	arc.c				main hook into OpenOCD framework (target function body)
+	arc.h				main include (gets everywhere included)
+	arc_jtag.c + .h		ARC jtag interface into OpenOCD
+
+	Supporting functions/modules as used by above interface into OpenOCD
+
+	arc32.c + .h		generic ARC architecture functions
+	arc_core.c + .h		ARC core internal specifics
+	arc_dbg.c + .h		ARC debugger functions
+	arc_mem.c + .h		ARC memory functions
+	arc_mntr.c + .h		GDB monitor functions
+	arc_ocd.c + .h		ARC OCD initialization
+	arc_regs.c + .h		ARC register access
+	arc_trgt.c + .h		target/board system functions
+
+
+8. Digilent driver installation instructions
+--------------------------------------------
+
+OpenOCD doesn't use Digilent drivers to communicate with Digilent debug cables,
+instead it uses it's own implementation of FTDI MPSSE protocol, which us
+compatible with _virtually_ any other FTDI x232 cable. However to use some
+features of Digilent cables you might need to install their drivers and
+utilities. Following are instructions on how to do that.
+
+Download appropriate version of runtime and utilities from Digilent site:
+http://www.digilentinc.com/Products/Detail.cfm?Prod=ADEPT2 .
+
+Untar and install products:
+
+    $ tar xzfv digilent.adept.runtime_2.10.2-i686.tar.gz
+    $ cd digilent.adept.runtime_2.10.2-i686
+    $ sudo ./install.sh
+    $ cd ftdi.drivers_1.0.4-i686
+    $ sudo ./install.sh
+    $ cd ../..
+
+    $ tar xvzf digilent.adept.utilities_2.1.1-i686.tar.gz
+    $ cd digilent.adept.utilities_2.1.1-i686
+    $ sudo ./install.sh
+    $ cd ..
+
+
+9. How to program a bit-file into FPGA with the Digilent HS cable
+-----------------------------------------------------------------
+
+Below is an example given of how to program a Xilinx ML509 FPGA developers
+board. NOTE: make sure the Digilent HS cable is connected to the right
+JTAG connector on the board (programming the FPGA and not the memory).
+So, it should be connected to PC4 JTAG and not to J51 BDM.
+Further more, Device 4: XC5VLX110T is the FPGA to program, device 4 in the
+JTAG scan chain.
+
+    > djtgcfg enum
+    Found 1 device(s)
+
+    Device: JtagHs2
+        Product Name:   Digilent JTAG-HS2
+        User Name:      JtagHs2
+        Serial Number:  210249810909
+
+    > djtgcfg -d JtagHs2 init
+    Initializing scan chain...
+    Found Device ID: a2ad6093
+    Found Device ID: 0a001093
+    Found Device ID: 59608093
+    Found Device ID: f5059093
+    Found Device ID: f5059093
+
+    Found 5 device(s):
+        Device 0: XCF32P
+        Device 1: XCF32P
+        Device 2: XC95144XL
+        Device 3: XCCACE
+        Device 4: XC5VLX110T
+
+    > djtgcfg -d JtagHs2 prog -i 4 -f <fpga bit file to progam>.bit
+    Programming device. Do not touch your board. This may take a few minutes...
+    Programming succeeded.
diff --git a/doc/openocd.texi b/doc/openocd.texi
index ea3db75..22aefd5 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -9,7 +9,7 @@
 @paragraphindent 0
 @c %**end of header
 
-@include version.texi
+@c @include version.texi
 
 @copying
 
@@ -156,9 +156,9 @@ USB-based, parallel port-based, and other standalone boxes that run
 OpenOCD internally. @xref{Debug Adapter Hardware}.
 
 @b{GDB Debug:} It allows ARM7 (ARM7TDMI and ARM720t), ARM9 (ARM920T,
-ARM922T, ARM926EJ--S, ARM966E--S), XScale (PXA25x, IXP42x) and
-Cortex-M3 (Stellaris LM3, ST STM32 and Energy Micro EFM32) based cores to be
-debugged via the GDB protocol.
+ARM922T, ARM926EJ--S, ARM966E--S), XScale (PXA25x, IXP42x), Cortex-M3
+(Stellaris LM3, ST STM32 and Energy Micro EFM32) and Intel Quark (x10xx)
+based cores to be debugged via the GDB protocol.
 
 @b{Flash Programming:} Flash writing is supported for external
 CFI-compatible NOR flashes (Intel and AMD/Spansion command set) and several
@@ -1317,23 +1317,24 @@ hilscher_nxhx500_re.cfg   opendous_ftdi.cfg          vsllink.cfg
 hilscher_nxhx50_etm.cfg   openocd-usb.cfg            xds100v2.cfg
 
 interface/ftdi:
-axm0432.cfg               hitex_str9-comstick.cfg    olimex-jtag-tiny.cfg
-calao-usb-a9260-c01.cfg   icebear.cfg                oocdlink.cfg
-calao-usb-a9260-c02.cfg   jtagkey2.cfg               opendous_ftdi.cfg
-cortino.cfg               jtagkey2p.cfg              openocd-usb.cfg
-dlp-usb1232h.cfg          jtagkey.cfg                openocd-usb-hs.cfg
-dp_busblaster.cfg         jtag-lock-pick_tiny_2.cfg  openrd.cfg
-flossjtag.cfg             kt-link.cfg                redbee-econotag.cfg
-flossjtag-noeeprom.cfg    lisa-l.cfg                 redbee-usb.cfg
-flyswatter2.cfg           luminary.cfg               sheevaplug.cfg
-flyswatter.cfg            luminary-icdi.cfg          signalyzer.cfg
-gw16042.cfg               luminary-lm3s811.cfg       signalyzer-lite.cfg
-hilscher_nxhx10_etm.cfg   minimodule.cfg             stm32-stick.cfg
+axm0432.cfg               hitex_lpc1768stick.cfg     olimex-arm-usb-tiny-h.cfg
+calao-usb-a9260-c01.cfg   hitex_str9-comstick.cfg    olimex-jtag-tiny.cfg
+calao-usb-a9260-c02.cfg   icebear.cfg                oocdlink.cfg
+cortino.cfg               jtagkey2.cfg               opendous_ftdi.cfg
+digilent-hs1.cfg          jtagkey2p.cfg              openocd-usb.cfg
+digilent-hs2.cfg          jtagkey.cfg                openocd-usb-hs.cfg
+dlp-usb1232h.cfg          jtag-lock-pick_tiny_2.cfg  openrd.cfg
+dp_busblaster.cfg         kt-link.cfg                redbee-econotag.cfg
+flossjtag.cfg             lisa-l.cfg                 redbee-usb.cfg
+flossjtag-noeeprom.cfg    luminary.cfg               sheevaplug.cfg
+flyswatter2.cfg           luminary-icdi.cfg          signalyzer.cfg
+flyswatter.cfg            luminary-lm3s811.cfg       signalyzer-lite.cfg
+gw16042.cfg               m53evk.cfg                 stm32-stick.cfg
+hilscher_nxhx10_etm.cfg   minimodule.cfg             tumpa.cfg
 hilscher_nxhx500_etm.cfg  neodb.cfg                  turtelizer2-revB.cfg
 hilscher_nxhx500_re.cfg   ngxtech.cfg                turtelizer2-revC.cfg
 hilscher_nxhx50_etm.cfg   olimex-arm-usb-ocd.cfg     vpaclink.cfg
 hilscher_nxhx50_re.cfg    olimex-arm-usb-ocd-h.cfg   xds100v2.cfg
-hitex_lpc1768stick.cfg    olimex-arm-usb-tiny-h.cfg
 $
 @end example
 @item @file{board} ...
@@ -7525,6 +7526,47 @@ the peripherals.
 @xref{targetevents,,Target Events}.
 @end deffn
 
+@section Intel Architecture
+
+Intel Quark X10xx is the first product in the Quark family of SoCs. It is an IA-32
+(Pentium x86 ISA) compatible SoC. The core CPU in the X10xx is codenamed Lakemont.
+Lakemont version 1 (LMT1) is used in X10xx. The CPU TAP (Lakemont TAP) is used for
+software debug and the CLTAP is used for SoC level operations.
+Useful docs are here: https://communities.intel.com/community/makers/documentation
+@itemize
+@item Intel Quark SoC X1000 OpenOCD/GDB/Eclipse App Note (web search for doc num 330015)
+@item Intel Quark SoC X1000 Debug Operations User Guide (web search for doc num 329866)
+@item Intel Quark SoC X1000 Datasheet (web search for doc num 329676)
+@end itemize
+
+@subsection x86 32-bit specific commands
+The three main address spaces for x86 are memory, I/O and configuration space.
+These commands allow a user to read and write to the 64Kbyte I/O address space.
+
+@deffn Command {x86_32 idw} address
+Display the contents of a 32-bit I/O port from address range 0x0000 - 0xffff.
+@end deffn
+
+@deffn Command {x86_32 idh} address
+Display the contents of a 16-bit I/O port from address range 0x0000 - 0xffff.
+@end deffn
+
+@deffn Command {x86_32 idb} address
+Display the contents of a 8-bit I/O port from address range 0x0000 - 0xffff.
+@end deffn
+
+@deffn Command {x86_32 iww} address
+Write the contents of a 32-bit I/O port to address range 0x0000 - 0xffff.
+@end deffn
+
+@deffn Command {x86_32 iwh} address
+Write the contents of a 16-bit I/O port to address range 0x0000 - 0xffff.
+@end deffn
+
+@deffn Command {x86_32 iwb} address
+Write the contents of a 8-bit I/O port to address range 0x0000 - 0xffff.
+@end deffn
+
 @section OpenRISC Architecture
 
 The OpenRISC CPU is a soft core. It is used in a programmable SoC which can be
diff --git a/src/helper/options.c b/src/helper/options.c
index a378131..88456eb 100644
--- a/src/helper/options.c
+++ b/src/helper/options.c
@@ -136,12 +136,14 @@ static void add_default_dirs(void)
 		add_script_search_dir(path);
 		free(path);
 	}
+	add_script_search_dir("../scripts");
+	add_script_search_dir("scripts");
 }
 
 int parse_cmdline_args(struct command_context *cmd_ctx, int argc, char *argv[])
 {
 	int c;
-	char command_buffer[128];
+	char command_buffer[1024];
 
 	while (1) {
 		/* getopt_long stores the option index here. */
@@ -164,7 +166,7 @@ int parse_cmdline_args(struct command_context *cmd_ctx, int argc, char *argv[])
 				break;
 			case 'f':		/* --file | -f */
 			{
-				snprintf(command_buffer, 128, "script {%s}", optarg);
+				snprintf(command_buffer, 1024, "script {%s}", optarg);
 				add_config_command(command_buffer);
 				break;
 			}
@@ -173,14 +175,14 @@ int parse_cmdline_args(struct command_context *cmd_ctx, int argc, char *argv[])
 				break;
 			case 'd':		/* --debug | -d */
 				if (optarg)
-					snprintf(command_buffer, 128, "debug_level %s", optarg);
+					snprintf(command_buffer, 1024, "debug_level %s", optarg);
 				else
-					snprintf(command_buffer, 128, "debug_level 3");
+					snprintf(command_buffer, 1024, "debug_level 3");
 				command_run_line(cmd_ctx, command_buffer);
 				break;
 			case 'l':		/* --log_output | -l */
 				if (optarg) {
-					snprintf(command_buffer, 128, "log_output %s", optarg);
+					snprintf(command_buffer, 1024, "log_output %s", optarg);
 					command_run_line(cmd_ctx, command_buffer);
 				}
 				break;
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index e07e513..db7578a 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -195,6 +195,7 @@ static int lisa_l_init(void);
 static int flossjtag_init(void);
 static int xds100v2_init(void);
 static int digilent_hs1_init(void);
+static int digilent_hs2_init(void);
 
 /* reset procedures for supported layouts */
 static void ftx23_reset(int trst, int srst);
@@ -214,6 +215,7 @@ static void ktlink_reset(int trst, int srst);
 static void redbee_reset(int trst, int srst);
 static void xds100v2_reset(int trst, int srst);
 static void digilent_hs1_reset(int trst, int srst);
+static void digilent_hs2_reset(int trst, int srst);
 
 /* blink procedures for layouts that support a blinking led */
 static void olimex_jtag_blink(void);
@@ -345,6 +347,10 @@ static const struct ft2232_layout  ft2232_layouts[] = {
 		.reset = digilent_hs1_reset,
 		.channel = INTERFACE_A,
 	},
+	{ .name = "digilent-hs2",
+		.init = digilent_hs2_init,
+		.reset = digilent_hs2_reset,
+	},
 	{ .name = NULL, /* END OF TABLE */ },
 };
 
@@ -4242,6 +4248,30 @@ static void digilent_hs1_reset(int trst, int srst)
 	/* Dummy function, no reset signals supported. */
 }
 
+/********************************************************************
+ * Support for Digilent HS-2
+ * http://www.digilentinc.com/Products/Detail.cfm?Prod=JTAG-HS2
+ *******************************************************************/
+static int digilent_hs2_init(void)
+{
+	/* the adapter only supports the base JTAG signals, no nTRST
+	   nor nSRST */
+	low_output	= 0xe8;
+	low_direction	= 0xeb;
+
+	/* initialize low byte for jtag */
+	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
+		LOG_ERROR("couldn't initialize FT2232 with 'digilent_hs2' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+	return ERROR_OK;
+}
+
+static void digilent_hs2_reset(int trst, int srst)
+{
+	/* Dummy function, no reset signals supported. */
+}
+
 static const struct command_registration ft2232_command_handlers[] = {
 	{
 		.name = "ft2232_device_desc",
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 6729df3..b0871df 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -617,11 +617,21 @@ static int gdb_get_packet_inner(struct connection *connection,
 				case '$':
 					break;
 				case '+':
-					/* gdb sends a dummy ack '+' at every remote connect - see
-					 * remote_start_remote (remote.c)
-					 * in case anyone tries to debug why they receive this
-					 * warning every time */
-					LOG_WARNING("acknowledgment received, but no packet pending");
+					/* According to the GDB documentation
+					 * (https://sourceware.org/gdb/onlinedocs/gdb/Packet-Acknowledgment.html):
+					 * "gdb sends a final `+` acknowledgment of the stub's `OK`
+					 * response, which can be safely ignored by the stub."
+					 * However OpenOCD server already is in noack mode at this
+					 * point and instead of ignoring this it was emitting a
+					 * warning. This code makes server ignore the first ACK
+					 * that will be received after going into noack mode,
+					 * warning only about subsequent ACK's. */
+					if (gdb_con->noack_mode > 1) {
+						LOG_WARNING("acknowledgment received, but no packet pending");
+					} else {
+						LOG_DEBUG("Received first acknowledgment after entering noack mode. Ignoring it.");
+						gdb_con->noack_mode = 2;
+					}
 					break;
 				case '-':
 					LOG_WARNING("negative acknowledgment, but no packet pending");
@@ -1874,6 +1884,8 @@ static const char *gdb_get_reg_type_name(enum reg_type type)
 			return "ieee_single";
 		case REG_TYPE_IEEE_DOUBLE:
 			return "ieee_double";
+		case REG_TYPE_i387_EXT:
+			return "i387_ext";
 		case REG_TYPE_ARCH_DEFINED:
 			return "int"; /* return arbitrary string to avoid compile warning. */
 	}
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 4d9ea41..b53d44a 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -35,6 +35,8 @@ libtarget_la_SOURCES = \
 	$(AVR32_SRC) \
 	$(MIPS32_SRC) \
 	$(NDS32_SRC) \
+	$(INTEL_IA32_SRC) \
+	$(ARC32_SRC) \
 	avrt.c \
 	dsp563xx.c \
 	dsp563xx_once.c \
@@ -124,6 +126,25 @@ NDS32_SRC = \
 	nds32_v3m.c \
 	nds32_aice.c
 
+INTEL_IA32_SRC = \
+	quark_x10xx.c \
+	quark_d2000.c \
+	quark_se.c \
+	lakemont.c \
+	x86_32_common.c
+
+ARC32_SRC = \
+	arc.c \
+	arc32.c \
+	arc_core.c \
+	arc_dbg.c \
+	arc_jtag.c \
+	arc_mem.c \
+	arc_mntr.c \
+	arc_ocd.c \
+	arc_regs.c \
+	arc_trgt.c
+
 
 noinst_HEADERS = \
 	algorithm.h \
@@ -191,7 +212,19 @@ noinst_HEADERS = \
 	nds32_v3_common.h \
 	nds32_v3.h \
 	nds32_v3m.h \
-	nds32_aice.h
+	nds32_aice.h \
+	lakemont.h \
+	x86_32_common.h \
+	arc.h \
+	arc32.h \
+	arc_core.h \
+	arc_dbg.h \
+	arc_jtag.h \
+	arc_mem.h \
+	arc_mntr.h \
+	arc_ocd.h \
+	arc_regs.h \
+	arc_trgt.h
 
 ocddatadir = $(pkglibdir)
 nobase_dist_ocddata_DATA =
diff --git a/src/target/arc.c b/src/target/arc.c
new file mode 100644
index 0000000..33d71de
--- /dev/null
+++ b/src/target/arc.c
@@ -0,0 +1,119 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+#include "quark_se.h"
+
+
+int quark_se_arc_write_memory(struct target *t, uint32_t addr, uint32_t size,
+			uint32_t count, const uint8_t *buf)
+{
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+				addr, size, count, buf);
+
+	if (t->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+	if (!count || !buf || !addr) {
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+					__func__, count, buf, addr);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	if (((addr >= FLASH0_BASE_ADDR) && (addr <= FLASH0_LIMT))
+			|| ((addr >= FLASH1_BASE_ADDR) && (addr <= FLASH1_LIMT))
+			|| ((addr >= ROM_BASE_ADDR) && (addr <= ROM_LIMIT))) {
+		/* Quark SE FLASH&ROM WRITE */
+		return quark_se_flash_write(t, addr, size, count, buf);
+	} else {
+		/* Quark SE SRAM WRITE */
+		return arc_mem_write(t, addr, size, count, buf);
+	}
+
+}
+
+int quark_se_arc_assert_reset(struct target *target)
+{
+	/* halt target before to restore memory */
+	if (target->state == TARGET_RUNNING) {
+		if (target_halt(target) != ERROR_OK) {
+			LOG_ERROR("%s could not halt target and therefore, "
+					"breakpoints in flash may not be deleted", __func__);
+		}
+	}
+	/* restore memory and delete breakpoints */
+	arc_dbg_reset_breakpoints_watchpoints(target);
+	/* do generic arc reset */
+	return arc_ocd_assert_reset(target);
+}
+
+struct target_type arc32_target = {
+	.name = "arc32",
+
+	.poll =	arc_ocd_poll,
+
+	.arch_state = arc32_arch_state,
+
+	.target_request_data = arc_trgt_request_data,
+
+	.halt = arc_dbg_halt,
+	.resume = arc_dbg_resume,
+	.step = arc_dbg_step,
+
+	.assert_reset = quark_se_arc_assert_reset,
+	.deassert_reset = arc_ocd_deassert_reset,
+
+	.soft_reset_halt = arc_core_soft_reset_halt,
+
+	.get_gdb_reg_list = arc_regs_get_gdb_reg_list,
+
+	.read_memory = arc_mem_read,
+	.write_memory = quark_se_arc_write_memory,
+	.checksum_memory = arc_mem_checksum,
+	.blank_check_memory = arc_mem_blank_check,
+
+	.add_breakpoint = arc_dbg_add_breakpoint,
+	.add_context_breakpoint = arc_dbg_add_context_breakpoint,
+	.add_hybrid_breakpoint = arc_dbg_add_hybrid_breakpoint,
+	.remove_breakpoint = arc_dbg_remove_breakpoint,
+	.add_watchpoint = arc_dbg_add_watchpoint,
+	.remove_watchpoint = arc_dbg_remove_watchpoint,
+
+	.run_algorithm = arc_mem_run_algorithm,
+	.start_algorithm = arc_mem_start_algorithm,
+	.wait_algorithm = arc_mem_wait_algorithm,
+
+	.commands = arc_monitor_command_handlers, /* see: arc_mntr.c|.h */
+
+	.target_create = arc_ocd_target_create,
+	.init_target = arc_ocd_init_target,
+	.examine = arc_ocd_examine,
+
+	.virt2phys = arc_mem_virt2phys,
+	.read_phys_memory = arc_mem_read_phys_memory,
+	.write_phys_memory = arc_mem_write_phys_memory,
+	.mmu = arc_mem_mmu,
+};
diff --git a/src/target/arc.h b/src/target/arc.h
new file mode 100644
index 0000000..94d5c7e
--- /dev/null
+++ b/src/target/arc.h
@@ -0,0 +1,59 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC_H
+#define ARC_H
+
+#include <helper/time_support.h>
+#include <jtag/jtag.h>
+
+#include "algorithm.h"
+#include "breakpoints.h"
+#include "jtag/interface.h"
+#include "register.h"
+#include "target.h"
+#include "target_request.h"
+#include "target_type.h"
+
+#include "arc32.h"
+#include "arc_core.h"
+#include "arc_dbg.h"
+#include "arc_jtag.h"
+#include "arc_mem.h"
+#include "arc_mntr.h"
+#include "arc_ocd.h"
+#include "arc_regs.h"
+#include "arc_trgt.h"
+
+#if defined _WIN32 || defined __CYGWIN__
+#include <windows.h>
+#define sleep(x) Sleep(x)
+#endif
+
+#define ARC_COMMON_MAGIC 0x1A471AC5  /* just a unique number */
+
+struct arc_common {
+	int common_magic;
+	bool is_4wire;
+	struct arc32_common arc32;
+};
+
+#endif /* ARC_H */
diff --git a/src/target/arc32.c b/src/target/arc32.c
new file mode 100644
index 0000000..f51b24b
--- /dev/null
+++ b/src/target/arc32.c
@@ -0,0 +1,610 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Mischa Jonker <mischa.jonker@synopsys.com>                            *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+
+/* ----- Supporting functions ---------------------------------------------- */
+
+static const char *arc_isa_strings[] = {
+	"ARC32", "ARC16"
+};
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc32_init_arch_info(struct target *target, struct arc32_common *arc32,
+	struct jtag_tap *tap)
+{
+	int retval = ERROR_OK;
+
+	arc32->common_magic = ARC32_COMMON_MAGIC;
+	target->arch_info = arc32;
+
+	arc32->fast_data_area = NULL;
+
+	arc32->jtag_info.tap = tap;
+	arc32->jtag_info.scann_size = 4;
+
+	/* has breakpoint/watchpoint unit been scanned */
+	arc32->bp_scanned = 0;
+
+	/*
+	 * TODO: number has to be determined dynamically querying register 0x76 (AP_BUILD)
+	 */
+	arc32->num_action_points_avail = 4;
+	arc32->num_action_points = 4;
+
+	/*
+	 * because checking return values from malloc is soooo 90's!
+	 * and if you don't have 48 bytes to give me probably you need to segfault anyways...
+	 */
+	arc32->action_point_list = malloc(sizeof(struct arc32_comparator) * arc32->num_action_points_avail);
+
+	for (int i = 0; i < arc32->num_action_points_avail; i++)
+		arc32->action_point_list[i].used = 0;
+
+	/* Flush D$ by default. It is safe to assume that D$ is present,
+	 * because if it isn't, there will be no error, just a slight
+	 * performance penalty from unnecessary JTAG operations. */
+	arc32->has_dcache = true;
+	arc32_reset_caches_states(target);
+
+	arc32->bcr_init = false;
+	arc32->gdb_compatibility_mode = true;
+
+	return retval;
+}
+
+/**
+ * Read register that are used in GDB g-packet. We don't read them one-by-one,
+ * but do that in one batch operation to improve speed. Calls to JTAG layer are
+ * expensive so it is better to make one big call that reads all necessary
+ * registers, instead of many calls, one for one register.
+ */
+int arc32_save_context(struct target *target)
+{
+	int retval = ERROR_OK;
+	unsigned int i;
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct reg *reg_list = arc32->core_cache->reg_list;
+
+	LOG_DEBUG("-");
+	assert(reg_list);
+
+	if (!arc32->bcr_init)
+		arc_regs_read_bcrs(target);
+
+	/* It is assumed that there is at least one AUX register in the list, for
+	 * example PC. */
+	const uint32_t core_regs_size = ARC_REG_FIRST_AUX * sizeof(uint32_t);
+	const uint32_t regs_to_scan = (arc32->gdb_compatibility_mode ?
+			ARC_TOTAL_NUM_REGS : ARC_REG_AFTER_GDB_GENERAL);
+	const uint32_t aux_regs_size = (regs_to_scan - ARC_REG_FIRST_AUX) *
+		sizeof(uint32_t);
+	uint32_t *core_values = malloc(core_regs_size);
+	uint32_t *aux_values = malloc(aux_regs_size);
+	uint32_t *core_addrs = malloc(core_regs_size);
+	uint32_t *aux_addrs = malloc(aux_regs_size);
+	unsigned int core_cnt = 0;
+	unsigned int aux_cnt = 0;
+
+	if (!core_values || !core_addrs || !aux_values || !aux_addrs)  {
+		LOG_ERROR("Not enough memory");
+		retval = ERROR_FAIL;
+		goto exit;
+	}
+
+	memset(core_values, 0xdeadbeef, core_regs_size);
+	memset(core_addrs, 0xdeadbeef, core_regs_size);
+	memset(aux_values, 0xdeadbeef, aux_regs_size);
+	memset(aux_addrs, 0xdeadbeef, aux_regs_size);
+
+	for (i = 0; i < regs_to_scan; i++) {
+		struct reg *reg = &(reg_list[i]);
+		struct arc_reg_t *arc_reg = reg->arch_info;
+		if (!reg->valid && reg->exist && !arc_reg->dummy) {
+			if (arc_reg->desc->regnum < ARC_REG_FIRST_AUX) {
+				/* core reg */
+				core_addrs[core_cnt] = arc_reg->desc->addr;
+				core_cnt += 1;
+			} else {
+				/* aux reg */
+				aux_addrs[aux_cnt] = arc_reg->desc->addr;
+				aux_cnt += 1;
+			}
+		}
+	}
+
+	/* Read data from target. */
+	retval = arc_jtag_read_core_reg(&arc32->jtag_info, core_addrs, core_cnt, core_values);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Attempt to read core registers failed.");
+		retval = ERROR_FAIL;
+		goto exit;
+	}
+	retval = arc_jtag_read_aux_reg(&arc32->jtag_info, aux_addrs, aux_cnt, aux_values);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Attempt to read aux registers failed.");
+		retval = ERROR_FAIL;
+		goto exit;
+	}
+
+	/* Parse core regs */
+	core_cnt = 0;
+	for (i = 0; i < ARC_REG_FIRST_AUX; i++) {
+		struct reg *reg = &(reg_list[i]);
+		struct arc_reg_t *arc_reg = reg->arch_info;
+		if (!reg->valid && reg->exist) {
+			if (!arc_reg->dummy) {
+				arc_reg->value = core_values[core_cnt];
+				core_cnt += 1;
+			} else {
+				arc_reg->value = 0;
+			}
+			buf_set_u32(reg->value, 0, 32, arc_reg->value);
+			reg->valid = true;
+			reg->dirty = false;
+			LOG_DEBUG("Get core register regnum=%" PRIu32 ", name=%s, value=0x%08" PRIx32,
+				i , arc_reg->desc->name, arc_reg->value);
+		}
+	}
+
+	/* Parse aux regs */
+	aux_cnt = 0;
+	for (i = ARC_REG_FIRST_AUX; i < regs_to_scan; i++) {
+		struct reg *reg = &(reg_list[i]);
+		struct arc_reg_t *arc_reg = reg->arch_info;
+		if (!reg->valid && reg->exist) {
+			if (!arc_reg->dummy) {
+				arc_reg->value = aux_values[aux_cnt];
+				aux_cnt += 1;
+			} else {
+				arc_reg->value = 0;
+			}
+			buf_set_u32(reg->value, 0, 32, arc_reg->value);
+			reg->valid = true;
+			reg->dirty = false;
+			LOG_DEBUG("Get aux register regnum=%" PRIu32 ", name=%s, value=0x%" PRIx32,
+				i , arc_reg->desc->name, arc_reg->value);
+		}
+	}
+
+exit:
+	free(core_values);
+	free(core_addrs);
+	free(aux_values);
+	free(aux_addrs);
+
+	return retval;
+}
+
+/**
+ * See arc32_save_context() for reason why we want to dump all regs at once.
+ * This however means that if there are dependencies between registers they
+ * will not be observable until target will be resumed.
+ */
+int arc32_restore_context(struct target *target)
+{
+	int retval = ERROR_OK;
+	unsigned int i;
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct reg *reg_list = arc32->core_cache->reg_list;
+
+	LOG_DEBUG("-");
+	assert(reg_list);
+
+	if (!arc32->bcr_init) {
+		LOG_ERROR("Attempt to restore context before saving it first.");
+		return ERROR_FAIL;
+	}
+
+	/* It is assumed that there is at least one AUX register in the list. */
+	const uint32_t core_regs_size = ARC_REG_AFTER_CORE_EXT * sizeof(uint32_t);
+	const uint32_t aux_regs_size = (ARC_REG_AFTER_AUX - ARC_REG_FIRST_AUX) *
+		sizeof(uint32_t);
+	uint32_t *core_values = malloc(core_regs_size);
+	uint32_t *aux_values = malloc(aux_regs_size);
+	uint32_t *core_addrs = malloc(core_regs_size);
+	uint32_t *aux_addrs = malloc(aux_regs_size);
+	unsigned int core_cnt = 0;
+	unsigned int aux_cnt = 0;
+
+	if (!core_values || !core_addrs || !aux_values || !aux_addrs)  {
+		LOG_ERROR("Not enough memory");
+		retval = ERROR_FAIL;
+		goto exit;
+	}
+
+	memset(core_values, 0xdeadbeef, core_regs_size);
+	memset(core_addrs, 0xdeadbeef, core_regs_size);
+	memset(aux_values, 0xdeadbeef, aux_regs_size);
+	memset(aux_addrs, 0xdeadbeef, aux_regs_size);
+
+	for (i = 0; i < ARC_REG_AFTER_AUX; i++) {
+		struct reg *reg = &(reg_list[i]);
+		struct arc_reg_t *arc_reg = reg->arch_info;
+		if (reg->valid && reg->exist && reg->dirty) {
+			LOG_DEBUG("Will write regnum=%u", i);
+			if (arc_reg->desc->regnum < ARC_REG_FIRST_AUX) {
+				/* core reg */
+				core_addrs[core_cnt] = arc_reg->desc->addr;
+				core_values[core_cnt] = arc_reg->value;
+				core_cnt += 1;
+			} else {
+				/* aux reg */
+				aux_addrs[aux_cnt] = arc_reg->desc->addr;
+				aux_values[aux_cnt] = arc_reg->value;
+				aux_cnt += 1;
+			}
+		}
+	}
+
+	/* Write data to target. */
+	/* JTAG layer will return quickly if count == 0. */
+	retval = arc_jtag_write_core_reg(&arc32->jtag_info, core_addrs, core_cnt, core_values);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Attempt to write to core registers failed.");
+		retval = ERROR_FAIL;
+		goto exit;
+	}
+	retval = arc_jtag_write_aux_reg(&arc32->jtag_info, aux_addrs, aux_cnt, aux_values);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Attempt to write to aux registers failed.");
+		retval = ERROR_FAIL;
+		goto exit;
+	}
+
+exit:
+	free(core_values);
+	free(core_addrs);
+	free(aux_values);
+	free(aux_addrs);
+
+	return retval;
+}
+
+int arc32_enable_interrupts(struct target *target, int enable)
+{
+	int retval = ERROR_OK;
+	uint32_t value;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	if (enable) {
+		/* enable interrupts */
+		value = SET_CORE_ENABLE_INTERRUPTS;
+		retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_IENABLE_REG, value);
+		LOG_DEBUG("interrupts enabled [stat:%i]", retval);
+	} else {
+		/* disable interrupts */
+		value = SET_CORE_DISABLE_INTERRUPTS;
+		retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_IENABLE_REG, value);
+		LOG_DEBUG("interrupts disabled [stat:%i]", retval);
+	}
+
+	return retval;
+}
+
+int arc32_start_core(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t value;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	target->state = TARGET_RUNNING;
+
+	retval = arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_STATUS32_REG, &value);
+	value &= ~SET_CORE_HALT_BIT;        /* clear the HALT bit */
+	retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_STATUS32_REG, value);
+	LOG_DEBUG("Core started to run");
+
+#ifdef DEBUG
+	arc32_print_core_state(target);
+#endif
+	return retval;
+}
+
+int arc32_config_step(struct target *target, int enable_step)
+{
+	int retval = ERROR_OK;
+	uint32_t value;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	if (enable_step) {
+		/* enable core debug step mode */
+		retval = arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_STATUS32_REG,
+			&value);
+		value &= ~SET_CORE_AE_BIT; /* clear the AE bit */
+		retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_STATUS32_REG,
+			value);
+		LOG_DEBUG(" [status32:0x%08" PRIx32 "] [stat:%i]", value, retval);
+
+		//retval = arc_jtag_read_aux_reg(&arc32->jtag_info, AUX_DEBUG_REG, &value);
+		value = SET_CORE_SINGLE_INSTR_STEP; /* set the IS bit */
+
+		if (arc32->processor_type == ARC600_NUM) {
+			value |= SET_CORE_SINGLE_STEP;  /* set the SS bit */
+			LOG_DEBUG("ARC600 extra single step bit to set.");
+		}
+
+		retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG,
+			value);
+		LOG_DEBUG("core debug step mode enabled [debug-reg:0x%08" PRIx32 "] [stat:%i]",
+			value, retval);
+	} else {
+		/* disable core debug step mode */
+		retval = arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG,
+			&value);
+		value &= ~SET_CORE_SINGLE_INSTR_STEP; /* clear the IS bit */
+		retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG,
+			value);
+		LOG_DEBUG("core debug step mode disabled [stat:%i]", retval);
+	}
+
+#ifdef DEBUG
+	arc32_print_core_state(target);
+#endif
+	return retval;
+}
+
+/* This function is cheap to call and returns quickly if caches already has
+ * been invalidated since core had been halted. */
+int arc32_cache_invalidate(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t value, backup;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	/* Don't waste time if already done. */
+	if (arc32->cache_invalidated)
+	    return ERROR_OK;
+
+	LOG_DEBUG("Invalidating I$ & D$.");
+
+	value = IC_IVIC_INVALIDATE;	/* invalidate I$ */
+	retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_IC_IVIC_REG, value);
+	retval = arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_DC_CTRL_REG, &value);
+
+	backup = value;
+	value = value & ~DC_CTRL_IM;
+
+	/* set DC_CTRL invalidate mode to invalidate-only (no flushing!!) */
+	retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DC_CTRL_REG, value);
+	value = DC_IVDC_INVALIDATE;	/* invalidate D$ */
+	retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DC_IVDC_REG, value);
+
+	/* restore DC_CTRL invalidate mode */
+	retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DC_CTRL_REG, backup);
+
+	arc32->cache_invalidated = true;
+
+	return retval;
+}
+
+/* Flush data cache. This function is cheap to call and return quickly if D$
+ * already has been flushed since target had been halted. JTAG debugger reads
+ * values directly from memory, bypassing cache, so if there are unflushed
+ * lines debugger will read invalid values, which will cause a lot of troubles.
+ * */
+int arc32_dcache_flush(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t value, dc_ctrl_value;
+	bool has_to_set_dc_ctrl_im;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	/* Don't waste time if already done. */
+	if (!arc32->has_dcache || arc32->dcache_flushed)
+	    return ERROR_OK;
+
+	LOG_DEBUG("Flushing D$.");
+
+	/* Store current value of DC_CTRL */
+	retval = arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_DC_CTRL_REG, &dc_ctrl_value);
+	if (ERROR_OK != retval)
+	    return retval;
+
+	/* Set DC_CTRL invalidate mode to flush (if not already set) */
+	has_to_set_dc_ctrl_im = (dc_ctrl_value & DC_CTRL_IM) == 0;
+	if (has_to_set_dc_ctrl_im) {
+		value = dc_ctrl_value | DC_CTRL_IM;
+		retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DC_CTRL_REG, value);
+		if (ERROR_OK != retval)
+		    return retval;
+	}
+
+	/* Flush D$ */
+	value = DC_IVDC_INVALIDATE;
+	retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DC_IVDC_REG, value);
+
+	/* Restore DC_CTRL invalidate mode (even of flush failed) */
+	if (has_to_set_dc_ctrl_im) {
+	    retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DC_CTRL_REG, dc_ctrl_value);
+	}
+
+	arc32->dcache_flushed = true;
+
+	return retval;
+}
+
+int arc32_wait_until_core_is_halted(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t value = 1; /* get us into checking for HALT bit */
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+//#ifdef DEBUG
+	arc32_print_core_state(target);
+//#endif
+
+	/*
+	 * check if bit N starting from 0 is set; temp & (1 << N)
+	 *   here, lets check if we are HALTED
+	 */
+	arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_STATUS32_REG, &value);
+	while (!(value & 1)) {
+		arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_STATUS32_REG, &value);
+	}
+
+#ifdef DEBUG
+	arc32_print_core_state(target);
+#endif
+
+	return retval;
+}
+
+int arc32_print_core_state(struct target *target)
+{
+	int retval = ERROR_OK;
+	struct arc32_common *arc32 = target_to_arc32(target);
+	uint32_t value;
+
+	arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG, &value);
+	LOG_DEBUG("  AUX REG  [DEBUG]: 0x%08" PRIx32, value);
+	arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_STATUS32_REG, &value);
+	LOG_DEBUG("        [STATUS32]: 0x%08" PRIx32, value);
+	arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_STATUS_REG, &value);
+	LOG_DEBUG("          [STATUS]: 0x%08" PRIx32, value);
+	arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_PC_REG, &value);
+	LOG_DEBUG("              [PC]: 0x%08" PRIx32, value);
+
+	return retval;
+}
+
+int arc32_arch_state(struct target *target)
+{
+	int retval = ERROR_OK;
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	LOG_DEBUG("target state: %s in: %s mode, PC at: 0x%08" PRIx32,
+		target_state_name(target),
+		arc_isa_strings[arc32->isa_mode],
+		buf_get_u32(arc32->core_cache->reg_list[ARC_REG_PC].value, 0, 32));
+
+
+	return retval;
+}
+
+int arc32_get_current_pc(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t dpc;
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	/* read current PC */
+	retval = arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_PC_REG, &dpc);
+
+	/* save current PC */
+	buf_set_u32(arc32->core_cache->reg_list[ARC_REG_PC].value, 0, 32, dpc);
+
+	return retval;
+}
+
+/**
+ * Reset internal states of caches. Must be called when entering debugging.
+ *
+ * @param target Target for which to reset caches states.
+ */
+int arc32_reset_caches_states(struct target *target)
+{
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	LOG_DEBUG("Resetting internal variables of caches states");
+
+	/* Reset caches states. */
+	arc32->dcache_flushed = false;
+	arc32->cache_invalidated = false;
+
+	return ERROR_OK;
+}
+
+/**
+ * Write 4-byte instruction to memory. This is like target_write_u32, however
+ * in case of little endian ARC instructions are in middle endian format, not
+ * little endian, so different type of conversion should be done.
+ */
+int arc32_write_instruction_u32(struct target *target, uint32_t address,
+	uint32_t instr)
+{
+    int retval;
+    uint8_t value_buf[4];
+    if (!target_was_examined(target)) {
+        LOG_ERROR("Target not examined yet");
+        return ERROR_FAIL;
+    }
+
+    LOG_DEBUG("Address: 0x%08" PRIx32 ", value: 0x%08" PRIx32, address,
+		instr);
+
+    if (target->endianness == TARGET_LITTLE_ENDIAN) {
+        arc32_h_u32_to_me(value_buf, instr);
+    } else{
+        h_u32_to_be(value_buf, instr);
+    }
+
+    retval = target_write_buffer(target, address, 4, value_buf);
+    if (retval != ERROR_OK)
+        LOG_ERROR("Write to 0x%08" PRIx32 " failed, errno=%i", address, retval);
+
+    return retval;
+}
+
+/**
+ * Read 32-bit instruction from memory. It is like target_read_u32, however in
+ * case of little endian ARC instructions are in middle endian format, so
+ * different type of conversion should be done.
+ */
+int arc32_read_instruction_u32(struct target *target, uint32_t address,
+		uint32_t *value)
+{
+    uint8_t value_buf[4];
+    if (!target_was_examined(target)) {
+        LOG_ERROR("Target not examined yet");
+        return ERROR_FAIL;
+    }
+
+    int retval = target_read_buffer(target, address, 4, value_buf);
+
+    if (retval == ERROR_OK) {
+		if (target->endianness == TARGET_LITTLE_ENDIAN)
+			*value = arc32_me_to_h_u32(value_buf);
+		else
+			*value = be_to_h_u32(value_buf);
+        LOG_DEBUG("Address: 0x%08" PRIx32 ", value: 0x%08" PRIx32, address,
+            *value);
+    } else {
+        *value = 0x0;
+        LOG_ERROR("Read from address: 0x%08" PRIx32 " failed, errno=%i",
+			address, retval);
+    }
+
+    return retval;
+}
+
diff --git a/src/target/arc32.h b/src/target/arc32.h
new file mode 100644
index 0000000..25ce356
--- /dev/null
+++ b/src/target/arc32.h
@@ -0,0 +1,164 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC32_H
+#define ARC32_H
+
+#include "arc_jtag.h"
+#include "arc_regs.h"
+
+
+#define ARC32_COMMON_MAGIC	0xB32EB324  /* just a unique number */
+
+/* supported ARC processor types */
+enum arc_processor_type {
+	ARCEM_NUM	= 1,
+	ARC600_NUM,
+	ARC700_NUM
+};
+
+#define ARCEM_STR	"arc-em"
+#define ARC600_STR	"arc600"
+#define ARC700_STR	"arc700"
+
+/* ARC core ARCompatISA register set */
+enum arc32_isa_mode {
+	ARC32_ISA_ARC32 = 0,
+	ARC32_ISA_ARC16 = 1,
+};
+
+/* offsets into arc32 core register cache */
+struct arc32_comparator {
+	int used;
+	uint32_t bp_value;
+	uint32_t reg_address;
+};
+
+struct arc32_common {
+	uint32_t common_magic;
+	void *arch_info;
+
+	struct arc_jtag jtag_info;
+
+	struct reg_cache *core_cache;
+
+	enum arc_processor_type processor_type;
+	enum arc32_isa_mode     isa_mode;
+
+	/* working area for fastdata access */
+	struct working_area *fast_data_area;
+
+	int bp_scanned;
+
+	/* action point */
+	int num_action_points;
+	int num_action_points_avail;
+	struct arc32_comparator *action_point_list;
+
+	/* Cache control */
+	bool has_dcache;
+	/* If true, then D$ has been already flushed since core has been
+	 * halted. */
+	bool dcache_flushed;
+	/* If true, then caches have been already flushed since core has been
+	 * halted. */
+	bool cache_invalidated;
+
+	/* If BCRs have been read and and optioanl registers have been proeprly
+	 * assigned whether they exist or not. */
+	bool bcr_init;
+	/* Whether to support old ARC GDB that doesn't understand XML target
+	 * descriptions. */
+	bool gdb_compatibility_mode;
+	/* Store values of BCR permanently. */
+	struct bcr_set_t bcr_set;
+};
+
+//#define ARC32_FASTDATA_HANDLER_SIZE	0x8000 /* haps51 */
+#define ARC32_FASTDATA_HANDLER_SIZE	0x10000  /* 64Kb */
+
+/* ARC 32bits Compact v2 opcodes */
+#define ARC32_SDBBP 0x256F003F  /* BRK */
+
+/* ARC 16bits Compact v2 opcodes */
+#define ARC16_SDBBP 0x7FFF      /* BRK_S */
+
+/* ----- Inlined functions ------------------------------------------------- */
+
+/**
+ * Convert data in host endianness to the middle endian. This is required to
+ * write 4-byte instructions.
+ */
+static inline void arc32_h_u32_to_me(uint8_t* buf, int val)
+{
+    buf[1] = (uint8_t) (val >> 24);
+    buf[0] = (uint8_t) (val >> 16);
+    buf[3] = (uint8_t) (val >> 8);
+    buf[2] = (uint8_t) (val >> 0);
+}
+
+/**
+ * Convert data in middle endian to host endian. This is required to read 32-bit
+ * instruction from little endian ARCs.
+ */
+static inline uint32_t arc32_me_to_h_u32(const uint8_t* buf)
+{
+    return (uint32_t)(buf[2] | buf[3] << 8 | buf[0] << 16 | buf[1] << 24);
+}
+
+static inline struct arc32_common * target_to_arc32(struct target *target)
+{
+	return target->arch_info;
+}
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc32_init_arch_info(struct target *target, struct arc32_common *arc32,
+	struct jtag_tap *tap);
+
+struct reg_cache *arc32_build_reg_cache(struct target *target);
+
+int arc32_save_context(struct target *target);
+int arc32_restore_context(struct target *target);
+
+int arc32_enable_interrupts(struct target *target, int enable);
+
+int arc32_start_core(struct target *target);
+
+int arc32_config_step(struct target *target, int enable_step);
+
+int arc32_cache_invalidate(struct target *target);
+
+int arc32_wait_until_core_is_halted(struct target *target);
+
+int arc32_print_core_state(struct target *target);
+int arc32_arch_state(struct target *target);
+int arc32_get_current_pc(struct target *target);
+int arc32_dcache_flush(struct target *target);
+
+int arc32_reset_caches_states(struct target *target);
+
+int arc32_write_instruction_u32(struct target *target, uint32_t address,
+		uint32_t instr);
+int arc32_read_instruction_u32(struct target *target, uint32_t address,
+		uint32_t *value);
+
+#endif /* ARC32_H */
diff --git a/src/target/arc_core.c b/src/target/arc_core.c
new file mode 100644
index 0000000..8f55117
--- /dev/null
+++ b/src/target/arc_core.c
@@ -0,0 +1,70 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Mischa Jonker <mischa.jonker@synopsys.com>                            *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_core_soft_reset_halt(struct target *target)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("Soft reset halt is NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+int arc_core_type_info(struct target *target)
+{
+	int retval = ERROR_OK;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	/* TODO: detection of the target shouldn't be based on the name, which is
+	 * an arbitrary string, check if a better way exists.
+	 * For the time being add our supported names in the checks below.
+	 */
+	if (strncmp(target_name(target), ARCEM_STR, 6) == 0) {
+		arc32->processor_type = ARCEM_NUM;
+		LOG_USER("Processor type: %s", ARCEM_STR);
+
+	} else if (strncmp(target_name(target), "quark_se.arc-em", 15) == 0) {
+		arc32->processor_type = ARCEM_NUM;
+		LOG_USER("Processor type: %s", ARCEM_STR);
+
+	} else if (strncmp(target_name(target), ARC600_STR, 6) == 0) {
+		arc32->processor_type = ARC600_NUM;
+		LOG_USER("Processor type: %s", ARC600_STR);
+
+	} else if (strncmp(target_name(target), ARC700_STR, 6) == 0) {
+		arc32->processor_type = ARC700_NUM;
+		LOG_USER("Processor type: %s", ARC700_STR);
+
+	} else
+	LOG_WARNING(" THIS IS A UNSUPPORTED TARGET: %s", target_name(target));
+
+	return retval;
+}
diff --git a/src/target/arc_core.h b/src/target/arc_core.h
new file mode 100644
index 0000000..4630160
--- /dev/null
+++ b/src/target/arc_core.h
@@ -0,0 +1,31 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC_CORE_H
+#define ARC_CORE_H
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_core_soft_reset_halt(struct target *target);
+
+int arc_core_type_info(struct target *target);
+
+#endif /* ARC_CORE_H */
diff --git a/src/target/arc_dbg.c b/src/target/arc_dbg.c
new file mode 100644
index 0000000..6dc0121
--- /dev/null
+++ b/src/target/arc_dbg.c
@@ -0,0 +1,869 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Mischa Jonker <mischa.jonker@synopsys.com>                            *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+
+/* ----- Supporting functions ---------------------------------------------- */
+static int arc_dbg_configure_actionpoint(struct target *target, uint32_t ap_num,
+	uint32_t match_value, uint32_t control_tt, uint32_t control_at)
+{
+	struct arc32_common *arc32 = target_to_arc32(target);
+	uint32_t ap_reg_id = ap_num * AP_STRUCT_LEN;
+
+	if (control_tt != AP_AC_TT_DISABLE) {
+
+		if (arc32->num_action_points_avail < 1) {
+			LOG_ERROR("No ActionPoint free, maximim amount is %" PRIu32,
+					arc32->num_action_points);
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+
+		arc_jtag_write_aux_reg_one(&arc32->jtag_info, AP_AMV_BASE + ap_reg_id,
+				match_value);
+		arc_jtag_write_aux_reg_one(&arc32->jtag_info, AP_AMM_BASE + ap_reg_id, 0x0);
+		arc_jtag_write_aux_reg_one(&arc32->jtag_info, AP_AC_BASE  + ap_reg_id,
+				control_tt | control_at);
+		arc32->num_action_points_avail--;
+	} else {
+		arc_jtag_write_aux_reg_one(&arc32->jtag_info, AP_AC_BASE  + ap_reg_id, AP_AC_TT_DISABLE);
+		arc32->num_action_points_avail++;
+	}
+
+	return ERROR_OK;
+}
+
+static int arc_dbg_set_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
+{
+	int retval = ERROR_OK;
+
+	if (breakpoint->set) {
+		LOG_WARNING("breakpoint already set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD) {
+		struct arc32_common *arc32 = target_to_arc32(target);
+		struct arc32_comparator *comparator_list = arc32->action_point_list;
+		int bp_num = 0;
+
+		while (comparator_list[bp_num].used)
+			bp_num++;
+
+		if (bp_num >= arc32->num_action_points) {
+			LOG_ERROR("No ActionPoint free, maximim amount is %" PRIu32,
+					arc32->num_action_points);
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+
+		retval = arc_dbg_configure_actionpoint(target, bp_num,
+				breakpoint->address, AP_AC_TT_READWRITE, AP_AC_AT_INST_ADDR);
+
+		if (retval == ERROR_OK) {
+			breakpoint->set = bp_num + 1;
+			comparator_list[bp_num].used = 1;
+			comparator_list[bp_num].bp_value = breakpoint->address;
+
+			LOG_DEBUG("bpid: %" PRIu32 ", bp_num %i bp_value 0x%" PRIx32,
+					breakpoint->unique_id, bp_num, comparator_list[bp_num].bp_value);
+		}
+
+	} else if (breakpoint->type == BKPT_SOFT) {
+		LOG_DEBUG("bpid: %" PRIu32, breakpoint->unique_id);
+
+		if (breakpoint->length == 4) { /* WAS: == 4) { but we have only 32 bits access !!*/
+			uint32_t verify = 0xffffffff;
+
+			retval = target_read_buffer(target, breakpoint->address, breakpoint->length,
+					breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = arc32_write_instruction_u32(target, breakpoint->address,
+					ARC32_SDBBP);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = arc32_read_instruction_u32(target, breakpoint->address, &verify);
+
+			if (retval != ERROR_OK)
+				return retval;
+				if (verify != ARC32_SDBBP) {
+				LOG_ERROR("Unable to set 32bit breakpoint at address %08" PRIx32
+						" - check that memory is read/writable", breakpoint->address);
+				return ERROR_OK;
+			}
+		} else if (breakpoint->length == 2) {
+			uint16_t verify = 0xffff;
+
+			retval = target_read_buffer(target, breakpoint->address, breakpoint->length,
+					breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = target_write_u16(target, breakpoint->address, ARC16_SDBBP);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = target_read_u16(target, breakpoint->address, &verify);
+			if (retval != ERROR_OK)
+				return retval;
+			if (verify != ARC16_SDBBP) {
+				LOG_ERROR("Unable to set 16bit breakpoint at address %08" PRIx32
+						" - check that memory is read/writable", breakpoint->address);
+				return ERROR_OK;
+			}
+		} else {
+			LOG_ERROR("Invalid breakpoint length: target supports only 2 or 4");
+			return ERROR_COMMAND_ARGUMENT_INVALID;
+		}
+
+		/* core instruction cache is now invalid */
+		arc32_cache_invalidate(target);
+
+		breakpoint->set = 64; /* Any nice value but 0 */
+	}
+
+	return retval;
+}
+
+static int arc_dbg_unset_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
+{
+	/* get pointers to arch-specific information */
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct arc32_comparator *comparator_list = arc32->action_point_list;
+	int retval;
+
+	if (!breakpoint->set) {
+		LOG_WARNING("breakpoint not set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD) {
+		int bp_num = breakpoint->set - 1;
+		if ((bp_num < 0) || (bp_num >= arc32->num_action_points)) {
+			LOG_DEBUG("Invalid ActionPoint ID: %" PRIu32 " in breakpoint: %" PRIu32,
+					  bp_num, breakpoint->unique_id);
+			return ERROR_OK;
+		}
+
+		retval =  arc_dbg_configure_actionpoint(target, bp_num,
+						breakpoint->address, AP_AC_TT_DISABLE, AP_AC_AT_INST_ADDR);
+
+		if (retval == ERROR_OK) {
+			breakpoint->set = 0;
+			comparator_list[bp_num].used = 0;
+			comparator_list[bp_num].bp_value = 0;
+
+			LOG_DEBUG("bpid: %" PRIu32 " - released ActionPoint ID: %i",
+					breakpoint->unique_id, bp_num);
+		}
+
+	} else {
+		/* restore original instruction (kept in target endianness) */
+		LOG_DEBUG("bpid: %" PRIu32, breakpoint->unique_id);
+		if (breakpoint->length == 4) {
+			uint32_t current_instr;
+
+			/* check that user program has not modified breakpoint instruction */
+			retval = arc32_read_instruction_u32(target, breakpoint->address, &current_instr);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if (current_instr == ARC32_SDBBP) {
+				target->running_alg = 1;
+				retval = target_write_buffer(target, breakpoint->address,
+					breakpoint->length, breakpoint->orig_instr);
+				target->running_alg = 0;
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		} else if (breakpoint->length == 2) {
+			uint16_t current_instr;
+
+			/* check that user program has not modified breakpoint instruction */
+			retval = target_read_memory(target, breakpoint->address, 2, 1,
+					(uint8_t *)&current_instr);
+			if (retval != ERROR_OK)
+				return retval;
+			current_instr = target_buffer_get_u16(target, (uint8_t *)&current_instr);
+			if (current_instr == ARC16_SDBBP) {
+				target->running_alg = 1;
+				retval = target_write_buffer(target, breakpoint->address,
+					breakpoint->length, breakpoint->orig_instr);
+				target->running_alg = 0;
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		} else {
+			LOG_ERROR("Invalid breakpoint length: target supports only 2 or 4");
+			return ERROR_COMMAND_ARGUMENT_INVALID;
+		}
+		breakpoint->set = 0;
+	}
+
+	/* core instruction cache is now invalid */
+	arc32_cache_invalidate(target);
+
+	return retval;
+}
+
+static void arc_dbg_enable_breakpoints(struct target *target)
+{
+	struct breakpoint *breakpoint = target->breakpoints;
+
+	/* set any pending breakpoints */
+	while (breakpoint) {
+		if (breakpoint->set == 0)
+			arc_dbg_set_breakpoint(target, breakpoint);
+		breakpoint = breakpoint->next;
+	}
+}
+
+static int arc_dbg_set_watchpoint(struct target *target,
+		struct watchpoint *watchpoint)
+{
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct arc32_comparator *comparator_list = arc32->action_point_list;
+
+	if (watchpoint->set) {
+		LOG_WARNING("watchpoint already set");
+		return ERROR_OK;
+	}
+
+	int wp_num = 0;
+	while (comparator_list[wp_num].used)
+		wp_num++;
+
+	if (wp_num >= arc32->num_action_points) {
+		LOG_ERROR("No ActionPoint free, maximim amount is %" PRIu32,
+				arc32->num_action_points);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+	/*
+	 * TODO: Verify documentation, just tried and worked fine!!
+	if (watchpoint->length != 4) {
+		LOG_ERROR("Only watchpoints of length 4 are supported");
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+	}
+
+	if (watchpoint->address % 4) {
+		LOG_ERROR("Watchpoints address should be word aligned");
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+	}
+	*/
+
+	int enable = AP_AC_TT_DISABLE;
+	switch (watchpoint->rw) {
+		case WPT_READ:
+			enable = AP_AC_TT_READ;
+			break;
+		case WPT_WRITE:
+			enable = AP_AC_TT_WRITE;
+			break;
+		case WPT_ACCESS:
+			enable = AP_AC_TT_READWRITE;
+			break;
+		default:
+			LOG_ERROR("BUG: watchpoint->rw neither read, write nor access");
+			return ERROR_FAIL;
+	}
+
+	int retval =  arc_dbg_configure_actionpoint(target, wp_num,
+					watchpoint->address, enable, AP_AC_AT_MEMORY_ADDR);
+
+	if (retval == ERROR_OK) {
+		watchpoint->set = wp_num + 1;
+		comparator_list[wp_num].used = 1;
+		comparator_list[wp_num].bp_value = watchpoint->address;
+
+		LOG_DEBUG("wpid: %" PRIu32 ", bp_num %i bp_value 0x%" PRIx32,
+				watchpoint->unique_id, wp_num, comparator_list[wp_num].bp_value);
+	}
+
+	return retval;
+}
+
+static int arc_dbg_unset_watchpoint(struct target *target,
+		struct watchpoint *watchpoint)
+{
+	/* get pointers to arch-specific information */
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct arc32_comparator *comparator_list = arc32->action_point_list;
+
+	if (!watchpoint->set) {
+		LOG_WARNING("watchpoint not set");
+		return ERROR_OK;
+	}
+
+	int wp_num = watchpoint->set - 1;
+	if ((wp_num < 0) || (wp_num >= arc32->num_action_points)) {
+		LOG_DEBUG("Invalid ActionPoint ID: %" PRIu32 " in watchpoint: %" PRIu32,
+				wp_num, watchpoint->unique_id);
+		return ERROR_OK;
+	}
+
+	int retval =  arc_dbg_configure_actionpoint(target, wp_num,
+				watchpoint->address, AP_AC_TT_DISABLE, AP_AC_AT_MEMORY_ADDR);
+
+	if (retval == ERROR_OK) {
+		watchpoint->set = 0;
+		comparator_list[wp_num].used = 0;
+		comparator_list[wp_num].bp_value = 0;
+
+		LOG_DEBUG("wpid: %" PRIu32 " - releasing ActionPoint ID: %i",
+				watchpoint->unique_id, wp_num);
+	}
+
+	return retval;
+}
+
+static void arc_dbg_enable_watchpoints(struct target *target)
+{
+	struct watchpoint *watchpoint = target->watchpoints;
+
+	/* set any pending watchpoints */
+	while (watchpoint) {
+		if (watchpoint->set == 0)
+			arc_dbg_set_watchpoint(target, watchpoint);
+		watchpoint = watchpoint->next;
+	}
+}
+
+static int arc_dbg_single_step_core(struct target *target)
+{
+	arc_dbg_debug_entry(target);
+
+	/* disable interrupts while stepping */
+	arc32_enable_interrupts(target, 0);
+
+	/* configure single step mode */
+	arc32_config_step(target, 1);
+
+	/* exit debug mode */
+	arc_dbg_enter_debug(target);
+
+	return ERROR_OK;
+}
+
+/* ----- Exported supporting functions ------s------------------------------- */
+
+int arc_dbg_enter_debug(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t value;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	target->state = TARGET_HALTED;
+
+	//retval = arc_jtag_read_aux_reg(&arc32->jtag_info, AUX_DEBUG_REG, &value);
+	//value |= SET_CORE_FORCE_HALT; /* set the HALT bit */
+	value = SET_CORE_FORCE_HALT; /* set the HALT bit */
+	retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG, value);
+	alive_sleep(1);
+
+#ifdef DEBUG
+	LOG_DEBUG("core stopped (halted) DEGUB-REG: 0x%08" PRIx32, value);
+	retval = arc_jtag_read_aux_reg(&arc32->jtag_info, AUX_STATUS32_REG, &value);
+	LOG_DEBUG("core STATUS32: 0x%08" PRIx32, value);
+#endif
+
+	return retval;
+}
+
+int arc_dbg_examine_debug_reason(struct target *target)
+{
+	/* Only check for reason if don't know it already. */
+	/* BTW After singlestep at this point core is not marked as halted, so
+	 * reading from memory to get current instruction won't work anyways. */
+	if (DBG_REASON_DBGRQ == target->debug_reason ||
+	    DBG_REASON_SINGLESTEP == target->debug_reason) {
+		return ERROR_OK;
+	}
+
+	int retval = ERROR_OK;
+
+	/* Ensure that DEBUG register value is in cache */
+	struct reg *debug_reg = &(target->reg_cache->reg_list[ARC_REG_DEBUG]);
+	if (!debug_reg->valid) {
+		retval = debug_reg->type->get(debug_reg);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Can not read DEBUG AUX register");
+			return retval;
+		}
+	}
+
+	/* DEBUG.BH is set if core halted due to BRK instruction. */
+	uint32_t debug_reg_value = buf_get_u32(debug_reg->value, 0, debug_reg->size);
+	if (debug_reg_value & SET_CORE_BREAKPOINT_HALT) {
+		target->debug_reason = DBG_REASON_BREAKPOINT;
+	}
+
+	return retval;
+}
+
+int arc_dbg_debug_entry(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t dpc;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	/* save current PC */
+	retval = arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_PC_REG, &dpc);
+	if (retval != ERROR_OK)
+		return retval;
+
+	arc32->jtag_info.dpc = dpc;
+
+	arc32_save_context(target);
+
+	/* We must reset internal indicators of caches states, otherwise D$/I$
+	 * will not be flushed/invalidated when required. */
+	retval = arc32_reset_caches_states(target);
+	if (ERROR_OK != retval)
+	    return retval;
+
+	retval = arc_dbg_examine_debug_reason(target);
+
+	return retval;
+}
+
+int arc_dbg_exit_debug(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t value;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	target->state = TARGET_RUNNING;
+
+	/* raise the Reset Applied bit flag */
+	retval = arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG, &value);
+	value |= SET_CORE_RESET_APPLIED; /* set the RA bit */
+	retval = arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG, value);
+
+#ifdef DEBUG
+	arc32_print_core_state(target);
+#endif
+	return retval;
+}
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_dbg_halt(struct target *target)
+{
+	int retval = ERROR_OK;
+
+	LOG_DEBUG("target->state: %s", target_state_name(target));
+
+	if (target->state == TARGET_HALTED) {
+		LOG_DEBUG("target was already halted");
+		return ERROR_OK;
+	}
+
+	if (target->state == TARGET_UNKNOWN)
+		LOG_WARNING("target was in unknown state when halt was requested");
+
+	if (target->state == TARGET_RESET) {
+		if ((jtag_get_reset_config() & RESET_SRST_PULLS_TRST) && jtag_get_srst()) {
+			LOG_ERROR("can't request a halt while in reset if nSRST pulls nTRST");
+			return ERROR_TARGET_FAILURE;
+		} else {
+			/*
+			 * we came here in a reset_halt or reset_init sequence
+			 * debug entry was already prepared in arc700_assert_reset()
+			 */
+			target->debug_reason = DBG_REASON_DBGRQ;
+
+			return ERROR_OK;
+		}
+	}
+
+	/* break (stop) processor */
+	retval = arc_dbg_enter_debug(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* update state and notify gdb*/
+	target->state = TARGET_HALTED;
+	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+
+	return retval;
+}
+
+int arc_dbg_resume(struct target *target, int current, uint32_t address,
+	int handle_breakpoints, int debug_execution)
+{
+	int retval = ERROR_OK;
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct breakpoint *breakpoint = NULL;
+	uint32_t resume_pc = 0;
+
+	LOG_DEBUG("current:%i, address:0x%08" PRIx32 ", handle_breakpoints:%i, debug_execution:%i",
+		current, address, handle_breakpoints, debug_execution);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (!debug_execution) {
+		/* (gdb) continue = execute until we hit break/watch-point */
+		LOG_DEBUG("we are in debug execution mode");
+		target_free_all_working_areas(target);
+		arc_dbg_enable_breakpoints(target);
+		arc_dbg_enable_watchpoints(target);
+	}
+
+	/* current = 1: continue on current PC, otherwise continue at <address> */
+	if (!current) {
+		buf_set_u32(arc32->core_cache->reg_list[ARC_REG_PC].value, 0, 32, address);
+		arc32->core_cache->reg_list[ARC_REG_PC].dirty = 1;
+		arc32->core_cache->reg_list[ARC_REG_PC].valid = 1;
+		LOG_DEBUG("Changing the value of current PC to 0x%08" PRIx32, address);
+	}
+
+	if (!current)
+		resume_pc = address;
+	else
+		resume_pc = buf_get_u32(arc32->core_cache->reg_list[ARC_REG_PC].value,
+			0, 32);
+
+	arc32_restore_context(target);
+
+	LOG_DEBUG("Target resumes from PC=0x%" PRIx32 ", pc.dirty=%i, pc.valid=%i",
+		resume_pc,
+		arc32->core_cache->reg_list[ARC_REG_PC].dirty,
+		arc32->core_cache->reg_list[ARC_REG_PC].valid);
+
+	/* check if GDB tells to set our PC where to continue from */
+	if ((arc32->core_cache->reg_list[ARC_REG_PC].valid == 1) &&
+		(resume_pc == buf_get_u32(arc32->core_cache->reg_list[ARC_REG_PC].value,
+			0, 32))) {
+
+		uint32_t value;
+		value = buf_get_u32(arc32->core_cache->reg_list[ARC_REG_PC].value, 0, 32);
+		LOG_DEBUG("resume Core (when start-core) with PC @:0x%08" PRIx32, value);
+		arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_PC_REG, value);
+	}
+
+	/* the front-end may request us not to handle breakpoints */
+	if (handle_breakpoints) {
+		/* Single step past breakpoint at current address */
+		breakpoint = breakpoint_find(target, resume_pc);
+		if (breakpoint) {
+			LOG_DEBUG("unset breakpoint at 0x%08" PRIx32,
+				breakpoint->address);
+			arc_dbg_unset_breakpoint(target, breakpoint);
+			arc_dbg_single_step_core(target);
+			arc_dbg_set_breakpoint(target, breakpoint);
+		}
+	}
+
+	/* enable interrupts if we are running */
+	arc32_enable_interrupts(target, !debug_execution);
+
+	/* exit debug mode */
+	arc_dbg_enter_debug(target);
+	target->debug_reason = DBG_REASON_NOTHALTED;
+
+	/* ready to get us going again */
+	arc32_start_core(target);
+
+	/* registers are now invalid */
+	register_cache_invalidate(arc32->core_cache);
+
+	if (!debug_execution) {
+		target->state = TARGET_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		LOG_DEBUG("target resumed at 0x%08" PRIx32, resume_pc);
+	} else {
+		target->state = TARGET_DEBUG_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
+		LOG_DEBUG("target debug resumed at 0x%08" PRIx32, resume_pc);
+	}
+
+	return retval;
+}
+
+int arc_dbg_step(struct target *target, int current, uint32_t address,
+	int handle_breakpoints)
+{
+	int retval = ERROR_OK;
+
+	/* get pointers to arch-specific information */
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct breakpoint *breakpoint = NULL;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	if (!current) {
+		buf_set_u32(arc32->core_cache->reg_list[ARC_REG_PC].value, 0, 32, address);
+		arc32->core_cache->reg_list[ARC_REG_PC].dirty = 1;
+		arc32->core_cache->reg_list[ARC_REG_PC].valid = 1;
+	}
+
+	LOG_DEBUG("Target steps one instruction from PC=0x%" PRIx32,
+		buf_get_u32(arc32->core_cache->reg_list[ARC_REG_PC].value, 0, 32));
+
+	/* the front-end may request us not to handle breakpoints */
+	if (handle_breakpoints) {
+		breakpoint = breakpoint_find(target,
+			buf_get_u32(arc32->core_cache->reg_list[ARC_REG_PC].value, 0, 32));
+		if (breakpoint)
+			arc_dbg_unset_breakpoint(target, breakpoint);
+	}
+
+	/* restore context */
+	arc32_restore_context(target);
+
+	target->debug_reason = DBG_REASON_SINGLESTEP;
+
+	target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+
+	/* disable interrupts while stepping */
+	arc32_enable_interrupts(target, 0);
+
+	/* exit debug mode */
+	arc_dbg_enter_debug(target);
+
+	/* do a single step */
+	arc32_config_step(target, 1);
+
+	/* make sure we done our step */
+	alive_sleep(1);
+
+	/* registers are now invalid */
+	register_cache_invalidate(arc32->core_cache);
+
+	if (breakpoint)
+		arc_dbg_set_breakpoint(target, breakpoint);
+
+	LOG_DEBUG("target stepped ");
+
+	/* target_call_event_callbacks() will send a response to GDB that
+	 * execution has stopped (packet T05). If target state is not set to
+	 * HALTED beforehand, then this creates a race condition: target state
+	 * will not be changed to HALTED until next invocation of
+	 * arc_ocd_poll(), however GDB can issue next command _before_
+	 * arc_ocd_poll() will be invoked. If GDB request requires target to be
+	 * halted this request execution will fail. Also it seems that
+	 * gdb_server cannot handle this failure properly, causing some
+	 * unexpected results instead of error message. Strangely no other
+	 * target does this except for ARM11, which sets target state to HALTED
+	 * in debug_entry. Thus either every other target is suspect to the
+	 * error, or they do something else differently, but I couldn't
+	 * understand this. */
+	target->state = TARGET_HALTED; 
+	arc_dbg_debug_entry(target);
+	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+
+	return retval;
+}
+
+/* ......................................................................... */
+
+int arc_dbg_add_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	if (target->state == TARGET_HALTED) {
+		return arc_dbg_set_breakpoint(target, breakpoint);
+
+	} else {
+		LOG_WARNING(" > core was not halted, please try again.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+}
+
+int arc_dbg_add_context_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("Context breakpoints are NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+int arc_dbg_add_hybrid_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("Hybryd breakpoints are NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+int arc_dbg_remove_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	int retval = ERROR_OK;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (breakpoint->set)
+		retval = arc_dbg_unset_breakpoint(target, breakpoint);
+
+	return retval;
+}
+
+int arc_dbg_add_watchpoint(struct target *target,
+	struct watchpoint *watchpoint)
+{
+	int retval = ERROR_OK;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = arc_dbg_set_watchpoint(target, watchpoint);
+
+	return retval;
+}
+
+int arc_dbg_remove_watchpoint(struct target *target,
+	struct watchpoint *watchpoint)
+{
+	int retval = ERROR_OK;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (watchpoint->set)
+		retval = arc_dbg_unset_watchpoint(target, watchpoint);
+
+	return retval;
+}
+int arc_dbg_add_auxreg_actionpoint(struct target *target,
+	uint32_t auxreg_addr, uint32_t transaction)
+{
+
+	if (target->state == TARGET_HALTED) {
+		struct arc32_common *arc32 = target_to_arc32(target);
+		struct arc32_comparator *comparator_list = arc32->action_point_list;
+		int ap_num = 0;
+
+		while (comparator_list[ap_num].used)
+			ap_num++;
+
+		if (ap_num >= arc32->num_action_points) {
+			LOG_ERROR("No ActionPoint free, maximim amount is %" PRIu32,
+					arc32->num_action_points);
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+
+		int retval =  arc_dbg_configure_actionpoint(target, ap_num,
+				auxreg_addr, transaction, AP_AC_AT_AUXREG_ADDR);
+
+		if (retval == ERROR_OK) {
+			comparator_list[ap_num].used = 1;
+			comparator_list[ap_num].reg_address = auxreg_addr;
+		}
+
+		return retval;
+
+	} else {
+		return ERROR_TARGET_NOT_HALTED;
+	}
+}
+
+int arc_dbg_remove_auxreg_actionpoint(struct target *target, uint32_t auxreg_addr)
+{
+	int retval = ERROR_OK;
+
+	if (target->state == TARGET_HALTED) {
+		struct arc32_common *arc32 = target_to_arc32(target);
+		struct arc32_comparator *comparator_list = arc32->action_point_list;
+		int ap_found = 0;
+		int ap_num = 0;
+
+		while ((comparator_list[ap_num].used) && (ap_num < arc32->num_action_points)) {
+			if (comparator_list[ap_num].reg_address == auxreg_addr) {
+				ap_found = 1;
+				break;
+			}
+			ap_num++;
+		}
+
+		if (ap_found) {
+			retval =  arc_dbg_configure_actionpoint(target, ap_num,
+					auxreg_addr, AP_AC_TT_DISABLE, AP_AC_AT_AUXREG_ADDR);
+
+			if (retval == ERROR_OK) {
+				comparator_list[ap_num].used = 0;
+				comparator_list[ap_num].bp_value = 0;
+			}
+		} else {
+			LOG_ERROR("Register ActionPoint not found");
+		}
+
+		return retval;
+
+	} else {
+		return ERROR_TARGET_NOT_HALTED;
+	}
+}
+
+void arc_dbg_reset_breakpoints_watchpoints(struct target *target)
+{
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct arc32_comparator *comparator_list = arc32->action_point_list;
+	struct breakpoint *next_b;
+	struct watchpoint *next_w;
+
+	while (target->breakpoints) {
+		next_b = target->breakpoints->next;
+		arc_dbg_remove_breakpoint(target, target->breakpoints);
+		free(target->breakpoints->orig_instr);
+		free(target->breakpoints);
+		target->breakpoints = next_b;
+	}
+	while (target->watchpoints) {
+		next_w = target->watchpoints->next;
+		arc_dbg_remove_watchpoint(target, target->watchpoints);
+		free(target->watchpoints);
+		target->watchpoints = next_w;
+	}
+	for (int i = 0; i < arc32->num_action_points; i++) {
+		if ((comparator_list[i].used) && (comparator_list[i].reg_address)) {
+			arc_dbg_remove_auxreg_actionpoint(target, comparator_list[i].reg_address);
+		}
+	}
+}
+
diff --git a/src/target/arc_dbg.h b/src/target/arc_dbg.h
new file mode 100644
index 0000000..b99cd57
--- /dev/null
+++ b/src/target/arc_dbg.h
@@ -0,0 +1,62 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC_DBG_H
+#define ARC_DBG_H
+
+/* ----- Supporting functions ---------------------------------------------- */
+
+int arc_dbg_enter_debug(struct target *target);
+int arc_dbg_debug_entry(struct target *target);
+int arc_dbg_exit_debug(struct target *target);
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_dbg_halt(struct target *target);
+int arc_dbg_resume(struct target *target, int current, uint32_t address,
+	int handle_breakpoints, int debug_execution);
+int arc_dbg_step(struct target *target, int current, uint32_t address,
+	int handle_breakpoints);
+
+/* ......................................................................... */
+
+int arc_dbg_add_breakpoint(struct target *target,
+	struct breakpoint *breakpoint);
+int arc_dbg_add_context_breakpoint(struct target *target,
+	struct breakpoint *breakpoint);
+int arc_dbg_add_hybrid_breakpoint(struct target *target,
+	struct breakpoint *breakpoint);
+int arc_dbg_remove_breakpoint(struct target *target,
+	struct breakpoint *breakpoint);
+
+int arc_dbg_add_watchpoint(struct target *target,
+	struct watchpoint *watchpoint);
+int arc_dbg_remove_watchpoint(struct target *target,
+	struct watchpoint *watchpoint);
+
+int arc_dbg_add_auxreg_actionpoint(struct target *target,
+	uint32_t auxreg_addr, uint32_t transaction);
+int arc_dbg_remove_auxreg_actionpoint(struct target *target,
+	uint32_t auxreg_addr);
+
+void arc_dbg_reset_breakpoints_watchpoints(struct target *target);
+
+#endif /* ARC_DBG_H */
diff --git a/src/target/arc_jtag.c b/src/target/arc_jtag.c
new file mode 100644
index 0000000..f8317f0
--- /dev/null
+++ b/src/target/arc_jtag.c
@@ -0,0 +1,600 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Mischa Jonker <mischa.jonker@synopsys.com>                            *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+
+/* ----- Supporting functions ---------------------------------------------- */
+
+typedef enum arc_jtag_reg_type {
+	ARC_JTAG_CORE_REG,
+	ARC_JTAG_AUX_REG
+} reg_type_t;
+
+/**
+ * This functions sets instruction register in TAP. TAP end state is always
+ * IRPAUSE.
+ *
+ * @param jtag_info
+ * @param new_instr	Instruction to write to instruction register.
+ */
+static void arc_jtag_write_ir(struct arc_jtag *jtag_info, uint32_t
+		new_instr)
+{
+	assert(jtag_info != NULL);
+	assert(jtag_info->tap != NULL);
+
+	struct jtag_tap *tap = jtag_info->tap;
+
+	/* Set end state */
+	jtag_info->tap_end_state = TAP_IRPAUSE;
+
+	/* Do not set instruction if it is the same as current. */
+	uint32_t current_instr = buf_get_u32(tap->cur_instr, 0, tap->ir_length);
+	if (current_instr == new_instr)
+		return;
+
+	/* Create scan field to output new instruction. */
+	struct scan_field field;
+	uint8_t instr_buffer[4];
+	field.num_bits = tap->ir_length;
+	field.in_value = NULL;
+	buf_set_u32(instr_buffer, 0, field.num_bits, new_instr);
+	field.out_value = instr_buffer;
+
+	/* From code in src/jtag/drivers/driver.c it look like that fields are
+	 * copied so it is OK that field in this function is allocated in stack and
+	 * thus this memory will be repurposed before jtag_queue_execute() will be
+	 * invoked. */
+	jtag_add_ir_scan(tap, &field, jtag_info->tap_end_state);
+}
+
+/**
+ * Set transaction in command register. This function sets instruction register
+ * and then transaction register, there is no need to invoke write_ir before
+ * invoking this function.
+ *
+ * @param jtag_info
+ * @param new_trans	Transaction to write to transaction command register.
+ * @param end_state	End state after writing.
+ */
+static void arc_jtag_set_transaction(struct arc_jtag *jtag_info,
+		arc_jtag_transaction_t new_trans, tap_state_t end_state)
+{
+	assert(jtag_info != NULL);
+	assert(jtag_info->tap != NULL);
+
+	/* No need to do anything. */
+	if (jtag_info->cur_trans == new_trans)
+		return;
+
+	/* Set instruction. We used to call write_ir at upper levels, however
+	 * write_ir-write_transaction were constantly in pair, so to avoid code
+	 * duplication this function does it self. For this reasons it is "set"
+	 * instead of "write". */
+	arc_jtag_write_ir(jtag_info, ARC_TRANSACTION_CMD_REG);
+
+	jtag_info->tap_end_state = end_state;
+
+	const int num_bits[1] = { ARC_TRANSACTION_CMD_REG_LENGTH };
+	const uint32_t values[1] = { new_trans };
+	jtag_add_dr_out(jtag_info->tap, 1, num_bits, values, end_state);
+	jtag_info->cur_trans = new_trans;
+}
+
+/**
+ * Read 4-byte word from data register.
+ *
+ * Unlike arc_jtag_write_data, this function returns byte-buffer, caller must
+ * convert this data to required format himself. This is done, because it is
+ * impossible to convert data before jtag_queue_execute() is invoked, so it
+ * cannot be done inside this function, so it has to operate with
+ * byte-buffers. Write function on the other hand can "write-and-forget", data
+ * is converted to byte-buffer before jtag_queue_execute().
+ *
+ * @param jtag_info
+ * @param data		Array of bytes to read into.
+ * @param end_state	End state after reading.
+ */
+static void arc_jtag_read_dr(struct arc_jtag *jtag_info, uint8_t *data,
+		tap_state_t end_state)
+{
+	assert(jtag_info != NULL);
+	assert(jtag_info->tap != NULL);
+
+	jtag_info->tap_end_state = end_state;
+	struct scan_field field;
+	field.num_bits = 32;
+	field.in_value = data;
+	field.out_value = NULL;
+	jtag_add_dr_scan(jtag_info->tap, 1, &field, jtag_info->tap_end_state);
+}
+
+/**
+ * Write 4-byte word to data register.
+ *
+ * @param jtag_info
+ * @param data		4-byte word to write into data register.
+ * @param end_state	End state after writing.
+ */
+static void arc_jtag_write_dr(struct arc_jtag *jtag_info, uint32_t data,
+		tap_state_t end_state)
+{
+	assert(jtag_info != NULL);
+	assert(jtag_info->tap != NULL);
+
+	jtag_info->tap_end_state = end_state;
+
+	const int num_bits[1] = { 32 };
+	const uint32_t values[1] = { data };
+	jtag_add_dr_out(jtag_info->tap, 1, num_bits, values, end_state);
+}
+
+/**
+ * Run us through transaction reset. This means that none of the previous
+ * settings/commands/etc. are used anymore (of no influence).
+ */
+static void arc_jtag_reset_transaction(struct arc_jtag *jtag_info)
+{
+	arc_jtag_set_transaction(jtag_info, ARC_JTAG_CMD_NOP, TAP_IDLE);
+}
+
+/**
+ * Write registers. addr is an array of addresses, and those addresses can be
+ * in any order, though it is recommended that they are in sequential order
+ * where possible, as this reduces number of JTAG commands to transfer.
+ *
+ * @param jtag_info
+ * @param type		Type of registers to write: core or aux.
+ * @param addr		Array of registers numbers.
+ * @param count		Amount of registers in arrays.
+ * @param values	Array of register values.
+ */
+static int arc_jtag_write_registers(struct arc_jtag *jtag_info, reg_type_t type,
+	uint32_t *addr, uint32_t count, const uint32_t *buffer)
+{
+	int retval = ERROR_OK;
+	unsigned int i;
+
+	/*
+	 * TODO: hacky hack, look for a proper way and logic (if there's) in setting
+	 *       DEBUG bits, here the code completely ignored the clock gating one
+	 *       and cleared it all the time... how could actionpoints have ever
+	 *       worked in real silicon?!?!?
+	 */
+	if((*addr == 0x5) && (type == ARC_JTAG_AUX_REG)) {
+		*((uint32_t*)buffer) |= 0x00100000;
+		LOG_DEBUG(" ### forcing ED bit in DEBUG aux register");
+	}
+
+	LOG_DEBUG("Writing to %s registers: addr[0]=0x%" PRIu32 ";count=%" PRIu32
+			  ";buffer[0]=0x%08" PRIx32,
+		(type == ARC_JTAG_CORE_REG ? "core" : "aux"), *addr, count, *buffer);
+
+	if (count == 0)
+		return retval;
+
+	arc_jtag_reset_transaction(jtag_info);
+
+	/* What registers are we writing to? */
+	const uint32_t transaction = (type == ARC_JTAG_CORE_REG ?
+			ARC_JTAG_WRITE_TO_CORE_REG : ARC_JTAG_WRITE_TO_AUX_REG);
+	arc_jtag_set_transaction(jtag_info, transaction, TAP_DRPAUSE);
+
+	for (i = 0; i < count; i++) {
+		/* Some of AUX registers are sequential, so we need to set address only
+		 * for the first one in sequence. */
+		if ( i == 0 || (addr[i] != addr[i-1] + 1) ) {
+			arc_jtag_write_ir(jtag_info, ARC_ADDRESS_REG);
+			arc_jtag_write_dr(jtag_info, addr[i], TAP_DRPAUSE);
+			/* No need to set ir each time, but only if current ir is
+			 * different. It is safe to put it into the if body, because this
+			 * if is always executed in first iteration. */
+			arc_jtag_write_ir(jtag_info, ARC_DATA_REG);
+		}
+		arc_jtag_write_dr(jtag_info, *(buffer + i), TAP_IDLE);
+	}
+
+	/* Cleanup. */
+	arc_jtag_reset_transaction(jtag_info);
+
+	/* Execute queue. */
+	retval = jtag_execute_queue();
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Writing to %s registers failed. Error code=%i",
+			(type == ARC_JTAG_CORE_REG ? "core" : "aux"), retval);
+		return retval;
+	}
+
+	return retval;
+}
+
+/**
+ * Read registers. addr is an array of addresses, and those addresses can be in
+ * any order, though it is recommended that they are in sequential order where
+ * possible, as this reduces number of JTAG commands to transfer.
+ *
+ * @param jtag_info
+ * @param type		Type of registers to read: core or aux.
+ * @param addr		Array of registers numbers.
+ * @param count		Amount of registers in arrays.
+ * @param values	Array of register values.
+ */
+static int arc_jtag_read_registers(struct arc_jtag *jtag_info, reg_type_t type,
+		uint32_t *addr, uint32_t count, uint32_t *buffer)
+{
+	int retval = ERROR_OK;
+	uint32_t i;
+
+	assert(jtag_info != NULL);
+	assert(jtag_info->tap != NULL);
+
+	LOG_DEBUG("Reading %s registers: addr[0]=0x%" PRIx32 ";count=%" PRIu32,
+		(type == ARC_JTAG_CORE_REG ? "core" : "aux"), *addr, count);
+
+	if (count == 0)
+		return retval;
+
+	arc_jtag_reset_transaction(jtag_info);
+
+	/* What type of registers we are reading? */
+	const uint32_t transaction = (type == ARC_JTAG_CORE_REG ?
+			ARC_JTAG_READ_FROM_CORE_REG : ARC_JTAG_READ_FROM_AUX_REG);
+	arc_jtag_set_transaction(jtag_info, transaction, TAP_DRPAUSE);
+
+	struct scan_field *fields = calloc(sizeof(struct scan_field), count);
+	uint8_t *data_buf = calloc(sizeof(uint8_t), count * 4);
+
+	for (i = 0; i < count; i++) {
+		/* Some of registers are sequential, so we need to set address only
+		 * for the first one in sequence. */
+		if (i == 0 || (addr[i] != addr[i-1] + 1)) {
+			/* Set address of register */
+			arc_jtag_write_ir(jtag_info, ARC_ADDRESS_REG);
+			arc_jtag_write_dr(jtag_info, addr[i], TAP_IDLE);  // TAP_IDLE or TAP_DRPAUSE?
+			arc_jtag_write_ir(jtag_info, ARC_DATA_REG);
+		}
+
+		arc_jtag_read_dr(jtag_info, data_buf + i * 4, TAP_IDLE);
+	}
+
+	/* Clean up */
+	arc_jtag_reset_transaction(jtag_info);
+
+	retval = jtag_execute_queue();
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Reading from %s registers failed. Error code=%i",
+			(type == ARC_JTAG_CORE_REG ? "core" : "aux"), retval);
+		return retval;
+	}
+
+	/* Convert byte-buffers to host presentation. */
+	for (i = 0; i < count; i++) {
+		buffer[i] = buf_get_u32(data_buf + 4*i, 0, 32);
+	}
+	free(data_buf);
+	free(fields);
+	LOG_DEBUG("Read from register: buf[0]=0x%" PRIx32, buffer[0]);
+
+	return retval;
+}
+
+/* ----- Exported JTAG functions ------------------------------------------- */
+
+int arc_jtag_startup(struct arc_jtag *jtag_info)
+{
+	arc_jtag_reset_transaction(jtag_info);
+	int retval = jtag_execute_queue();
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Starting JTAG failed.");
+		return retval;
+	}
+	return retval;
+}
+
+int arc_jtag_shutdown(struct arc_jtag *jtag_info)
+{
+	LOG_WARNING("arc_jtag_shutdown not implemented");
+	return ERROR_OK;
+}
+
+/** Read STATUS register. */
+int arc_jtag_status(struct arc_jtag * const jtag_info, uint32_t * const value)
+{
+	assert(jtag_info != NULL);
+	assert(jtag_info->tap != NULL);
+
+	int retval = ERROR_OK;
+	uint8_t buffer[4];
+
+	/* Fill command queue. */
+	arc_jtag_reset_transaction(jtag_info);
+	arc_jtag_write_ir(jtag_info, ARC_JTAG_STATUS_REG);
+	arc_jtag_read_dr(jtag_info, buffer, TAP_IDLE);
+	arc_jtag_reset_transaction(jtag_info);
+
+	/* Execute queue. */
+	retval = jtag_execute_queue();
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Reading STATUS register failed. Error code = %i", retval);
+		return retval;
+	}
+
+	/* Parse output. */
+	*value = buf_get_u32(buffer, 0, 32);
+
+	return retval;
+}
+
+/** Read IDCODE register. */
+int arc_jtag_idcode(struct arc_jtag * const jtag_info, uint32_t * const value)
+{
+	assert(jtag_info != NULL);
+	assert(jtag_info->tap != NULL);
+
+	LOG_DEBUG("Reading IDCODE register.");
+
+	int retval = ERROR_OK;
+	uint8_t buffer[4];
+
+	/* Fill command queue. */
+	arc_jtag_reset_transaction(jtag_info);
+	arc_jtag_write_ir(jtag_info, ARC_IDCODE_REG);
+	arc_jtag_read_dr(jtag_info, buffer, TAP_IDLE);
+	arc_jtag_reset_transaction(jtag_info);
+
+	/* Execute queue. */
+	retval = jtag_execute_queue();
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Reading IDCODE register failed. Error code = %i", retval);
+		return retval;
+	}
+
+	/* Parse output. */
+	*value = buf_get_u32(buffer, 0, 32);
+	LOG_DEBUG("IDCODE register=0x%08" PRIx32, *value);
+
+	return retval;
+}
+
+/**
+ * Write a sequence of 4-byte words into target memory.
+ *
+ * We can write only 4byte words via JTAG, so any non-word writes should be
+ * handled at higher levels by read-modify-write.
+ *
+ * This function writes directly to the memory, leaving any caches (if there
+ * are any) in inconsistent state. It is responsibility of upper level to
+ * resolve this.
+ *
+ * @param jtag_info
+ * @param addr		Address of first word to write into.
+ * @param count		Amount of word to write.
+ * @param buffer	Array to write into memory.
+ */
+int arc_jtag_write_memory(struct arc_jtag *jtag_info, uint32_t addr,
+		uint32_t count, const uint32_t* buffer)
+{
+	int retval = ERROR_OK;
+
+	assert(jtag_info != NULL);
+	assert(buffer != NULL);
+
+	LOG_DEBUG("Writing to memory: addr=0x%08" PRIx32 ";count=%" PRIu32 ";buffer[0]=0x%08" PRIx32,
+		addr, count, *buffer);
+
+	/* No need to waste time on useless operations. */
+	if (count == 0)
+		return retval;
+
+	/* We do not know where we come from. */
+	arc_jtag_reset_transaction(jtag_info);
+
+	/* We want to write to memory. */
+	arc_jtag_set_transaction(jtag_info, ARC_JTAG_WRITE_TO_MEMORY, TAP_DRPAUSE);
+
+	/* Set target memory address of the first word. */
+	arc_jtag_write_ir(jtag_info, ARC_ADDRESS_REG);
+	arc_jtag_write_dr(jtag_info, addr, TAP_DRPAUSE);
+
+	/* Start sending words. Address is auto-incremented on 4bytes by HW. */
+	arc_jtag_write_ir(jtag_info, ARC_DATA_REG);
+	uint32_t i;
+	for (i = 0; i < count; i++) {
+		arc_jtag_write_dr(jtag_info, *(buffer + i), TAP_IDLE);
+	}
+
+	/* Cleanup. */
+	arc_jtag_reset_transaction(jtag_info);
+
+	/* Run queue. */
+	retval = jtag_execute_queue();
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Writing to memory failed. Error code = %i", retval);
+		return retval;
+	}
+
+	return retval;
+}
+
+/**
+ * Read a sequence of 4-byte words from target memory.
+ *
+ * We can read only 4byte words via JTAG.
+ *
+ * This function read directly from the memory, so it can read invalid data if
+ * data cache hasn't been flushed before hand. It is responsibility of upper
+ * level to resolve this.
+ *
+ * @param jtag_info
+ * @param addr		Address of first word to read from.
+ * @param count		Amount of words to read.
+ * @param buffer	Array of words to read into.
+ */
+int arc_jtag_read_memory(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t count, uint32_t *buffer )
+{
+	int retval = ERROR_OK;
+
+	assert(jtag_info != NULL);
+	assert(jtag_info->tap != NULL);
+
+	LOG_DEBUG("Reading memory: addr=0x%" PRIx32 ";count=%" PRIu32, addr, count);
+
+	if (count == 0)
+		return retval;
+
+	arc_jtag_reset_transaction(jtag_info);
+
+	/* We are reading from memory. */
+	arc_jtag_set_transaction(jtag_info, ARC_JTAG_READ_FROM_MEMORY, TAP_DRPAUSE);
+
+	/* Set address of the first word */
+	arc_jtag_write_ir(jtag_info, ARC_ADDRESS_REG);
+	arc_jtag_write_dr(jtag_info, addr, TAP_IDLE);
+
+	/* Read data */
+	arc_jtag_write_ir(jtag_info, ARC_DATA_REG);
+	uint8_t *data_buf = calloc(sizeof(uint8_t), count * 4);
+	uint32_t i;
+	for (i = 0; i < count; i++) {
+		arc_jtag_read_dr(jtag_info, data_buf + i * 4, TAP_IDLE);
+	}
+
+	/* Clean up */
+	arc_jtag_reset_transaction(jtag_info);
+
+	retval = jtag_execute_queue();
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Reading from memory failed. Error code=%i", retval);
+		return retval;
+	}
+
+	/* Convert byte-buffers to host presentation. */
+	for (i = 0; i < count; i++) {
+		buffer[i] = buf_get_u32(data_buf + 4*i, 0, 32);
+	}
+
+	free(data_buf);
+
+	return retval;
+}
+
+/** Wrapper function to ease writing of one core register. */
+int arc_jtag_write_core_reg_one(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t value)
+{
+	return arc_jtag_write_core_reg(jtag_info, &addr, 1, &value);
+}
+
+/**
+ * Write core registers. addr is an array of addresses, and those addresses can
+ * be in any order, though it is recommended that they are in sequential order
+ * where possible, as this reduces number of JTAG commands to transfer.
+ *
+ * @param jtag_info
+ * @param addr		Array of registers numbers.
+ * @param count		Amount of registers in arrays.
+ * @param values	Array of register values.
+ */
+int arc_jtag_write_core_reg(struct arc_jtag *jtag_info, uint32_t* addr,
+	uint32_t count, const uint32_t* buffer)
+{
+	return arc_jtag_write_registers(jtag_info, ARC_JTAG_CORE_REG, addr, count,
+			buffer);
+}
+
+/** Wrapper function to ease reading of one core register. */
+int arc_jtag_read_core_reg_one(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t *value)
+{
+	return arc_jtag_read_core_reg(jtag_info, &addr, 1, value);
+}
+
+/**
+ * Read core registers. addr is an array of addresses, and those addresses can
+ * be in any order, though it is recommended that they are in sequential order
+ * where possible, as this reduces number of JTAG commands to transfer.
+ *
+ * @param jtag_info
+ * @param addr		Array of core register numbers.
+ * @param count		Amount of registers in arrays.
+ * @param values	Array of register values.
+ */
+int arc_jtag_read_core_reg(struct arc_jtag *jtag_info, uint32_t *addr,
+	uint32_t count, uint32_t* buffer)
+{
+	return arc_jtag_read_registers(jtag_info, ARC_JTAG_CORE_REG, addr, count,
+			buffer);
+}
+
+/** Wrapper function to ease writing of one AUX register. */
+int arc_jtag_write_aux_reg_one(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t value)
+{
+	return arc_jtag_write_aux_reg(jtag_info, &addr, 1, &value);
+}
+
+/**
+ * Write AUX registers. addr is an array of addresses, and those addresses can
+ * be in any order, though it is recommended that they are in sequential order
+ * where possible, as this reduces number of JTAG commands to transfer.
+ *
+ * @param jtag_info
+ * @param addr		Array of registers numbers.
+ * @param count		Amount of registers in arrays.
+ * @param values	Array of register values.
+ */
+int arc_jtag_write_aux_reg(struct arc_jtag *jtag_info, uint32_t* addr,
+	uint32_t count, const uint32_t* buffer)
+{
+	return arc_jtag_write_registers(jtag_info, ARC_JTAG_AUX_REG, addr, count,
+			buffer);
+}
+
+/** Wrapper function to ease reading of one AUX register. */
+int arc_jtag_read_aux_reg_one(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t *value)
+{
+	return arc_jtag_read_aux_reg(jtag_info, &addr, 1, value);
+}
+
+/**
+ * Read AUX registers. addr is an array of addresses, and those addresses can
+ * be in any order, though it is recommended that they are in sequential order
+ * where possible, as this reduces number of JTAG commands to transfer.
+ *
+ * @param jtag_info
+ * @param addr		Array of AUX register numbers.
+ * @param count		Amount of registers in arrays.
+ * @param values	Array of register values.
+ */
+int arc_jtag_read_aux_reg(struct arc_jtag *jtag_info, uint32_t *addr,
+	uint32_t count, uint32_t* buffer)
+{
+	return arc_jtag_read_registers(jtag_info, ARC_JTAG_AUX_REG, addr, count,
+			buffer);
+}
+
diff --git a/src/target/arc_jtag.h b/src/target/arc_jtag.h
new file mode 100644
index 0000000..b131315
--- /dev/null
+++ b/src/target/arc_jtag.h
@@ -0,0 +1,107 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC_JTAG_H
+#define ARC_JTAG_H
+
+/* JTAG TAP instructions = IEEE 1149.1 */
+#define ARC_TAP_INST_IDCODE	0x01
+
+/* JTAG core registers plus bit fields within registers */
+#define ARC_INSTRUCTION_REG 		0x0 /* Instruction register */
+
+#define ARC_JTAG_STATUS_REG 		0x8 /* Jtag cmd transaction status */
+#define ARC_JTAG_STAT_ST			0b000001
+#define ARC_JTAG_STAT_FL			0b000010
+#define ARC_JTAG_STAT_RD			0b000100
+#define ARC_JTAG_STAT_NIU			0b001000 /* Not in use */
+#define ARC_JTAG_STAT_RU			0b010000
+#define ARC_JTAG_STAT_RA			0b100000
+
+#define ARC_TRANSACTION_CMD_REG 	0x9 /* Command to perform */
+#define ARC_TRANSACTION_CMD_REG_LENGTH 4
+typedef enum arc_jtag_transaction {
+	ARC_JTAG_WRITE_TO_MEMORY = 0x0,
+	ARC_JTAG_WRITE_TO_CORE_REG = 0x1,
+	ARC_JTAG_WRITE_TO_AUX_REG = 0x2,
+	ARC_JTAG_CMD_NOP = 0x3,
+	ARC_JTAG_READ_FROM_MEMORY = 0x4,
+	ARC_JTAG_READ_FROM_CORE_REG = 0x5,
+	ARC_JTAG_READ_FROM_AUX_REG = 0x6,
+} arc_jtag_transaction_t;
+
+#define ARC_ADDRESS_REG				0xA /* SoC address to access */
+
+#define ARC_DATA_REG				0xB /* Data read/written from SoC */
+
+#define ARC_IDCODE_REG				0xC /* ARC core type information */
+#define ARC_CORE_TYPE				(111111 << 12)
+#define ARC_NUMBER_CORE				(1111111111 << 18)
+#define ARC_JTAG_VERSION			(1111 << 28)
+
+#define ARC_BYPASS_REG				0xF /* TDI to TDO */
+
+struct arc_jtag {
+	struct jtag_tap *tap;
+	uint32_t tap_end_state;
+	uint32_t intest_instr;
+	uint32_t cur_trans;
+
+	uint32_t scann_size;
+	uint32_t scann_instr;
+	uint32_t cur_scan_chain;
+
+	uint32_t dpc; /* Debug PC value */
+
+	int fast_access_save;
+};
+
+/* ----- Exported JTAG functions ------------------------------------------- */
+
+int arc_jtag_startup(struct arc_jtag *jtag_info);
+int arc_jtag_shutdown(struct arc_jtag *jtag_info);
+int arc_jtag_status(struct arc_jtag *const jtag_info, uint32_t *const value);
+int arc_jtag_idcode(struct arc_jtag *const jtag_info, uint32_t *const value);
+
+int arc_jtag_write_memory(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t count, const uint32_t *buffer);
+int arc_jtag_read_memory(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t count, uint32_t *buffer);
+
+int arc_jtag_write_core_reg(struct arc_jtag *jtag_info, uint32_t *addr,
+	uint32_t count, const uint32_t *buffer);
+int arc_jtag_read_core_reg(struct arc_jtag *jtag_info, uint32_t *addr,
+	uint32_t count, uint32_t *buffer);
+int arc_jtag_write_core_reg_one(struct arc_jtag *jtag_info, uint32_t addr,
+	const uint32_t buffer);
+int arc_jtag_read_core_reg_one(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t *buffer);
+
+int arc_jtag_write_aux_reg(struct arc_jtag *jtag_info, uint32_t *addr,
+	uint32_t count, const uint32_t* buffer);
+int arc_jtag_write_aux_reg_one(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t value);
+int arc_jtag_read_aux_reg(struct arc_jtag *jtag_info, uint32_t *addr,
+	uint32_t count, uint32_t *buffer);
+int arc_jtag_read_aux_reg_one(struct arc_jtag *jtag_info, uint32_t addr,
+	uint32_t *value);
+
+#endif /* ARC_JTAG_H */
diff --git a/src/target/arc_mem.c b/src/target/arc_mem.c
new file mode 100644
index 0000000..b088dee
--- /dev/null
+++ b/src/target/arc_mem.c
@@ -0,0 +1,417 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Mischa Jonker <mischa.jonker@synopsys.com>                            *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+
+/* ----- Supporting functions ---------------------------------------------- */
+
+static int arc_mem_read_block(struct target *target, uint32_t addr,
+	int size, int count, void *buf)
+{
+	struct arc32_common *arc32 = target_to_arc32(target);
+	int retval = ERROR_OK;
+
+	LOG_DEBUG("Read memory: addr=0x%" PRIx32 ", size=%i, count=%i",
+			addr, size, count);
+	assert(!(addr & 3));
+	assert(size == 4);
+
+	/* Always call D$ flush, it will decide whether to perform actual
+	 * flush. */
+	retval = arc32_dcache_flush(target);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = arc_jtag_read_memory(&arc32->jtag_info, addr, count, buf);
+
+	return retval;
+}
+
+/* Write word at word-aligned address */
+static int arc_mem_write_block32(struct target *target, uint32_t addr, int count,
+	void *buf)
+{
+	struct arc32_common *arc32 = target_to_arc32(target);
+	int retval = ERROR_OK;
+
+	/* Check arguments */
+	if (addr & 0x3u)
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	/* No need to flush cache, because we don't read values from memory. */
+	retval = arc_jtag_write_memory( &arc32->jtag_info, addr, count, (uint32_t *)buf);
+	if (ERROR_OK != retval)
+		return retval;
+
+	/* Invalidate caches. */
+	retval = arc32_cache_invalidate(target);
+
+	return retval;
+}
+
+/* Write half-word at half-word-aligned address */
+static int arc_mem_write_block16(struct target *target, uint32_t addr, int count,
+	void *buf)
+{
+	struct arc32_common *arc32 = target_to_arc32(target);
+	int retval = ERROR_OK;
+	int i;
+
+	LOG_DEBUG("Write memory (16bit): addr=0x%" PRIx32 ", count=%i", addr, count);
+
+	/* Check arguments */
+	if (addr & 1u)
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	/* We will read data from memory, so we need to flush D$. */
+	retval = arc32_dcache_flush(target);
+	if (ERROR_OK != retval)
+		return retval;
+
+	uint32_t buffer_he;
+	uint8_t buffer_te[sizeof(uint32_t)];
+	uint8_t halfword_te[sizeof(uint16_t)];
+	/* non-word writes are less common, than 4-byte writes, so I suppose we can
+	 * allowe ourselves to write this in a cycle, instead of calling arc_jtag
+	 * with count > 1. */
+	for(i = 0; i < count; i++) {
+		/* We can read only word at word-aligned address. Also *jtag_read_memory
+		 * functions return data in host endianness, so host endianness !=
+		 * target endianness we have to convert data back to target endianness,
+		 * or bytes will be at the wrong places.So:
+		 *   1) read word
+		 *   2) convert to target endianness
+		 *   3) make changes
+		 *   4) convert back to host endianness
+		 *   5) write word back to target.
+		 */
+		retval = arc_jtag_read_memory(&arc32->jtag_info,
+				(addr + i * sizeof(uint16_t)) & ~3u, 1, &buffer_he);
+		target_buffer_set_u32(target, buffer_te, buffer_he);
+		/* buf is in host endianness, convert to target */
+		target_buffer_set_u16(target, halfword_te, ((uint16_t *)buf)[i]);
+		memcpy(buffer_te  + ((addr + i * sizeof(uint16_t)) & 3u),
+                        halfword_te, sizeof(uint16_t));
+		buffer_he = target_buffer_get_u32(target, buffer_te);
+		retval = arc_jtag_write_memory(&arc32->jtag_info,
+                        (addr + i * sizeof(uint16_t)) & ~3u, 1, &buffer_he);
+
+		if (ERROR_OK != retval)
+			return retval;
+	}
+
+	/* Invalidate caches. */
+	retval = arc32_cache_invalidate(target);
+
+	return retval;
+}
+
+/* Write byte at address */
+static int arc_mem_write_block8(struct target *target, uint32_t addr, int count,
+	void *buf)
+{
+	struct arc32_common *arc32 = target_to_arc32(target);
+	int retval = ERROR_OK;
+	int i;
+
+	/* We will read data from memory, so we need to flush D$. */
+	retval = arc32_dcache_flush(target);
+	if (ERROR_OK != retval)
+		return retval;
+
+	uint32_t buffer_he;
+	uint8_t buffer_te[sizeof(uint32_t)];
+	/* non-word writes are less common, than 4-byte writes, so I suppose we can
+	 * allowe ourselves to write this in a cycle, instead of calling arc_jtag
+	 * with count > 1. */
+	for(i = 0; i < count; i++) {
+		/* See comment in arc_mem_write_block16 for details. Since it is a byte
+		 * there is not need to convert write buffer to target endianness, but
+		 * we still have to convert read buffer. */
+		retval = arc_jtag_read_memory(&arc32->jtag_info, (addr + i) & ~3, 1, &buffer_he);
+		target_buffer_set_u32(target, buffer_te, buffer_he);
+		memcpy(buffer_te  + ((addr + i) & 3), (uint8_t*)buf + i, 1);
+		buffer_he = target_buffer_get_u32(target, buffer_te);
+		retval = arc_jtag_write_memory(&arc32->jtag_info, (addr + i) & ~3, 1, &buffer_he);
+
+		if (ERROR_OK != retval)
+			return retval;
+	}
+
+	/* Invalidate caches. */
+	retval = arc32_cache_invalidate(target);
+
+	return retval;
+}
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_mem_read(struct target *target, uint32_t address, uint32_t size,
+	uint32_t count, uint8_t *buffer)
+{
+	int retval = ERROR_OK;
+
+	LOG_DEBUG("Read memory: addr=0x%" PRIx32 ", size=%i, count=%i",
+			address, size, count);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Sanitize arguments */
+	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
+	    return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	void *tunnel_he;
+	uint8_t *tunnel_te;
+	uint32_t words_to_read, bytes_to_read;
+
+	/* TODO: I think this function might be made much more clear if it
+	 * would be splitted onto three based on size (4/2/1). That would
+	 * duplicate some logic, but it would be much easier to understand it,
+	 * those bit operations are just asking for a trouble. And they emulate
+	 * size-specific logic, that is smart, but dangerous.  */
+	/* Reads are word-aligned, so padding might be required if count > 1.
+	 * NB: +3 is a padding for the last word (in case it's not aligned;
+	 * addr&3 is a padding for the first word (since address can be
+	 * unaligned as well).  */
+	bytes_to_read = (count * size + 3 + (address & 3u)) & ~3u;
+	words_to_read = bytes_to_read >> 2;
+	tunnel_he = malloc(bytes_to_read);
+	tunnel_te = malloc(bytes_to_read);
+	if (!tunnel_he || !tunnel_te) {
+		LOG_ERROR("Out of memory");
+		return ERROR_FAIL;
+	}
+
+	/* We can read only word-aligned words. */
+	retval = arc_mem_read_block(target, address & ~3u, sizeof(uint32_t),
+		words_to_read, tunnel_he);
+
+	/* arc32_..._read_mem with size 4/2 returns uint32_t/uint16_t in host */
+	/* endianness, but byte array should represent target endianness      */
+
+	if (ERROR_OK == retval) {
+		switch (size) {
+		case 4:
+			target_buffer_set_u32_array(target, buffer, count,
+				tunnel_he);
+			break;
+		case 2:
+			target_buffer_set_u32_array(target, tunnel_te,
+				words_to_read, tunnel_he);
+			/* Will that work properly with count > 1 and big endian? */
+			memcpy(buffer, tunnel_te + (address & 3u),
+				count * sizeof(uint16_t));
+			break;
+		case 1:
+			target_buffer_set_u32_array(target, tunnel_te,
+				words_to_read, tunnel_he);
+			/* Will that work properly with count > 1 and big endian? */
+			memcpy(buffer, tunnel_te + (address & 3u), count);
+			break;
+		}
+	}
+
+	free(tunnel_he);
+	free(tunnel_te);
+
+	return retval;
+}
+
+int arc_mem_write(struct target *target, uint32_t address, uint32_t size,
+	uint32_t count, const uint8_t *buffer)
+{
+	int retval = ERROR_OK;
+
+	LOG_DEBUG("address: 0x%08" PRIx32 ", size: %" PRIu32 ", count: %" PRIu32,
+		address, size, count);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* sanitize arguments */
+
+	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	/* correct endianess if we have word or hword access */
+	void *tunnel = NULL;
+
+	if (size > 1) {
+		/*
+		 * arc32_..._write_mem with size 4/2 requires uint32_t/uint16_t
+		 * in host endianness, but byte array represents target endianness.
+		 */
+		tunnel = malloc(count * size * sizeof(uint8_t));
+		if (tunnel == NULL) {
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
+
+		switch (size) {
+		case 4:
+			target_buffer_get_u32_array(target, buffer, count,
+				(uint32_t *)tunnel);
+			break;
+		case 2:
+			target_buffer_get_u16_array(target, buffer, count,
+				(uint16_t *)tunnel);
+			break;
+		}
+		buffer = tunnel;
+	}
+
+	if (size == 4) {
+		retval = arc_mem_write_block32(target, address, count, (void *)buffer);
+	} else if (size == 2) {
+		/* We convert buffer from host endianness to target. But then in
+		 * write_block16, we do the reverse. Is there a way to avoid this without
+		 * breaking other cases? */
+		retval = arc_mem_write_block16(target, address, count, (void *)buffer);
+	} else {
+		retval = arc_mem_write_block8(target, address, count, (void *)buffer);
+	}
+
+	if (tunnel != NULL)
+		free(tunnel);
+
+	return retval;
+}
+
+int arc_mem_checksum(struct target *target, uint32_t address, uint32_t count,
+	uint32_t *checksum)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("arc_mem_checksum NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+int arc_mem_blank_check(struct target *target, uint32_t address,
+	uint32_t count, uint32_t *blank)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("arc_mem_blank_check NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+/* ......................................................................... */
+
+int arc_mem_run_algorithm(struct target *target,
+	int num_mem_params, struct mem_param *mem_params,
+	int num_reg_params, struct reg_param *reg_params,
+	uint32_t entry_point, uint32_t exit_point,
+	int timeout_ms, void *arch_info)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("arc_mem_run_algorithm NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+int arc_mem_start_algorithm(struct target *target,
+	int num_mem_params, struct mem_param *mem_params,
+	int num_reg_params, struct reg_param *reg_params,
+	uint32_t entry_point, uint32_t exit_point,
+	void *arch_info)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("arc_mem_start_algorithm NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+int arc_mem_wait_algorithm(struct target *target,
+	int num_mem_params, struct mem_param *mem_params,
+	int num_reg_params, struct reg_param *reg_params,
+	uint32_t exit_point, int timeout_ms,
+	void *arch_info)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("arc_mem_wait_algorithm NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+/* ......................................................................... */
+
+int arc_mem_virt2phys(struct target *target, uint32_t address,
+	uint32_t *physical)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("arc_mem_virt2phys NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+int arc_mem_read_phys_memory(struct target *target, uint32_t phys_address,
+	uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("arc_mem_read_phys_memory NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+int arc_mem_write_phys_memory(struct target *target, uint32_t phys_address,
+	uint32_t size, uint32_t count, const uint8_t *buffer)
+{
+	int retval = ERROR_OK;
+
+	LOG_ERROR("arc_mem_write_phys_memory NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
+
+int arc_mem_mmu(struct target *target, int *enabled)
+{
+	int retval = ERROR_OK;
+
+	/* (gdb) load command runs through here */
+
+	LOG_DEBUG("arc_mem_mmu NOT SUPPORTED IN THIS RELEASE.");
+	LOG_DEBUG("    arc_mem_mmu() = entry point for performance upgrade");
+
+	return retval;
+}
diff --git a/src/target/arc_mem.h b/src/target/arc_mem.h
new file mode 100644
index 0000000..799592e
--- /dev/null
+++ b/src/target/arc_mem.h
@@ -0,0 +1,72 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC_MEM_H
+#define ARC_MEM_H
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_mem_read(struct target *target, uint32_t address, uint32_t size,
+	uint32_t count, uint8_t *buffer);
+int arc_mem_write(struct target *target, uint32_t address, uint32_t size,
+	uint32_t count, const uint8_t *buffer);
+
+int arc_mem_bulk_write(struct target *target, uint32_t address, uint32_t count,
+	const uint8_t *buffer);
+
+int arc_mem_checksum(struct target *target, uint32_t address, uint32_t count,
+	uint32_t *checksum);
+int arc_mem_blank_check(struct target *target, uint32_t address,
+	uint32_t count, uint32_t *blank);
+
+/* ......................................................................... */
+
+int arc_mem_run_algorithm(struct target *target,
+	int num_mem_params, struct mem_param *mem_params,
+	int num_reg_params, struct reg_param *reg_params,
+	uint32_t entry_point, uint32_t exit_point,
+	int timeout_ms, void *arch_info);
+
+int arc_mem_start_algorithm(struct target *target,
+	int num_mem_params, struct mem_param *mem_params,
+	int num_reg_params, struct reg_param *reg_params,
+	uint32_t entry_point, uint32_t exit_point,
+	void *arch_info);
+
+int arc_mem_wait_algorithm(struct target *target,
+	int num_mem_params, struct mem_param *mem_params,
+	int num_reg_params, struct reg_param *reg_params,
+	uint32_t exit_point, int timeout_ms,
+	void *arch_info);
+
+/* ......................................................................... */
+
+int arc_mem_virt2phys(struct target *target, uint32_t address,
+	uint32_t *physical);
+
+int arc_mem_read_phys_memory(struct target *target, uint32_t phys_address,
+	uint32_t size, uint32_t count, uint8_t *buffer);
+int arc_mem_write_phys_memory(struct target *target, uint32_t phys_address,
+	uint32_t size, uint32_t count, const uint8_t *buffer);
+
+int arc_mem_mmu(struct target *target, int *enabled);
+
+#endif /* ARC_MEM_H */
diff --git a/src/target/arc_mntr.c b/src/target/arc_mntr.c
new file mode 100644
index 0000000..4955515
--- /dev/null
+++ b/src/target/arc_mntr.c
@@ -0,0 +1,509 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Mischa Jonker <mischa.jonker@synopsys.com>                            *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+
+/* --------------------------------------------------------------------------
+ *
+ *   ARC targets expose command interface.
+ *   It can be accessed via GDB through the (gdb) monitor command.
+ *
+ * ------------------------------------------------------------------------- */
+
+COMMAND_HANDLER(handle_set_pc_command)
+{
+	int retval = ERROR_OK;
+	uint32_t value;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	struct target_list *head;
+	head = target->head;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "NOTE: target must be HALTED for \"%s\" command",
+			CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if (head == (struct target_list *)NULL) {
+
+		if (CMD_ARGC >= 1) {
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], value);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%08" PRIx32, CMD_ARGC, value);
+			arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_PC_REG, value);
+			LOG_INFO("Core PC @: 0x%08" PRIx32, value);
+		} else
+			LOG_ERROR(" > missing address to set.");
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_set_core_into_halted_command)
+{
+	int retval = ERROR_OK;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	struct target_list *head;
+	head = target->head;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "NOTE: target must be HALTED for \"%s\" command",
+			CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if (head == (struct target_list *)NULL) {
+		uint32_t value;
+		arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG, &value);
+		value |= SET_CORE_FORCE_HALT; /* set the HALT bit */
+		arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG, value);
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_read_core_reg_command)
+{
+	int retval = ERROR_OK;
+	uint32_t reg_nbr, value;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	struct target_list *head;
+	head = target->head;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "NOTE: target must be HALTED for \"%s\" command",
+			CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if (head == (struct target_list *)NULL) {
+
+		if (CMD_ARGC >= 1) {
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], reg_nbr);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%" PRIx32, CMD_ARGC, reg_nbr);
+			arc_jtag_read_core_reg_one(&arc32->jtag_info, reg_nbr, &value);
+			LOG_INFO("Core reg: 0x%" PRIx32 " contains: 0x%08" PRIx32, reg_nbr, value);
+		} else
+			LOG_ERROR(" > missing reg nbr to read.");
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_write_core_reg_command)
+{
+	int retval = ERROR_OK;
+	uint32_t reg_nbr, value;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	struct target_list *head;
+	head = target->head;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "NOTE: target must be HALTED for \"%s\" command",
+			CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if (head == (struct target_list *)NULL) {
+
+		if (CMD_ARGC >= 2) {
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], reg_nbr);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%" PRIx32, CMD_ARGC, reg_nbr);
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%08" PRIx32, CMD_ARGC, value);
+			arc_jtag_write_core_reg_one(&arc32->jtag_info, reg_nbr, value);
+			LOG_DEBUG("Core reg: 0x%" PRIx32 " contains: 0x%08" PRIx32, reg_nbr, value);
+		} else
+			LOG_ERROR(" > missing reg nbr or value to write.");
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_read_aux_reg_command)
+{
+	int retval = ERROR_OK;
+	uint32_t reg_nbr, value;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	struct target_list *head;
+	head = target->head;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "NOTE: target must be HALTED for \"%s\" command",
+			CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if (head == (struct target_list *)NULL) {
+
+		if (CMD_ARGC >= 1) {
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], reg_nbr);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%" PRIx32, CMD_ARGC, reg_nbr);
+			arc_jtag_read_aux_reg_one(&arc32->jtag_info, reg_nbr, &value);
+			LOG_ERROR("AUX reg: 0x%" PRIx32 " contains: 0x%08" PRIx32, reg_nbr, value);
+		} else
+			LOG_ERROR(" > missing reg nbr to read.");
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_write_aux_reg_command)
+{
+	int retval = ERROR_OK;
+	uint32_t reg_nbr, value;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	struct target_list *head;
+	head = target->head;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "NOTE: target must be HALTED for \"%s\" command",
+			CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if (head == (struct target_list *)NULL) {
+
+		if (CMD_ARGC >= 2) {
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], reg_nbr);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%" PRIx32, CMD_ARGC, reg_nbr);
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%08" PRIx32, CMD_ARGC, value);
+			arc_jtag_write_aux_reg_one(&arc32->jtag_info, reg_nbr, value);
+			LOG_DEBUG("AUX reg: 0x%x contains: 0x%x", reg_nbr, value);
+		} else
+			LOG_ERROR(" > missing reg nbr or value to write.");
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_read_mem_word_command)
+{
+	int retval = ERROR_OK;
+	uint32_t mem_addr, value;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	struct target_list *head;
+	head = target->head;
+
+	if (head == (struct target_list *)NULL) {
+
+		if (CMD_ARGC >= 1) {
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], mem_addr);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%08" PRIx32, CMD_ARGC, mem_addr);
+			arc_jtag_read_memory(&arc32->jtag_info, mem_addr, 1, &value);
+			LOG_ERROR("mem addr: 0x%08" PRIx32 " contains: 0x%08" PRIx32, mem_addr, value);
+		} else
+			LOG_ERROR(" > missing memory address to read.");
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_write_mem_word_command)
+{
+	int retval = ERROR_OK;
+	uint32_t mem_addr, value;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	struct target_list *head;
+	head = target->head;
+
+	if (head == (struct target_list *)NULL) {
+
+		if (CMD_ARGC >= 2) {
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], mem_addr);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%08" PRIx32, CMD_ARGC, mem_addr);
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
+			LOG_DEBUG("CMD_ARGC:%u  CMD_ARGV: 0x%08" PRIx32, CMD_ARGC, value);
+			arc_jtag_write_memory(&arc32->jtag_info, mem_addr, 1, &value);
+			LOG_DEBUG("mem addr: 0x%08" PRIx32 " contains: 0x%08" PRIx32, mem_addr, value);
+		} else
+			LOG_ERROR(" > missing memory address or value to write.");
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_print_core_status_command)
+{
+	int retval = ERROR_OK;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	struct target_list *head;
+	head = target->head;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "NOTE: target must be HALTED for \"%s\" command",
+			CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if (head == (struct target_list *)NULL) {
+		uint32_t value;
+		arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG, &value);
+		LOG_INFO(" AUX REG    [DEBUG]: 0x%08" PRIx32, value);
+		arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_STATUS32_REG, &value);
+		LOG_INFO("         [STATUS32]: 0x%08" PRIx32, value);
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(arc_handle_has_dcache)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+	return CALL_COMMAND_HANDLER(handle_command_parse_bool,
+		&arc32->has_dcache, "target has data-cache");
+}
+
+COMMAND_HANDLER(arc_handle_gdb_compatibility_mode)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arc32_common *arc32 = target_to_arc32(target);
+	return CALL_COMMAND_HANDLER(handle_command_parse_bool,
+		&arc32->gdb_compatibility_mode, "GDB compatibility mode");
+}
+COMMAND_HANDLER(set_action_point_auxreg_addr)
+{
+	int retval = ERROR_OK;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct target_list *head;
+	head = target->head;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "NOTE: target must be HALTED for \"%s\" command",
+			CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if (head == (struct target_list *)NULL) {
+		if (CMD_ARGC == 2) {
+			uint32_t auxreg_addr = 0;
+			uint32_t transaction = AP_AC_TT_DISABLE;
+
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], auxreg_addr);
+
+			switch (CMD_ARGV[1][0]) {
+				case 'r':
+					transaction = AP_AC_TT_READ;
+					break;
+				case 'w':
+					transaction = AP_AC_TT_WRITE;
+					break;
+				case 'a':
+					transaction = AP_AC_TT_READWRITE;
+					break;
+				default:
+					LOG_ERROR("invalid watchpoint mode ('%c')", CMD_ARGV[2][0]);
+					return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+
+			return arc_dbg_add_auxreg_actionpoint(target, auxreg_addr, transaction);
+
+		} else {
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+COMMAND_HANDLER(remove_action_point_auxreg_addr)
+{
+	int retval = ERROR_OK;
+
+	struct target *target = get_current_target(CMD_CTX);
+	struct target_list *head;
+	head = target->head;
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "NOTE: target must be HALTED for \"%s\" command",
+			CMD_NAME);
+		return ERROR_OK;
+	}
+
+	if (head == (struct target_list *)NULL) {
+		if (CMD_ARGC == 1) {
+			uint32_t auxreg_addr = 0;
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], auxreg_addr);
+
+			return arc_dbg_remove_auxreg_actionpoint(target, auxreg_addr);
+
+		} else {
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+	} else
+		LOG_ERROR(" > head list is not NULL !");
+
+	return retval;
+}
+
+/* ----- Exported target commands ------------------------------------------ */
+
+static const struct command_registration arc_core_command_handlers[] = {
+	{
+		.name = "set-pc",
+		.handler = handle_set_pc_command,
+		.mode = COMMAND_EXEC,
+		.usage = "has one argument: <value>",
+		.help = "modify the ARC core program counter (PC) register",
+	},
+	{
+		.name = "set-core-into-halted",
+		.handler = handle_set_core_into_halted_command,
+		.mode = COMMAND_EXEC,
+		.usage = "has no arguments",
+		.help = "set the ARC core into HALTED state",
+	},
+	{
+		.name = "read-core-reg",
+		.handler = handle_read_core_reg_command,
+		.mode = COMMAND_EXEC,
+		.usage = "has one argument: <reg-nbr>",
+		.help = "list the content of a particular core registers",
+	},
+	{
+		.name = "write-core-reg",
+		.handler = handle_write_core_reg_command,
+		.mode = COMMAND_EXEC,
+		.usage = "has two argument: <reg-nbr> <value to write>",
+		.help = "write value to a particular core registers",
+	},
+	{
+		.name = "read-aux-reg",
+		.handler = handle_read_aux_reg_command,
+		.mode = COMMAND_EXEC,
+		.usage = "has one argument: <reg-nbr>",
+		.help = "list the content of a particular aux registers",
+	},
+	{
+		.name = "write-aux-reg",
+		.handler = handle_write_aux_reg_command,
+		.mode = COMMAND_EXEC,
+		.usage = "has two argument: <reg-nbr> <value to write>",
+		.help = "write value to a particular aux registers",
+	},
+	{
+		.name = "read-mem-word",
+		.handler = handle_read_mem_word_command,
+		.mode = COMMAND_EXEC,
+		.usage = "has one argument: <mem-addr>",
+		.help = "list the content (1 word) of a particular memory location",
+	},
+	{
+		.name = "write-mem-word",
+		.handler = handle_write_mem_word_command,
+		.mode = COMMAND_EXEC,
+		.usage = "has two argument: <mem-addr> <value to write>",
+		.help = "write value (1 word) to a particular memory location",
+	},
+	{
+		.name = "print-core-status",
+		.handler = handle_print_core_status_command,
+		.mode = COMMAND_EXEC,
+		.usage = "has no arguments",
+		.help = "list the content of core aux debug & status32 register",
+	},
+	{
+		.name = "has-dcache",
+		.handler = arc_handle_has_dcache,
+		.mode = COMMAND_ANY,
+		.usage = "True or false",
+		.help = "Does target has D$? If yes it will be flushed before memory reads.",
+	},
+	{
+		.name = "gdb-compatibility-mode",
+		.handler = arc_handle_gdb_compatibility_mode,
+		.mode = COMMAND_CONFIG,
+		.usage = "true or false",
+		.help = "GDB compatibility mode: if true OpenOCD will use register "\
+			"specification compatible with old GDB for ARC that doesn't support "\
+			"XML target descriptions.",
+	},
+	{
+		.name = "ap-auxreg-addr",
+		.handler = set_action_point_auxreg_addr,
+		.mode = COMMAND_EXEC,
+		.usage = "has two argument: <auxreg-addr> <r|w|a>",
+		.help = "sets break when aux register is accessed",
+	},
+	{
+		.name = "rap-auxreg-addr",
+		.handler = remove_action_point_auxreg_addr,
+		.mode = COMMAND_EXEC,
+		.usage = "has only one argument: <auxreg-addr>",
+		.help = "removes break when aux register is accessed",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration arc_monitor_command_handlers[] = {
+	{
+		.name = "arc",
+		.mode = COMMAND_ANY,
+		.help = "ARC monitor command group",
+		.usage = "Help info ...",
+		.chain = arc_core_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
diff --git a/src/target/arc_mntr.h b/src/target/arc_mntr.h
new file mode 100644
index 0000000..969e67d
--- /dev/null
+++ b/src/target/arc_mntr.h
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC_MNTR_H
+#define ARC_MNTR_H
+
+extern const struct command_registration arc_monitor_command_handlers[];
+
+#endif /* ARC_MNTR_H */
diff --git a/src/target/arc_ocd.c b/src/target/arc_ocd.c
new file mode 100644
index 0000000..668090e
--- /dev/null
+++ b/src/target/arc_ocd.c
@@ -0,0 +1,217 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Mischa Jonker <mischa.jonker@synopsys.com>                            *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+
+/* ----- Supporting functions ---------------------------------------------- */
+
+static int arc_ocd_init_arch_info(struct target *target,
+	struct arc_common *arc, struct jtag_tap *tap)
+{
+	int retval = ERROR_OK;
+	struct arc32_common *arc32 = &arc->arc32;
+
+	LOG_DEBUG("Entering");
+
+	arc->common_magic = ARC_COMMON_MAGIC;
+
+	/* initialize arc specific info */
+	retval = arc32_init_arch_info(target, arc32, tap);
+	arc32->arch_info = arc;
+
+	return retval;
+}
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_ocd_poll(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t status;
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	/* gdb calls continuously through this arc_poll() function  */
+	retval = arc_jtag_status(&arc32->jtag_info, &status);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* check for processor halted */
+	if (status & ARC_JTAG_STAT_RU) {
+		if (target->state != TARGET_RUNNING){
+			LOG_WARNING("target is still running!");
+			target->state = TARGET_RUNNING;
+		}
+	} else {
+		if ((target->state == TARGET_RUNNING) ||
+			(target->state == TARGET_RESET)) {
+
+			target->state = TARGET_HALTED;
+			LOG_DEBUG("ARC core is halted or in reset.");
+
+			retval = arc_dbg_debug_entry(target);
+			if (retval != ERROR_OK)
+				return retval;
+
+			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+		} else if (target->state == TARGET_DEBUG_RUNNING) {
+
+			target->state = TARGET_HALTED;
+			LOG_DEBUG("ARC core is in debug running mode");
+
+			retval = arc_dbg_debug_entry(target);
+			if (retval != ERROR_OK)
+				return retval;
+
+			target_call_event_callbacks(target, TARGET_EVENT_DEBUG_HALTED);
+		}
+	}
+
+	return retval;
+}
+
+/* ......................................................................... */
+
+int arc_ocd_assert_reset(struct target *target)
+{
+	int retval = ERROR_OK;
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	LOG_DEBUG("%s target->state: %s", __func__, target_state_name(target));
+
+	enum reset_types jtag_reset_config = jtag_get_reset_config();
+
+	/* some cores support connecting while srst is asserted
+	 * use that mode is it has been configured */
+
+	bool srst_asserted = false;
+
+	if (!(jtag_reset_config & RESET_SRST_PULLS_TRST) &&
+			(jtag_reset_config & RESET_SRST_NO_GATING)) {
+		jtag_add_reset(0, 1);
+		srst_asserted = true;
+	}
+
+	if (jtag_reset_config & RESET_HAS_SRST) {
+		/* should issue a srst only, but we may have to assert trst as well */
+		if (jtag_reset_config & RESET_SRST_PULLS_TRST)
+			jtag_add_reset(1, 1);
+		else if (!srst_asserted)
+			jtag_add_reset(0, 1);
+	}
+
+	target->state = TARGET_RESET;
+	jtag_add_sleep(50000);
+
+	register_cache_invalidate(arc32->core_cache);
+
+	if (target->reset_halt)
+		retval = target_halt(target);
+
+	return retval;
+}
+
+int arc_ocd_deassert_reset(struct target *target)
+{
+	int retval = ERROR_OK;
+
+	LOG_DEBUG("%s target->state: %s", __func__, target_state_name(target));
+
+	/* deassert reset lines */
+	jtag_add_reset(0, 0);
+
+	return retval;
+}
+
+/* ......................................................................... */
+
+int arc_ocd_target_create(struct target *target, Jim_Interp *interp)
+{
+	int retval = ERROR_OK;
+
+	struct arc_common *arc = calloc(1, sizeof(struct arc_common));
+
+	retval = arc_ocd_init_arch_info(target, arc, target->tap);
+
+	return retval;
+}
+
+int arc_ocd_init_target(struct command_context *cmd_ctx, struct target *target)
+{
+	int retval = ERROR_OK;
+
+	arc_regs_build_reg_cache(target);
+
+	return retval;
+}
+
+int arc_ocd_examine(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t value, status;
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	retval = arc_jtag_startup(&arc32->jtag_info);
+
+	if (!target_was_examined(target)) {
+
+		/* read JTAG info */
+		arc_jtag_idcode(&arc32->jtag_info, &value);
+		LOG_DEBUG("JTAG ID: 0x%08" PRIx32, value);
+		arc_jtag_status(&arc32->jtag_info, &status);
+		LOG_DEBUG("JTAG status: 0x%08" PRIx32, status);
+
+		/* bring processor into HALT */
+		LOG_DEBUG("bring ARC core into HALT state");
+		arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG, &value);
+		value |= SET_CORE_FORCE_HALT;
+		arc_jtag_write_aux_reg_one(&arc32->jtag_info, AUX_DEBUG_REG, value);
+		sleep(1); /* just give us once some time to come to rest ;-) */
+
+		arc_jtag_status(&arc32->jtag_info, &status);
+		LOG_DEBUG("JTAG status: 0x%08" PRIx32, status);
+
+		/* read ARC core info */
+		arc_core_type_info(target);
+
+		arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_IDENTITY_REG, &value);
+		LOG_DEBUG("CPU ID: 0x%08" PRIx32, value);
+		arc_jtag_read_aux_reg_one(&arc32->jtag_info, AUX_PC_REG, &value);
+		LOG_DEBUG("current PC: 0x%08" PRIx32, value);
+
+		arc_jtag_status(&arc32->jtag_info, &status);
+		if (status & ARC_JTAG_STAT_RU) {
+			LOG_WARNING("target is still running !!");
+			target->state = TARGET_RUNNING;
+		} else {
+			LOG_DEBUG("target is halted.");
+			target->state = TARGET_RESET; /* means HALTED after restart */
+		}
+
+		target_set_examined(target);
+	}
+
+	return retval;
+}
diff --git a/src/target/arc_ocd.h b/src/target/arc_ocd.h
new file mode 100644
index 0000000..4b23746
--- /dev/null
+++ b/src/target/arc_ocd.h
@@ -0,0 +1,40 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC_OCD_H
+#define ARC_OCD_H
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_ocd_poll(struct target *target);
+
+/* ......................................................................... */
+
+int arc_ocd_assert_reset(struct target *target);
+int arc_ocd_deassert_reset(struct target *target);
+
+/* ......................................................................... */
+
+int arc_ocd_target_create(struct target *target, Jim_Interp *interp);
+int arc_ocd_init_target(struct command_context *cmd_ctx, struct target *target);
+int arc_ocd_examine(struct target *target);
+
+#endif /* ARC_OCD_H */
diff --git a/src/target/arc_regs.c b/src/target/arc_regs.c
new file mode 100644
index 0000000..f82c137
--- /dev/null
+++ b/src/target/arc_regs.c
@@ -0,0 +1,712 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Mischa Jonker <mischa.jonker@synopsys.com>                            *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+
+/* TODO: Register definitions are a bit inconsistent in that some properties
+ * are set statically in a description table, while some properties are set at
+ * runtime with `if` and `switch`. Would be good to rething this when time will
+ * allow. */
+
+/* XML feature names */
+static const char * const general_group_name = "general";
+static const char * const float_group_name = "float";
+static const char * const feature_core_basecase_name = "org.gnu.gdb.arc.core-basecase";
+static const char * const feature_core_extension_name = "org.gnu.gdb.arc.core-extension";
+static const char * const feature_core_pointers_name = "org.gnu.gdb.arc.core-pointers";
+static const char * const feature_core_link_name = "org.gnu.gdb.arc.core-linkregs.v2";
+static const char * const feature_core_other_name = "org.gnu.gdb.arc.core-other";
+static const char * const feature_aux_baseline_name = "org.gnu.gdb.arc.aux-baseline.v2";
+
+/* Describe all possible registers. */
+static const struct arc32_reg_desc arc32_regs_descriptions[ARC_TOTAL_NUM_REGS] = {
+	/* regnum, name, address, gdb_type, readonly, old_regnum */
+	{ ARC_REG_R0,       "r0",        0, REG_TYPE_UINT32,   false,  0, },
+	{ ARC_REG_R1,       "r1",        1, REG_TYPE_UINT32,   false,  1, },
+	{ ARC_REG_R2,       "r2",        2, REG_TYPE_UINT32,   false,  2, },
+	{ ARC_REG_R3,       "r3",        3, REG_TYPE_UINT32,   false,  3, },
+	{ ARC_REG_R4,       "r4",        4, REG_TYPE_UINT32,   false,  4, },
+	{ ARC_REG_R5,       "r5",        5, REG_TYPE_UINT32,   false,  5, },
+	{ ARC_REG_R6,       "r6",        6, REG_TYPE_UINT32,   false,  6, },
+	{ ARC_REG_R7,       "r7",        7, REG_TYPE_UINT32,   false,  7, },
+	{ ARC_REG_R8,       "r8",        8, REG_TYPE_UINT32,   false,  8, },
+	{ ARC_REG_R9,       "r9",        9, REG_TYPE_UINT32,   false,  9, },
+	{ ARC_REG_R10,      "r10",      10, REG_TYPE_UINT32,   false, 10, },
+	{ ARC_REG_R11,      "r11",      11, REG_TYPE_UINT32,   false, 11, },
+	{ ARC_REG_R12,      "r12",      12, REG_TYPE_UINT32,   false, 12, },
+	{ ARC_REG_R13,      "r13",      13, REG_TYPE_UINT32,   false, 13, },
+	{ ARC_REG_R14,      "r14",      14, REG_TYPE_UINT32,   false, 14, },
+	{ ARC_REG_R15,      "r15",      15, REG_TYPE_UINT32,   false, 15, },
+	{ ARC_REG_R16,      "r16",      16, REG_TYPE_UINT32,   false, 16, },
+	{ ARC_REG_R17,      "r17",      17, REG_TYPE_UINT32,   false, 17, },
+	{ ARC_REG_R18,      "r18",      18, REG_TYPE_UINT32,   false, 18, },
+	{ ARC_REG_R19,      "r19",      19, REG_TYPE_UINT32,   false, 19, },
+	{ ARC_REG_R20,      "r20",      20, REG_TYPE_UINT32,   false, 20, },
+	{ ARC_REG_R21,      "r21",      21, REG_TYPE_UINT32,   false, 21, },
+	{ ARC_REG_R22,      "r22",      22, REG_TYPE_UINT32,   false, 22, },
+	{ ARC_REG_R23,      "r23",      23, REG_TYPE_UINT32,   false, 23, },
+	{ ARC_REG_R24,      "r24",      24, REG_TYPE_UINT32,   false, 24, },
+	{ ARC_REG_R25,      "r25",      25, REG_TYPE_UINT32,   false, 25, },
+	{ ARC_REG_GP,       "gp",       26, REG_TYPE_DATA_PTR, false, 26, },
+	{ ARC_REG_FP,       "fp",       27, REG_TYPE_DATA_PTR, false, 27, },
+	{ ARC_REG_SP,       "sp",       28, REG_TYPE_DATA_PTR, false, 28, },
+	{ ARC_REG_ILINK,    "ilink",    29, REG_TYPE_CODE_PTR, false, 29, },
+	{ ARC_REG_R30,      "r30",      30, REG_TYPE_UINT32,   false, 30, },
+	{ ARC_REG_BLINK,    "blink",    31, REG_TYPE_CODE_PTR, false, 31, },
+	{ ARC_REG_R32,      "r32",      32, REG_TYPE_UINT32,   false, 32, },
+	{ ARC_REG_R33,      "r33",      33, REG_TYPE_UINT32,   false, 33, },
+	{ ARC_REG_R34,      "r34",      34, REG_TYPE_UINT32,   false, 34, },
+	{ ARC_REG_R35,      "r35",      35, REG_TYPE_UINT32,   false, 35, },
+	{ ARC_REG_R36,      "r36",      36, REG_TYPE_UINT32,   false, 36, },
+	{ ARC_REG_R37,      "r37",      37, REG_TYPE_UINT32,   false, 37, },
+	{ ARC_REG_R38,      "r38",      38, REG_TYPE_UINT32,   false, 38, },
+	{ ARC_REG_R39,      "r39",      39, REG_TYPE_UINT32,   false, 39, },
+	{ ARC_REG_R40,      "r40",      40, REG_TYPE_UINT32,   false, 40, },
+	{ ARC_REG_R41,      "r41",      41, REG_TYPE_UINT32,   false, 41, },
+	{ ARC_REG_R42,      "r42",      42, REG_TYPE_UINT32,   false, 42, },
+	{ ARC_REG_R43,      "r43",      43, REG_TYPE_UINT32,   false, 43, },
+	{ ARC_REG_R44,      "r44",      44, REG_TYPE_UINT32,   false, 44, },
+	{ ARC_REG_R45,      "r45",      45, REG_TYPE_UINT32,   false, 45, },
+	{ ARC_REG_R46,      "r46",      46, REG_TYPE_UINT32,   false, 46, },
+	{ ARC_REG_R47,      "r47",      47, REG_TYPE_UINT32,   false, 47, },
+	{ ARC_REG_R48,      "r48",      48, REG_TYPE_UINT32,   false, 48, },
+	{ ARC_REG_R49,      "r49",      49, REG_TYPE_UINT32,   false, 49, },
+	{ ARC_REG_R50,      "r50",      50, REG_TYPE_UINT32,   false, 50, },
+	{ ARC_REG_R51,      "r51",      51, REG_TYPE_UINT32,   false, 51, },
+	{ ARC_REG_R52,      "r52",      52, REG_TYPE_UINT32,   false, 52, },
+	{ ARC_REG_R53,      "r53",      53, REG_TYPE_UINT32,   false, 53, },
+	{ ARC_REG_R54,      "r54",      54, REG_TYPE_UINT32,   false, 54, },
+	{ ARC_REG_R55,      "r55",      55, REG_TYPE_UINT32,   false, 55, },
+	{ ARC_REG_R56,      "r56",      56, REG_TYPE_UINT32,   false, 56, },
+	{ ARC_REG_R57,      "r57",      57, REG_TYPE_UINT32,   false, 57, },
+	{ ARC_REG_R58,      "r58",      58, REG_TYPE_UINT32,   false, 58, },
+	{ ARC_REG_R59,      "r59",      59, REG_TYPE_UINT32,   false, 59, },
+	{ ARC_REG_LP_COUNT, "lp_count", 60, REG_TYPE_UINT32,   false, 60, },
+	{ ARC_REG_RESERVED, "reserved", 61, REG_TYPE_UINT32,    true, 61, },
+	{ ARC_REG_LIMM,     "limm",     62, REG_TYPE_UINT32,    true, 62, },
+	{ ARC_REG_R63,      "pcl",      63, REG_TYPE_CODE_PTR,  true, 63, },
+	/* AUX */
+	{ ARC_REG_PC,           "pc",		    0x6,   REG_TYPE_CODE_PTR, false, 64, },
+	{ ARC_REG_LP_START,     "lp_start",     0x2,   REG_TYPE_CODE_PTR, false, 65, },
+	{ ARC_REG_LP_END,       "lp_end",       0x3,   REG_TYPE_CODE_PTR, false, 66, },
+	{ ARC_REG_STATUS32,     "status32",     0xA,   REG_TYPE_UINT32,   false, 67, },
+	{ ARC_REG_IDENTITY,     "idenity",      0x4,   REG_TYPE_UINT32,    true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DEBUG,        "debug",        0x5,   REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_STATUS32_P0,  "status32_p0",  0xB,   REG_TYPE_UINT32,   false, 68, },
+	{ ARC_REG_STATUS32_L2,  "status32_l2",  0xC,   REG_TYPE_UINT32,    true, 69, },
+	{ ARC_REG_AUX_USER_SP,  "aux_user_sp",  0xD,   REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_AUX_IRQ_CTRL, "aux_irq_ctrl", 0xE,   REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IC_IVIC,      "ic_ivic",      0x10,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IC_CTRL,      "ic_ctrl",      0x11,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IC_LIL,       "ic_lil",       0x13,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_AUX_DCCM,     "aux_dccm",     0x18,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IC_IVIL,      "ic_ivil",      0x19,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IC_RAM_ADDR,  "ic_ram_addr",  0x1A,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IC_TAG,       "ic_tag",       0x1B,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IC_DATA,      "ic_data",      0x1D,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DEBUGI,       "debugi",       0x1F,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_COUNT0,       "count0",       0x21,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_CONTROL0,     "control0",     0x22,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_LIMIT0,       "limit0",       0x23,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_INT_VECTOR_BASE, "int_vector_base", 0x25, REG_TYPE_CODE_PTR, false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_AUX_IRQ_ACT,  "aux_irq_act",  0x43,  REG_TYPE_UINT32,   false, 70 },
+	{ ARC_REG_DC_IVDC,      "dc_ivdc",      0x47,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DC_CTRL,      "dc_ctrl",      0x48,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DC_LDL,       "dc_ldl",       0x49,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DC_IVDL,      "dc_ivdl",      0x4A,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DC_FLSH,      "dc_flsh",      0x4B,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DC_FLDL,      "dc_fldl",      0x4C,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DC_RAM_ADDR,  "dc_ram_addr",  0x58,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DC_TAG,       "dc_tag",       0x59,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DC_DATA,      "dc_data",      0x5B,  REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_COUNT1,       "count1",       0x100, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_CONTROL1,     "control1",     0x101, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_LIMIT1,       "limit1",       0x102, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_AUX_RTC_CTRL, "aux_rtc_ctrl", 0x103, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_AUX_RTC_LOW,  "aux_rtc_low",  0x104, REG_TYPE_UINT32,    true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_AUX_RTC_HIGH, "aux_rtc_high", 0x105, REG_TYPE_UINT32,    true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IRQ_PRIORITY_PENDING, "irq_priority_pending", 0x200, REG_TYPE_UINT32,  true, 71, },
+	{ ARC_REG_AUX_IRQ_HINT, "irq_hint",     0x201, REG_TYPE_UINT32,   false, 72, },
+	{ ARC_REG_IRQ_PRIORITY, "irq_priority", 0x206, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_AUX_ICCM,     "aux_iccm",     0x208, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_USTACK_TOP,   "ustack_top",   0x260, REG_TYPE_DATA_PTR, false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_USTACK_BASE,  "ustack_base",  0x261, REG_TYPE_DATA_PTR, false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_KSTACK_TOP,   "kstack_top",   0x264, REG_TYPE_DATA_PTR, false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_KSTACK_BASE,  "kstack_base",  0x265, REG_TYPE_DATA_PTR, false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_JLI_BASE,     "jli_base",     0x290, REG_TYPE_CODE_PTR, false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_LDI_BASE,     "ldi_base",     0x291, REG_TYPE_DATA_PTR, false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_EI_BASE,      "ei_base",      0x292, REG_TYPE_CODE_PTR, false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_ERET,         "eret",         0x400, REG_TYPE_CODE_PTR, false, 73, },
+	{ ARC_REG_ERBTA,        "erbta",        0x401, REG_TYPE_CODE_PTR, false, 74, },
+	{ ARC_REG_ERSTATUS,     "erstatus",     0x402, REG_TYPE_UINT32,   false, 75, },
+	{ ARC_REG_ECR,          "ecr",          0x403, REG_TYPE_UINT32,   false, 76, },
+	{ ARC_REG_EFA,          "efa",          0x404, REG_TYPE_CODE_PTR, false, 77, },
+	{ ARC_REG_MPU_EN,       "mpu_en",       0x409, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_ICAUSE,       "icause",       0x40A, REG_TYPE_UINT32,    true, 78, }, /* aka icause1 */
+	{ ARC_REG_IRQ_SELECT,   "irq_select",   0x40B, REG_TYPE_UINT32,   false, 79, }, /* aka icause2 */
+	{ ARC_REG_IRQ_ENABLE,   "irq_enable",   0x40C, REG_TYPE_UINT32,   false, 80, },
+	{ ARC_REG_IRQ_TRIGGER,  "irq_trigger",  0x40D, REG_TYPE_UINT32,   false, 81, },
+	{ ARC_REG_IRQ_STATUS,   "irq_status",   0x40F, REG_TYPE_UINT32,    true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_BTA,          "bta",          0x412, REG_TYPE_CODE_PTR, false, 82, },
+	{ ARC_REG_BTA_L1,       "bta_l1",       0x413, REG_TYPE_CODE_PTR, false, 83, },
+	{ ARC_REG_BTA_L2,       "bta_l2",       0x414, REG_TYPE_CODE_PTR, false, 84, },
+	{ ARC_REG_IRQ_PULSE_CANCEL, "irq_pulse_cancel", 0x415,  REG_TYPE_UINT32, false, 85, },
+	{ ARC_REG_IRQ_PENDING,  "irq_pending",  0x416, REG_TYPE_UINT32,    true, 86, },
+	{ ARC_REG_MPU_ECR,      "mpu_ecr",      0x420, REG_TYPE_UINT32,    true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB0,     "mpu_rdb0",     0x422, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP0,     "mpu_rdp0",     0x423, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB1,     "mpu_rdb1",     0x424, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP1,     "mpu_rdp1",     0x425, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB2,     "mpu_rdb2",     0x426, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP2,     "mpu_rdp2",     0x427, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB3,     "mpu_rdb3",     0x428, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP3,     "mpu_rdp3",     0x429, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB4,     "mpu_rdb4",     0x42A, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP4,     "mpu_rdp4",     0x42B, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB5,     "mpu_rdb5",     0x42C, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP5,     "mpu_rdp5",     0x42D, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB6,     "mpu_rdb6",     0x42E, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP6,     "mpu_rdp6",     0x42F, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB7,     "mpu_rdb7",     0x430, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP7,     "mpu_rdp7",     0x431, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB8,     "mpu_rdb8",     0x432, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP8,     "mpu_rdp8",     0x433, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB9,     "mpu_rdb9",     0x434, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP9,     "mpu_rdp9",     0x435, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB10,    "mpu_rdb10",    0x436, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP10,    "mpu_rdp10",    0x437, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB11,    "mpu_rdb11",    0x438, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP11,    "mpu_rdp11",    0x439, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB12,    "mpu_rdb12",    0x43A, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP12,    "mpu_rdp12",    0x43B, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB13,    "mpu_rdb13",    0x43C, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP13,    "mpu_rdp13",    0x43D, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB14,    "mpu_rdb14",    0x43E, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP14,    "mpu_rdp14",    0x43F, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDB15,    "mpu_rdb15",    0x440, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_RDP15,    "mpu_rdp15",    0x441, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_SMART_CONTROL,"smart_control",0x700, REG_TYPE_UINT32,   false, ARC_INVALID_REGNUM, },
+	{ ARC_REG_SMART_DATA,   "smart_data",   0x701, REG_TYPE_UINT32,    true, ARC_INVALID_REGNUM, },
+	/* BCR */
+	{ ARC_REG_BCR_VER,          "bcr_ver",          0x60, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_BTA_LINK_BUILD,   "bta_link_build",   0x63, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_VECBASE_AC_BUILD, "vecbase_ac_build", 0x68, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MPU_BUILD,        "mpu_build",        0x6D, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_RF_BUILD,         "rf_build",         0x6E, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_D_CACHE_BUILD,    "d_cache_build",    0x72, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_DCCM_BUILD,       "dccm_build",       0x74, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_TIMER_BUILD,      "timer_build",      0x75, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_AP_BUILD,         "ap_build",         0x76, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_I_CACHE_BUILD,    "i_cache_build",    0x77, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_ICCM_BUILD,       "iccm_build",       0x78, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MULTIPLY_BUILD,   "multiply_build",   0x7B, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_SWAP_BUILD,       "swap_build",       0x7C, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_NORM_BUILD,       "norm_build",       0x7D, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_MINMAX_BUILD,     "minmax_build",     0x7E, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_BARREL_BUILD,     "barrel_build",     0x7F, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_ISA_CONFIG,       "isa_config",       0xC1, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_STACK_REGION_BUILD, "stack_region_build", 0xC5, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_CPROT_BUILD,      "cprot_build",      0xC9, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IRQ_BUILD,        "irq_build",        0xF3, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_IFQUEUE_BUILD,    "ifqueue_build",    0xFE, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+	{ ARC_REG_SMART_BUILD,      "smart_build",      0xFF, REG_TYPE_UINT32, true, ARC_INVALID_REGNUM, },
+};
+
+static int arc_regs_get_core_reg(struct reg *reg)
+{
+	int retval = ERROR_OK;
+	assert(reg != NULL);
+
+	struct arc_reg_t *arc_reg = reg->arch_info;
+	struct target *target = arc_reg->target;
+	struct arc32_common *arc32 = target_to_arc32(target);
+	const uint32_t regnum = arc_reg->desc->regnum;
+
+	if (target->state != TARGET_HALTED)
+		return ERROR_TARGET_NOT_HALTED;
+
+	if (regnum >= ARC_TOTAL_NUM_REGS)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (!arc32->bcr_init)
+		arc_regs_read_bcrs(target);
+
+	if (reg->valid) {
+		LOG_DEBUG("Get register (cached) regnum=%" PRIu32 ", name=%s, value=0x%" PRIx32,
+				regnum, arc_reg->desc->name, arc_reg->value);
+		return ERROR_OK;
+	}
+
+	if (regnum == ARC_REG_LIMM || regnum == ARC_REG_RESERVED) {
+		arc_reg->value = 0;
+	} else if (regnum < ARC_REG_FIRST_AUX) {
+		arc_jtag_read_core_reg_one(&arc32->jtag_info, arc_reg->desc->addr, &arc_reg->value);
+	} else {
+		arc_jtag_read_aux_reg_one(&arc32->jtag_info, arc_reg->desc->addr, &arc_reg->value);
+	}
+
+	buf_set_u32(arc32->core_cache->reg_list[regnum].value, 0, 32, arc_reg->value);
+	arc32->core_cache->reg_list[regnum].valid = true;
+	arc32->core_cache->reg_list[regnum].dirty = false;
+	LOG_DEBUG("Get register regnum=%" PRIu32 ", name=%s, value=0x%" PRIx32,
+			regnum , arc_reg->desc->name, arc_reg->value);
+
+	return retval;
+}
+
+static int arc_regs_set_core_reg(struct reg *reg, uint8_t *buf)
+{
+	int retval = ERROR_OK;
+
+	LOG_DEBUG("-");
+	struct arc_reg_t *arc_reg = reg->arch_info;
+	struct target *target = arc_reg->target;
+	struct arc32_common *arc32 = target_to_arc32(target);
+	uint32_t value = buf_get_u32(buf, 0, 32);
+	uint32_t regnum = arc_reg->desc->regnum;
+
+	if (target->state != TARGET_HALTED)
+		return ERROR_TARGET_NOT_HALTED;
+
+	if (regnum >= ARC_TOTAL_NUM_REGS)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (!arc32->bcr_init)
+		arc_regs_read_bcrs(target);
+
+	if (arc_reg->desc->readonly) {
+		LOG_ERROR("Cannot set value to a read-only register %s.", arc_reg->desc->name);
+		return ERROR_FAIL;
+	}
+
+	buf_set_u32(reg->value, 0, 32, value);
+
+	arc_reg->value = value;
+
+	LOG_DEBUG("Set register regnum=%" PRIu32 ", name=%s, value=0x%08" PRIx32,
+			regnum, arc_reg->desc->name, value);
+	arc32->core_cache->reg_list[regnum].valid = true;
+	arc32->core_cache->reg_list[regnum].dirty = true;
+
+	return retval;
+}
+
+static const struct reg_arch_type arc32_reg_type = {
+	.get = arc_regs_get_core_reg,
+	.set = arc_regs_set_core_reg,
+};
+
+/**
+ * Read BCRs.
+ */
+int arc_regs_read_bcrs(struct target *target)
+{
+	LOG_DEBUG("-");
+
+	int retval = ERROR_OK;
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct reg *reg_list = arc32->core_cache->reg_list;
+
+	/* BCRs never change. No need to execute this function multiple times. */
+	if (arc32->bcr_init)
+		return retval;
+
+	/* Don't read BCR's in compatibility mode. */
+	if (arc32->gdb_compatibility_mode) {
+		arc32->bcr_init = true;
+		return retval;
+	}
+
+	uint32_t numregs = ARC_REG_AFTER_BCR - ARC_REG_FIRST_BCR;
+	uint32_t *addrs = calloc(numregs, sizeof(uint32_t));
+	uint32_t *values = calloc(numregs, sizeof(uint32_t));
+
+	for (unsigned i = ARC_REG_FIRST_BCR; i < ARC_REG_AFTER_BCR; i++) {
+		addrs[i - ARC_REG_FIRST_BCR]  = arc32_regs_descriptions[i].addr;
+	}
+	retval = arc_jtag_read_aux_reg(&arc32->jtag_info, addrs, numregs, values);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Error reading BCR registers from target.");
+		free(addrs);
+		free(values);
+		return retval;
+	}
+
+	struct bcr_set_t *bcrs = &(arc32->bcr_set);
+	bcrs->bcr_ver.raw = values[ARC_REG_BCR_VER - ARC_REG_FIRST_BCR];
+	bcrs->bta_link_build.raw = values[ARC_REG_BTA_LINK_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->vecbase_ac_build.raw = values[ARC_REG_VECBASE_AC_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->mpu_build.raw = values[ARC_REG_MPU_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->rf_build.raw = values[ARC_REG_RF_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->d_cache_build.raw = values[ARC_REG_D_CACHE_BUILD - ARC_REG_FIRST_BCR];
+
+	bcrs->dccm_build.raw = values[ARC_REG_DCCM_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->timer_build.raw = values[ARC_REG_TIMER_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->ap_build.raw = values[ARC_REG_AP_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->i_cache_build.raw = values[ARC_REG_I_CACHE_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->iccm_build.raw = values[ARC_REG_ICCM_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->multiply_build.raw = values[ARC_REG_MULTIPLY_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->swap_build.raw = values[ARC_REG_SWAP_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->norm_build.raw = values[ARC_REG_NORM_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->minmax_build.raw = values[ARC_REG_MINMAX_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->barrel_build.raw = values[ARC_REG_BARREL_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->isa_config.raw = values[ARC_REG_ISA_CONFIG - ARC_REG_FIRST_BCR];
+	bcrs->stack_region_build.raw = values[ARC_REG_STACK_REGION_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->cprot_build.raw = values[ARC_REG_CPROT_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->irq_build.raw = values[ARC_REG_IRQ_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->ifqueue_build.raw = values[ARC_REG_IFQUEUE_BUILD - ARC_REG_FIRST_BCR];
+	bcrs->smart_build.raw = values[ARC_REG_SMART_BUILD - ARC_REG_FIRST_BCR];
+
+	free(addrs);
+	free(values);
+
+	/* Enable baseline registers which are always present. */
+	reg_list[ARC_REG_IDENTITY].exist = true;
+	reg_list[ARC_REG_PC].exist = true;
+	reg_list[ARC_REG_STATUS32].exist = true;
+	reg_list[ARC_REG_BTA].exist = true;
+	reg_list[ARC_REG_ECR].exist = true;
+	reg_list[ARC_REG_INT_VECTOR_BASE].exist = true;
+	reg_list[ARC_REG_AUX_USER_SP].exist = true;
+	reg_list[ARC_REG_ERET].exist = true;
+	reg_list[ARC_REG_ERBTA].exist = true;
+	reg_list[ARC_REG_ERSTATUS].exist = true;
+	reg_list[ARC_REG_EFA].exist = true;
+
+	/* Enable debug registers. They accompany debug host interface, so there is
+	 * no way OpenOCD could communicate with target that has no such registers.
+	 */
+	reg_list[ARC_REG_DEBUG].exist = true;
+	reg_list[ARC_REG_DEBUGI].exist = true;
+
+	/* AUX registers are disabled by default, enable them depending on BCR
+	 * contents. */
+	for (unsigned regnum = 0; regnum < ARC_TOTAL_NUM_REGS; regnum++) {
+		/* Some core regs are missing from cores with reduced register banks. */
+		if (bcrs->rf_build.e &&
+		   ((regnum > ARC_REG_R3 && regnum < ARC_REG_R10) ||
+			(regnum > ARC_REG_R15 && regnum < ARC_REG_R26))) {
+			reg_list[regnum].exist = false;
+			continue;
+		}
+
+		/* Enable MPU regions registers */
+		if (regnum >= ARC_REG_MPU_RDB0 && regnum <= ARC_REG_MPU_RDP15 &&
+			(bcrs->mpu_build.version >= 2)) {
+			const unsigned num_regions = bcrs->mpu_build.regions;
+			/* Shift because we have two registers per region. Add  */
+			const unsigned region_id = (regnum - ARC_REG_MPU_RDB0) >> 1;
+			if (region_id + 1 >= num_regions) {
+				reg_list[regnum].exist = true;
+			}
+			continue;
+		}
+
+		switch (regnum) {
+			/* Enable zero-delay loop registers. */
+			case ARC_REG_LP_START:
+			case ARC_REG_LP_END:
+				if (bcrs->isa_config.lpc_size)
+					reg_list[regnum].exist = true;
+				break;
+			/* Enable code density registers (not for ISAv1). */
+			case ARC_REG_JLI_BASE:
+			case ARC_REG_LDI_BASE:
+			case ARC_REG_EI_BASE:
+				if (bcrs->isa_config.c && bcrs->isa_config.version >= 2)
+					reg_list[regnum].exist = true;
+				break;
+			/* Timer 0 */
+			case ARC_REG_COUNT0:
+			case ARC_REG_CONTROL0:
+			case ARC_REG_LIMIT0:
+				if (bcrs->timer_build.t0)
+					reg_list[regnum].exist = true;
+				break;
+			/* Timer 1 */
+			case ARC_REG_COUNT1:
+			case ARC_REG_CONTROL1:
+			case ARC_REG_LIMIT1:
+				if (bcrs->timer_build.t1)
+					reg_list[regnum].exist = true;
+				break;
+			/* RTC: 64-bit timer */
+			case ARC_REG_AUX_RTC_CTRL:
+			case ARC_REG_AUX_RTC_LOW:
+			case ARC_REG_AUX_RTC_HIGH:
+				if (bcrs->timer_build.rtc)
+					reg_list[regnum].exist = true;
+				break;
+			/* I$ with feature level 0 and up*/
+			case ARC_REG_IC_IVIC:
+			case ARC_REG_IC_CTRL:
+				if (bcrs->i_cache_build.version >= 4)
+					reg_list[regnum].exist = true;
+				break;
+			/* I$ with feature level 1 and up */
+			case ARC_REG_IC_LIL:
+			case ARC_REG_IC_IVIL:
+				if (bcrs->i_cache_build.version >= 4 && bcrs->i_cache_build.fl > 0)
+					reg_list[regnum].exist = true;
+				break;
+			/* I$ with feature level 2 */
+			case ARC_REG_IC_RAM_ADDR:
+			case ARC_REG_IC_TAG:
+			case ARC_REG_IC_DATA:
+				if (bcrs->i_cache_build.version >= 4 && bcrs->i_cache_build.fl > 1)
+					reg_list[regnum].exist = true;
+				break;
+			/* D$ with feature level 0 and up*/
+			case ARC_REG_DC_IVDC:
+			case ARC_REG_DC_CTRL:
+			case ARC_REG_DC_FLSH:
+				if (bcrs->d_cache_build.version >= 4)
+					reg_list[regnum].exist = true;
+				break;
+			/* D$ with feature level 1 and up */
+			case ARC_REG_DC_LDL:
+			case ARC_REG_DC_IVDL:
+			case ARC_REG_DC_FLDL:
+				if (bcrs->d_cache_build.version >= 4 && bcrs->d_cache_build.fl > 0)
+					reg_list[regnum].exist = true;
+				break;
+			/* D$ with feature level 2 */
+			case ARC_REG_DC_RAM_ADDR:
+			case ARC_REG_DC_TAG:
+			case ARC_REG_DC_DATA:
+				if (bcrs->d_cache_build.version >= 4 && bcrs->d_cache_build.fl > 1)
+					reg_list[regnum].exist = true;
+				break;
+			/* DCCM regs */
+			case ARC_REG_AUX_DCCM:
+				if (bcrs->dccm_build.version >= 3)
+					reg_list[regnum].exist = true;
+				break;
+			/* ICCM regs */
+			case ARC_REG_AUX_ICCM:
+				if (bcrs->dccm_build.version >= 4)
+					reg_list[regnum].exist = true;
+				break;
+			/* Enable MPU registers. */
+			case ARC_REG_MPU_EN:
+			case ARC_REG_MPU_ECR:
+				if (bcrs->mpu_build.version >= 2)
+					reg_list[regnum].exist = true;
+				break;
+			/* Enable SMART registers */
+			case ARC_REG_SMART_CONTROL:
+			case ARC_REG_SMART_DATA:
+				if (bcrs->smart_build.version >= 3)
+					reg_list[regnum].exist = true;
+				break;
+			/* Enable STATUS32_P0 for fast interrupts. */
+			case ARC_REG_STATUS32_P0:
+				if (bcrs->irq_build.version >= 2 && bcrs->irq_build.f)
+					reg_list[regnum].exist = true;
+				break;
+			/* Enable interrupt registers  */
+			case ARC_REG_AUX_IRQ_CTRL:
+			case ARC_REG_AUX_IRQ_ACT:
+			case ARC_REG_IRQ_SELECT:
+			case ARC_REG_IRQ_PRIORITY:
+			case ARC_REG_IRQ_ENABLE:
+			case ARC_REG_IRQ_TRIGGER:
+			case ARC_REG_IRQ_PENDING:
+			case ARC_REG_IRQ_PULSE_CANCEL:
+			case ARC_REG_IRQ_STATUS:
+			case ARC_REG_IRQ_PRIORITY_PENDING:
+			case ARC_REG_AUX_IRQ_HINT:
+			case ARC_REG_ICAUSE:
+				if (bcrs->irq_build.version >= 2 && bcrs->irq_build.irqs)
+					reg_list[regnum].exist = true;
+				break;
+			/* Stack checking registers */
+			case ARC_REG_KSTACK_BASE:
+			case ARC_REG_KSTACK_TOP:
+			case ARC_REG_USTACK_BASE:
+			case ARC_REG_USTACK_TOP:
+				if (bcrs->stack_region_build.version >= 2)
+					reg_list[regnum].exist = true;
+				break;
+		}
+	}
+
+	/* Ensure that this function will not be called in the future. */
+	arc32->bcr_init = true;
+
+	return retval;
+}
+
+struct reg_cache *arc_regs_build_reg_cache(struct target *target)
+{
+	uint32_t i;
+
+	/* get pointers to arch-specific information */
+	struct arc32_common *arc32 = target_to_arc32(target);
+	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
+	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
+	struct reg *reg_list = calloc(ARC_TOTAL_NUM_REGS, sizeof(struct reg));
+	struct arc_reg_t *arch_info = calloc(ARC_TOTAL_NUM_REGS, sizeof(struct arc_reg_t));
+
+	/* Build the process context cache */
+	cache->name = "arc32 registers";
+	cache->next = NULL;
+	cache->reg_list = reg_list;
+	cache->num_regs = ARC_TOTAL_NUM_REGS;
+	(*cache_p) = cache;
+	arc32->core_cache = cache;
+
+	// XML features
+	struct reg_feature *core_basecase = calloc(1, sizeof(struct reg_feature));
+	core_basecase->name = feature_core_basecase_name;
+	struct reg_feature *core_extension = calloc(1, sizeof(struct reg_feature));
+	core_extension->name = feature_core_extension_name;
+	struct reg_feature *core_pointers = calloc(1, sizeof(struct reg_feature));
+	core_pointers->name = feature_core_pointers_name;
+	struct reg_feature *core_link = calloc(1, sizeof(struct reg_feature));
+	core_link->name = feature_core_link_name;
+	struct reg_feature *core_other = calloc(1, sizeof(struct reg_feature));
+	core_other->name = feature_core_other_name;
+	struct reg_feature *aux_baseline = calloc(1, sizeof(struct reg_feature));
+	aux_baseline->name = feature_aux_baseline_name;
+
+	/* Data types */
+	struct reg_data_type *uint32_data_type = calloc(sizeof(struct reg_data_type), 1);
+	struct reg_data_type *code_ptr_data_type = calloc(sizeof(struct reg_data_type), 1);
+	struct reg_data_type *data_ptr_data_type = calloc(sizeof(struct reg_data_type), 1);
+	uint32_data_type->type = REG_TYPE_UINT32;
+	uint32_data_type->id = "uint32";
+	code_ptr_data_type->type = REG_TYPE_CODE_PTR;
+	code_ptr_data_type->id = "code_ptr";
+	data_ptr_data_type->type = REG_TYPE_DATA_PTR;
+	data_ptr_data_type->id = "data_ptr";
+	/* Only three data types are used by ARC */
+	struct reg_data_type *data_types[13] = { NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, uint32_data_type, NULL, NULL, code_ptr_data_type,
+		data_ptr_data_type };
+
+	for (i = 0; i < ARC_TOTAL_NUM_REGS; i++) {
+		arch_info[i].desc = arc32_regs_descriptions + i;
+		arch_info[i].target = target;
+		arch_info[i].arc32_common = arc32;
+		arch_info[i].dummy = false;
+		reg_list[i].name = arc32_regs_descriptions[i].name;
+		reg_list[i].size = 32;
+		reg_list[i].value = calloc(1, 4);
+		reg_list[i].dirty = 0;
+		reg_list[i].valid = 0;
+		reg_list[i].type = &arc32_reg_type;
+		reg_list[i].arch_info = &arch_info[i];
+
+		if (!arc32->gdb_compatibility_mode) {
+			reg_list[i].number = arc32_regs_descriptions[i].regnum;
+			/* By default only core regs and BCRs are enabled. */
+			reg_list[i].exist = (i < ARC_REG_AFTER_CORE || i == ARC_REG_PCL ||
+					(i >= ARC_REG_FIRST_BCR && i < ARC_REG_AFTER_BCR));
+		} else {
+			reg_list[i].number = arch_info[i].desc->old_regnum;
+			reg_list[i].exist = (arch_info[i].desc->old_regnum != ARC_INVALID_REGNUM);
+			if ((i >= ARC_REG_FIRST_CORE_EXT && i < ARC_REG_AFTER_CORE_EXT) ||
+				i == ARC_REG_LIMM || i == ARC_REG_RESERVED ||
+				i == ARC_REG_STATUS32_L2 || i == ARC_REG_BTA_L1 ||
+				i == ARC_REG_BTA_L2 ) {
+				arch_info[i].dummy = true;
+			}
+		}
+
+		reg_list[i].group = general_group_name;
+		reg_list[i].caller_save = true;
+		reg_list[i].reg_data_type = data_types[ arch_info[i].desc->gdb_type ];
+
+		if (i < ARC_REG_GP) {
+			reg_list[i].feature = core_basecase;
+		} else if (ARC_REG_GP <= i && i < ARC_REG_ILINK) {
+			reg_list[i].feature = core_pointers;
+		} else if (ARC_REG_ILINK <= i && i < ARC_REG_AFTER_CORE) {
+			reg_list[i].feature = core_link;
+		} else if ((ARC_REG_FIRST_CORE_EXT <= i && i < ARC_REG_AFTER_CORE_EXT) ||
+					i == ARC_REG_LIMM || i == ARC_REG_RESERVED) {
+			reg_list[i].feature = core_extension;
+		} else if (ARC_REG_AFTER_CORE_EXT <= i && i < ARC_REG_FIRST_AUX) {
+			reg_list[i].feature = core_other;
+		} else if (ARC_REG_PC <= i) {
+			reg_list[i].feature = aux_baseline;
+		} else {
+			LOG_WARNING("Unknown register with number %" PRIu32, i);
+			reg_list[i].feature = NULL;
+		}
+
+		LOG_DEBUG("reg n=%3i name=%3s group=%s feature=%s", i,
+			reg_list[i].name, reg_list[i].group,
+			reg_list[i].feature->name);
+	}
+
+	return cache;
+}
+
+
+int arc_regs_get_gdb_reg_list(struct target *target, struct reg **reg_list[],
+	int *reg_list_size, enum target_register_class reg_class)
+{
+	int retval = ERROR_OK;
+	int i;
+
+	struct arc32_common *arc32 = target_to_arc32(target);
+
+	/* get pointers to arch-specific information storage */
+	*reg_list_size = ARC_TOTAL_NUM_REGS;
+	*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
+
+	/* OpenOCD gdb_server API seems to be inconsistent here: when it generates
+	 * XML tdesc it filters out !exist registers, however when creating a
+	 * g-packet it doesn't do so. REG_CLASS_ALL is used in first case, and
+	 * REG_CLASS_GENERAL used in the latter one. Due to this we had to filter
+	 * out !exist register for "general", but not for "all". Attempts to filter out
+	 * !exist for "all" as well will cause a failed check in OpenOCD GDB
+	 * server. */
+	if (reg_class == REG_CLASS_ALL) {
+		for (i = 0; i < ARC_TOTAL_NUM_REGS; i++) {
+			(*reg_list)[i] = &arc32->core_cache->reg_list[i];
+		}
+		LOG_DEBUG("REG_CLASS_ALL: number of regs=%i", *reg_list_size);
+	} else {
+		int cur_index = 0;
+		for (i = 0; i < ARC_TOTAL_NUM_REGS; i++) {
+			/* In compatibility mode we pass all existing regs. In normal mode
+			 * we pass only a core registers. */
+			if ((i < ARC_REG_AFTER_GDB_GENERAL || arc32->gdb_compatibility_mode) &&
+					arc32->core_cache->reg_list[i].exist) {
+				(*reg_list)[cur_index] = &arc32->core_cache->reg_list[i];
+				cur_index += 1;
+			}
+		}
+		*reg_list_size = cur_index;
+		LOG_DEBUG("REG_CLASS_GENERAL: number of regs=%i", *reg_list_size);
+	}
+
+	return retval;
+}
+
diff --git a/src/target/arc_regs.h b/src/target/arc_regs.h
new file mode 100644
index 0000000..b9e835b
--- /dev/null
+++ b/src/target/arc_regs.h
@@ -0,0 +1,616 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Mischa Jonker <mischa.jonker@synopsys.com>                            *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC_REGS_H
+#define ARC_REGS_H
+
+#include "target.h"
+
+/* Would be great to replace usage of constants with usage of arc32_reg_desc.
+ * But that's quite a lot of code. */
+/* --------------------------------------------------------------------------
+ * ARC core Auxiliary register set
+ *      name:					id:		bitfield:	comment:
+ *      ------                  ----    ----------  ---------
+ */
+#define AUX_STATUS_REG			0x0					/* LEGACY, IS OBSOLETE */
+#define STAT_HALT_BIT					(1 << 25)
+
+#define AUX_SEMAPHORE_REG	 	0x1
+#define AUX_LP_START_REG		0x2
+#define AUX_LP_END_REG			0x3
+#define AUX_IDENTITY_REG		0x4
+
+#define AUX_DEBUG_REG			0x5
+#define SET_CORE_SINGLE_STEP			(1)
+#define SET_CORE_FORCE_HALT				(1 << 1)
+#define SET_CORE_SINGLE_INSTR_STEP		(1 << 11)
+#define SET_CORE_RESET_APPLIED			(1 << 22)
+#define SET_CORE_SLEEP_MODE				(1 << 23)
+#define SET_CORE_USER_BREAKPOINT		(1 << 28)
+#define SET_CORE_BREAKPOINT_HALT		(1 << 29)
+#define SET_CORE_SELF_HALT				(1 << 30)
+#define SET_CORE_LOAD_PENDING			(1 << 31)
+
+#define AUX_PC_REG				0x6
+
+#define AUX_STATUS32_REG		0xA
+#define SET_CORE_HALT_BIT				(1)
+#define SET_CORE_INTRP_MASK_E1			(1 << 1)
+#define SET_CORE_INTRP_MASK_E2			(1 << 2)
+#define SET_CORE_AE_BIT					(1 << 5)
+
+#define AUX_STATUS32_L1_REG		0xB
+#define AUX_STATUS32_L2_REG		0xC
+#define AUX_USER_SP_REG         0xD
+
+#define AUX_IC_IVIC_REG			0X10
+#define IC_IVIC_INVALIDATE		0XFFFFFFFF
+
+#define AUX_COUNT0_REG			0x21
+#define AUX_CONTROL0_REG		0x22
+#define AUX_LIMIT0_REG			0x23
+#define AUX_INT_VECTOR_BASE_REG	0x25
+#define AUX_MACMODE_REG			0x41
+#define AUX_IRQ_LV12_REG		0x43
+
+#define AUX_DC_IVDC_REG			0X47
+#define DC_IVDC_INVALIDATE		(1)
+#define AUX_DC_CTRL_REG			0X48
+#define DC_CTRL_IM			(1 << 6)
+
+#define AUX_COUNT1_REG			0x100
+#define AUX_CONTROL1_REG		0x101
+#define AUX_LIMIT1_REG			0x102
+#define AUX_IRQ_LEV_REG			0x200
+#define AUX_IRQ_HINT_REG		0x201
+#define AUX_ERET_REG			0x400
+#define AUX_ERBTA_REG			0x401
+#define AUX_ERSTATUS_REG		0x402
+#define AUX_ECR_REG				0x403
+#define AUX_EFA_REG				0x404
+#define AUX_ICAUSE1_REG			0x40A
+#define AUX_ICAUSE2_REG			0x40B
+
+#define AUX_IENABLE_REG			0x40C
+#define SET_CORE_DISABLE_INTERRUPTS		0x00000000
+#define SET_CORE_ENABLE_INTERRUPTS		0xFFFFFFFF
+
+#define AUX_ITRIGGER_REG		0x40D
+#define AUX_XPU_REG				0x410
+#define AUX_BTA_REG				0x412
+#define AUX_BTA_L1_REG			0x413
+#define AUX_BTA_L2_REG			0x414
+#define AUX_IRQ_PULSE_CAN_REG	0x415
+#define AUX_IRQ_PENDING_REG		0x416
+#define AUX_XFLAGS_REG			0x44F
+
+#define AUX_BCR_VER_REG			0x60
+#define AUX_BTA_LINK_BUILD_REG	0x63
+#define AUX_VECBASE_AC_BUILD_REG	0x68
+#define AUX_RF_BUILD_REG		0x6E
+#define AUX_ISA_CONFIG_REG		0xC1
+#define AUX_DCCM_BUILD_REG		0x74
+
+#define AUX_ICCM_BUILD_REG		0x78
+
+ /* Action Point */
+#define AP_AMV_BASE				0x220
+#define AP_AMM_BASE				0x221
+#define AP_AC_BASE				0x222
+#define AP_STRUCT_LEN			0x3
+
+#define AP_AC_AT_INST_ADDR		0x0
+#define AP_AC_AT_MEMORY_ADDR	0x2
+#define AP_AC_AT_AUXREG_ADDR	0x4
+
+#define AP_AC_TT_DISABLE		0x00
+#define AP_AC_TT_WRITE			0x10
+#define AP_AC_TT_READ			0x20
+#define AP_AC_TT_READWRITE		0x30
+
+struct arc32_reg_desc {
+	uint32_t regnum;
+	char * const name;
+	uint32_t addr;
+	enum reg_type gdb_type;
+	bool readonly;
+	/* Previously GDB for ARC didn't supported XML target descriptions and used
+	 * one format of g/G-packet to fit all needs. Since we need to maintain
+	 * compatibility (at least for some time) this regnum will be used if
+	 * compatibility mode is on. Value ARC_INVALID_REGNUM means that register is
+	 * not present in old packet. */
+	uint32_t old_regnum;
+};
+
+#define ARC_INVALID_REGNUM (0xFFFFFFFF)
+
+struct arc_reg_t {
+	const struct arc32_reg_desc *desc;
+	struct target *target;
+	struct arc32_common *arc32_common;
+	uint32_t value;
+	bool dummy;
+};
+
+enum arc32_reg_number {
+	/* Core registers */
+	ARC_REG_R0 = 0,
+	ARC_REG_R1,
+	ARC_REG_R2,
+	ARC_REG_R3,
+	ARC_REG_R4,
+	ARC_REG_R5,
+	ARC_REG_R6,
+	ARC_REG_R7,
+	ARC_REG_R8,
+	ARC_REG_R9,
+	ARC_REG_R10,
+	ARC_REG_R11,
+	ARC_REG_R12,
+	ARC_REG_R13,
+	ARC_REG_R14,
+	ARC_REG_R15,
+	ARC_REG_R16,
+	ARC_REG_R17,
+	ARC_REG_R18,
+	ARC_REG_R19,
+	ARC_REG_R20,
+	ARC_REG_R21,
+	ARC_REG_R22,
+	ARC_REG_R23,
+	ARC_REG_R24,
+	ARC_REG_R25,
+	ARC_REG_R26,
+	ARC_REG_GP = ARC_REG_R26,
+	ARC_REG_R27,
+	ARC_REG_FP = ARC_REG_R27,
+	ARC_REG_R28,
+	ARC_REG_SP = ARC_REG_R28,
+	ARC_REG_R29,
+	ARC_REG_ILINK = ARC_REG_R29,
+	ARC_REG_R30,
+	ARC_REG_R31,
+	ARC_REG_BLINK = ARC_REG_R31,
+
+	/* Core extension registers */
+	ARC_REG_AFTER_CORE,
+	ARC_REG_FIRST_CORE_EXT = ARC_REG_AFTER_CORE,
+	ARC_REG_R32 = ARC_REG_R31 + 1,
+	ARC_REG_R33,
+	ARC_REG_R34,
+	ARC_REG_R35,
+	ARC_REG_R36,
+	ARC_REG_R37,
+	ARC_REG_R38,
+	ARC_REG_R39,
+	ARC_REG_R40,
+	ARC_REG_R41,
+	ARC_REG_R42,
+	ARC_REG_R43,
+	ARC_REG_R44,
+	ARC_REG_R45,
+	ARC_REG_R46,
+	ARC_REG_R47,
+	ARC_REG_R48,
+	ARC_REG_R49,
+	ARC_REG_R50,
+	ARC_REG_R51,
+	ARC_REG_R52,
+	ARC_REG_R53,
+	ARC_REG_R54,
+	ARC_REG_R55,
+	ARC_REG_R56,
+	ARC_REG_R57,
+	/* In HS R58 and R59 are ACCL and ACCH. */
+	ARC_REG_R58,
+	ARC_REG_R59,
+	ARC_REG_AFTER_CORE_EXT,
+
+	/* Additional core registers. */
+	ARC_REG_R60 = ARC_REG_AFTER_CORE_EXT,
+	ARC_REG_LP_COUNT = ARC_REG_R60,
+	ARC_REG_R61, /* Not a register: reserved address. */
+	ARC_REG_RESERVED = ARC_REG_R61,
+	ARC_REG_R62, /* Not a register: long immediate value. */
+	ARC_REG_LIMM = ARC_REG_R62,
+	ARC_REG_R63,
+	ARC_REG_PCL = ARC_REG_R63,
+	/* End of core register. */
+
+	/* AUX registers */
+	/* First register in this list are also "general" registers: the ones which
+	 * are included in GDB g/G-packeta. General registers start from the
+	 * regnum=0.  */
+	ARC_REG_FIRST_AUX,
+	ARC_REG_PC = ARC_REG_FIRST_AUX,
+	/* ZD-loops */
+	ARC_REG_LP_START,
+	ARC_REG_LP_END,
+	/* /ZD-loop */
+	ARC_REG_STATUS32,
+
+	ARC_REG_AFTER_GDB_GENERAL,
+
+	/* Other baseline AUX registers. */
+	ARC_REG_IDENTITY = ARC_REG_AFTER_GDB_GENERAL,
+	ARC_REG_DEBUG,
+	ARC_REG_STATUS32_P0,
+	ARC_REG_STATUS32_L2,
+	ARC_REG_AUX_USER_SP,
+	ARC_REG_AUX_IRQ_CTRL,
+	ARC_REG_IC_IVIC,
+	ARC_REG_IC_CTRL,
+	ARC_REG_IC_LIL,
+	ARC_REG_AUX_DCCM,
+	ARC_REG_IC_IVIL,
+	ARC_REG_IC_RAM_ADDR,
+	ARC_REG_IC_TAG,
+	ARC_REG_IC_DATA,
+	ARC_REG_DEBUGI,
+	ARC_REG_COUNT0,
+	ARC_REG_CONTROL0,
+	ARC_REG_LIMIT0,
+	ARC_REG_INT_VECTOR_BASE,
+	ARC_REG_AUX_IRQ_ACT,
+	ARC_REG_DC_IVDC,
+	ARC_REG_DC_CTRL,
+	ARC_REG_DC_LDL,
+	ARC_REG_DC_IVDL,
+	ARC_REG_DC_FLSH,
+	ARC_REG_DC_FLDL,
+	ARC_REG_DC_RAM_ADDR,
+	ARC_REG_DC_TAG,
+	ARC_REG_DC_DATA,
+	ARC_REG_COUNT1,
+	ARC_REG_CONTROL1,
+	ARC_REG_LIMIT1,
+	ARC_REG_AUX_RTC_CTRL,
+	ARC_REG_AUX_RTC_LOW,
+	ARC_REG_AUX_RTC_HIGH,
+	ARC_REG_IRQ_PRIORITY_PENDING,
+	ARC_REG_AUX_IRQ_HINT,
+	ARC_REG_IRQ_PRIORITY,
+	ARC_REG_AUX_ICCM,
+	/* I haven't found a way to probe for this register */
+	/*ARC_REG_AUX_CACHE_LIMIT,*/
+	/* There is no way to probe this register.
+	ARC_REG_DMP_PERIPHERAL,*/
+	ARC_REG_USTACK_TOP,
+	ARC_REG_USTACK_BASE,
+	ARC_REG_KSTACK_TOP,
+	ARC_REG_KSTACK_BASE,
+	ARC_REG_JLI_BASE,
+	ARC_REG_LDI_BASE,
+	ARC_REG_EI_BASE,
+	ARC_REG_ERET,
+	ARC_REG_ERBTA,
+	ARC_REG_ERSTATUS,
+	ARC_REG_ECR,
+	ARC_REG_EFA,
+	ARC_REG_MPU_EN,
+	ARC_REG_ICAUSE,
+	ARC_REG_IRQ_SELECT,
+	ARC_REG_IRQ_ENABLE,
+	ARC_REG_IRQ_TRIGGER,
+	ARC_REG_IRQ_STATUS,
+	/* XPU and XFLAGS registers are listed in ISA, however they are present
+	 * only in designes with extension and instructions and there is no way to
+	 * check for their existenct at runtime. OpenOCD will not probe for them.
+	 */
+	/* ARC_REG_XPU, */
+	ARC_REG_BTA,
+	ARC_REG_BTA_L1,
+	ARC_REG_BTA_L2,
+	ARC_REG_IRQ_PULSE_CANCEL,
+	ARC_REG_IRQ_PENDING,
+	ARC_REG_MPU_ECR,
+	/* Registers to describe MPU regions: RDB and RDP */
+	ARC_REG_MPU_RDB0,
+	ARC_REG_MPU_RDP0,
+	ARC_REG_MPU_RDB1,
+	ARC_REG_MPU_RDP1,
+	ARC_REG_MPU_RDB2,
+	ARC_REG_MPU_RDP2,
+	ARC_REG_MPU_RDB3,
+	ARC_REG_MPU_RDP3,
+	ARC_REG_MPU_RDB4,
+	ARC_REG_MPU_RDP4,
+	ARC_REG_MPU_RDB5,
+	ARC_REG_MPU_RDP5,
+	ARC_REG_MPU_RDB6,
+	ARC_REG_MPU_RDP6,
+	ARC_REG_MPU_RDB7,
+	ARC_REG_MPU_RDP7,
+	ARC_REG_MPU_RDB8,
+	ARC_REG_MPU_RDP8,
+	ARC_REG_MPU_RDB9,
+	ARC_REG_MPU_RDP9,
+	ARC_REG_MPU_RDB10,
+	ARC_REG_MPU_RDP10,
+	ARC_REG_MPU_RDB11,
+	ARC_REG_MPU_RDP11,
+	ARC_REG_MPU_RDB12,
+	ARC_REG_MPU_RDP12,
+	ARC_REG_MPU_RDB13,
+	ARC_REG_MPU_RDP13,
+	ARC_REG_MPU_RDB14,
+	ARC_REG_MPU_RDP14,
+	ARC_REG_MPU_RDB15,
+	ARC_REG_MPU_RDP15,
+	/* See note for XPU */
+	/*ARC_REG_XFLAGS,*/
+	ARC_REG_SMART_CONTROL,
+	ARC_REG_SMART_DATA,
+
+	ARC_REG_AFTER_AUX,
+
+	/* BCR - Build configuration registers */
+	ARC_REG_FIRST_BCR = ARC_REG_AFTER_AUX,
+	ARC_REG_BCR_VER = ARC_REG_AFTER_AUX,
+	ARC_REG_BTA_LINK_BUILD,
+	ARC_REG_VECBASE_AC_BUILD,
+	ARC_REG_MPU_BUILD,
+	ARC_REG_RF_BUILD,
+	ARC_REG_D_CACHE_BUILD,
+	ARC_REG_DCCM_BUILD,
+	ARC_REG_TIMER_BUILD,
+	ARC_REG_AP_BUILD,
+	ARC_REG_I_CACHE_BUILD,
+	ARC_REG_ICCM_BUILD,
+	ARC_REG_MULTIPLY_BUILD,
+	ARC_REG_SWAP_BUILD,
+	ARC_REG_NORM_BUILD,
+	ARC_REG_MINMAX_BUILD,
+	ARC_REG_BARREL_BUILD,
+	ARC_REG_ISA_CONFIG,
+	ARC_REG_STACK_REGION_BUILD,
+	ARC_REG_CPROT_BUILD,
+	ARC_REG_IRQ_BUILD,
+	ARC_REG_IFQUEUE_BUILD,
+	ARC_REG_SMART_BUILD,
+
+	ARC_REG_AFTER_BCR,
+
+	ARC_TOTAL_NUM_REGS = ARC_REG_AFTER_BCR,
+};
+
+struct bcr_set_t {
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+		};
+	} bcr_ver;
+
+	union {
+		uint32_t raw;
+		struct {
+			bool p : 1;
+		};
+	} bta_link_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t __raz   : 2;
+			uint8_t version : 8;
+			uint32_t addr   : 22;
+		};
+	} vecbase_ac_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			uint8_t regions : 8;
+		};
+	} mpu_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			bool p    : 1;
+			bool e    : 1;
+			bool r    : 1;
+			uint8_t b : 3;
+			uint8_t d : 2;
+		};
+	} rf_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version  : 8;
+			uint8_t assoc    : 4;
+			uint8_t capacity : 4;
+			uint8_t bsize    : 4;
+			uint8_t fl       : 2;
+		};
+	} d_cache_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			uint8_t size    : 4;
+		};
+	} dccm_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			bool t0         : 1;
+			bool t1         : 1;
+			bool rtc        : 1;
+			uint8_t __raz   : 5;
+			uint8_t p0      : 4;
+			uint8_t p1      : 4;
+		};
+	} timer_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			uint8_t type    : 4;
+		};
+	} ap_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			uint8_t assoc   : 4;
+			uint8_t capacity: 4;
+			uint8_t bsize   : 4;
+			uint8_t fl      : 2;
+		};
+	} i_cache_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version    : 8;
+			uint8_t iccm0_size : 4;
+			uint8_t iccm1_size : 4;
+		};
+	} iccm_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version32 : 8;
+			uint8_t type      : 2;
+			uint8_t cyc       : 2;
+			uint8_t __raz     : 4;
+			uint8_t version16 : 8;
+		};
+	} multiply_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+		};
+	} swap_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+		};
+	} norm_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+		};
+	} minmax_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			uint8_t b       : 2;
+		};
+	} barrel_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version  : 8;
+			uint8_t pc_size  : 4;
+			uint8_t lpc_size : 4;
+			uint8_t addr_size: 4;
+			bool b           : 1;
+			bool a           : 1;
+			uint8_t __raz    : 2;
+			uint8_t c        : 4;
+			uint8_t d        : 4;
+		};
+	} isa_config;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+		};
+	} stack_region_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+		};
+	} cprot_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			uint8_t irqs    : 4;
+			uint8_t exts    : 4;
+			uint8_t p       : 4;
+			bool f          : 1;
+		};
+	} irq_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			uint8_t bd      : 3;
+		};
+	} ifqueue_build;
+
+	union {
+		uint32_t raw;
+		struct {
+			uint8_t version : 8;
+			uint8_t __raz   : 2;
+			uint32_t stack_size : 22;
+		};
+	} smart_build;
+};
+
+
+/* ----- Exported functions ------------------------------------------------ */
+
+struct reg_cache *arc_regs_build_reg_cache(struct target *target);
+
+int arc_regs_read_core_reg(struct target *target, int num);
+int arc_regs_write_core_reg(struct target *target, int num);
+int arc_regs_read_registers(struct target *target, uint32_t *regs);
+int arc_regs_write_registers(struct target *target, uint32_t *regs);
+
+int arc_regs_get_gdb_reg_list(struct target *target, struct reg **reg_list[],
+	int *reg_list_size, enum target_register_class reg_class);
+
+int arc_regs_read_bcrs(struct target *target);
+int arc_regs_print_core_registers(struct target *target);
+int arc_regs_print_aux_registers(struct arc_jtag *jtag_info);
+
+#endif /* ARC_REGS_H */
diff --git a/src/target/arc_trgt.c b/src/target/arc_trgt.c
new file mode 100644
index 0000000..6e758e6
--- /dev/null
+++ b/src/target/arc_trgt.c
@@ -0,0 +1,40 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arc.h"
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_trgt_request_data(struct target *target, uint32_t size,
+	uint8_t *buffer)
+{
+	int retval = ERROR_OK;
+
+	LOG_DEBUG("Entering");
+
+	LOG_ERROR("arc_trgt_request_data NOT SUPPORTED IN THIS RELEASE.");
+
+	return retval;
+}
diff --git a/src/target/arc_trgt.h b/src/target/arc_trgt.h
new file mode 100644
index 0000000..db05dc5
--- /dev/null
+++ b/src/target/arc_trgt.h
@@ -0,0 +1,30 @@
+/***************************************************************************
+ *   Copyright (C) 2013-2014 Synopsys, Inc.                                *
+ *   Frank Dols <frank.dols@synopsys.com>                                  *
+ *   Anton Kolesov <anton.kolesov@synopsys.com>                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifndef ARC_TRGT_H
+#define ARC_TRGT_H
+
+/* ----- Exported functions ------------------------------------------------ */
+
+int arc_trgt_request_data(struct target *target, uint32_t size,
+	uint8_t *buffer);
+
+#endif /* ARC_TRGT_H */
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index b602b80..5ce4884 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -808,7 +808,11 @@ static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index_t,
 		LOG_DEBUG("watchpoint values and masking not supported");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
-
+	/* IO watchpoints are only supported on Intel Architecture (x86) */
+	if (wp->rw == WPT_IO) {
+		LOG_ERROR("IO watchpoints are not supported");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
 	retval = dpm_bpwp_setup(dpm, &dwp->bpwp, wp->address, wp->length);
 	if (retval != ERROR_OK)
 		return retval;
@@ -824,6 +828,9 @@ static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index_t,
 		case WPT_ACCESS:
 			control |= 3 << 3;
 			break;
+		case WPT_IO:
+			/* not supported, error checking was done above */
+			break;
 	}
 	dwp->bpwp.control = control;
 
diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index 5143afb..f428e20 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -37,7 +37,8 @@ static char *breakpoint_type_strings[] = {
 static char *watchpoint_rw_strings[] = {
 	"read",
 	"write",
-	"access"
+	"access",
+	"IO"
 };
 
 /* monotonic counter/id-number for breakpoints and watch points */
@@ -405,7 +406,7 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 				|| watchpoint->mask != mask
 				|| watchpoint->rw != rw) {
 				LOG_ERROR("address 0x%8.8" PRIx32
-					"already has watchpoint %d",
+					" already has watchpoint %d",
 					address, watchpoint->unique_id);
 				return ERROR_FAIL;
 			}
diff --git a/src/target/breakpoints.h b/src/target/breakpoints.h
index 0246acd..8b99be2 100644
--- a/src/target/breakpoints.h
+++ b/src/target/breakpoints.h
@@ -29,7 +29,7 @@ enum breakpoint_type {
 };
 
 enum watchpoint_rw {
-	WPT_READ = 0, WPT_WRITE = 1, WPT_ACCESS = 2
+	WPT_READ = 0, WPT_WRITE = 1, WPT_ACCESS = 2, WPT_IO = 3
 };
 
 struct breakpoint {
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index d95c25e..0fb53b8 100644
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -1291,6 +1291,12 @@ int cortex_m_set_watchpoint(struct target *target, struct watchpoint *watchpoint
 	uint32_t mask, temp;
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 
+	/* IO watchpoints are only supported on Intel Architecture (x86) */
+	if (watchpoint->rw == WPT_IO) {
+		LOG_ERROR("IO watchpoints are not supported");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
 	/* watchpoint params were validated earlier */
 	mask = 0;
 	temp = watchpoint->length;
@@ -1336,6 +1342,9 @@ int cortex_m_set_watchpoint(struct target *target, struct watchpoint *watchpoint
 		case WPT_ACCESS:
 			comparator->function = 7;
 			break;
+		case WPT_IO:
+			/* not supported, error checking was done above */
+			break;
 	}
 	target_write_u32(target, comparator->dwt_comparator_address + 8,
 		comparator->function);
diff --git a/src/target/lakemont.c b/src/target/lakemont.c
new file mode 100644
index 0000000..e49c664
--- /dev/null
+++ b/src/target/lakemont.c
@@ -0,0 +1,1202 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * Adrian Burns (adrian.burns@intel.com)
+ * Thomas Faust (thomas.faust@intel.com)
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Julien Carreno (julien.carreno@intel.com)
+ * Jeffrey Maxwell (jeffrey.r.maxwell@intel.com)
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * This implements the probemode operations for Lakemont 1 (LMT1).
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/log.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "lakemont.h"
+#include "register.h"
+#include "breakpoints.h"
+#include "x86_32_common.h"
+
+static int irscan(struct target *t, uint8_t *out,
+			uint8_t *in, uint8_t ir_len);
+static int drscan(struct target *t, uint8_t *out, uint8_t *in, uint8_t len);
+static int save_context(struct target *target);
+static int restore_context(struct target *target);
+static uint32_t get_tapstatus(struct target *t);
+static int enter_probemode(struct target *t);
+static int exit_probemode(struct target *t);
+static int halt_prep(struct target *t);
+static int do_halt(struct target *t);
+static int do_resume(struct target *t);
+static int read_all_core_hw_regs(struct target *t);
+static int write_all_core_hw_regs(struct target *t);
+static int read_hw_reg(struct target *t,
+			int reg, uint32_t *regval, uint8_t cache);
+static int write_hw_reg(struct target *t,
+			int reg, uint32_t regval, uint8_t cache);
+static struct reg_cache *lakemont_build_reg_cache
+			(struct target *target);
+static int submit_reg_pir(struct target *t, int num);
+static int submit_instruction_pir(struct target *t, int num);
+static int submit_pir(struct target *t, uint64_t op);
+static int lakemont_get_core_reg(struct reg *reg);
+static int lakemont_set_core_reg(struct reg *reg, uint8_t *buf);
+
+static struct scan_blk scan;
+
+/* registers and opcodes for register access, pm_idx is used to identify the
+ * registers that are modified for lakemont probemode specific operations
+ */
+static const struct {
+	uint8_t id;
+	const char *name;
+	uint64_t op;
+	uint8_t pm_idx;
+	unsigned bits;
+	enum reg_type type;
+	const char *group;
+	const char *feature;
+} regs[] = {
+	/* general purpose registers */
+	{ EAX, "eax", 0x000000D01D660000, 0, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ ECX, "ecx", 0x000000501D660000, 1, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ EDX, "edx", 0x000000901D660000, 2, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ EBX, "ebx", 0x000000101D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ ESP, "esp", 0x000000E01D660000, NOT_PMREG, 32, REG_TYPE_DATA_PTR, "general", "org.gnu.gdb.i386.core" },
+	{ EBP, "ebp", 0x000000601D660000, NOT_PMREG, 32, REG_TYPE_DATA_PTR, "general", "org.gnu.gdb.i386.core" },
+	{ ESI, "esi", 0x000000A01D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ EDI, "edi", 0x000000201D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+
+	/* instruction pointer & flags */
+	{ EIP, "eip", 0x000000C01D660000, 3, 32, REG_TYPE_CODE_PTR, "general", "org.gnu.gdb.i386.core" },
+	{ EFLAGS, "eflags", 0x000000401D660000, 4, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+
+	/* segment registers */
+	{ CS, "cs", 0x000000281D660000, 5, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ SS, "ss", 0x000000C81D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ DS, "ds", 0x000000481D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ ES, "es", 0x000000A81D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ FS, "fs", 0x000000881D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ GS, "gs", 0x000000081D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+
+	/* floating point unit registers - not accessible via JTAG - here to satisfy GDB */
+	{ ST0, "st0", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_i387_EXT, "general", "org.gnu.gdb.i386.core" },
+	{ ST1, "st1", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_i387_EXT, "general", "org.gnu.gdb.i386.core" },
+	{ ST2, "st2", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_i387_EXT, "general", "org.gnu.gdb.i386.core" },
+	{ ST3, "st3", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_i387_EXT, "general", "org.gnu.gdb.i386.core" },
+	{ ST4, "st4", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_i387_EXT, "general", "org.gnu.gdb.i386.core" },
+	{ ST5, "st5", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_i387_EXT, "general", "org.gnu.gdb.i386.core" },
+	{ ST6, "st6", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_i387_EXT, "general", "org.gnu.gdb.i386.core" },
+	{ ST7, "st7", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_i387_EXT, "general", "org.gnu.gdb.i386.core" },
+
+	{ FCTRL, "fctrl", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ FSTAT, "fstat", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ FTAG,  "ftag",  0x0, NOT_AVAIL_REG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ FISEG, "fiseg", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ FIOFF, "fioff", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ FOSEG, "foseg", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ FOOFF, "fooff", 0x0, NOT_AVAIL_REG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+	{ FOP,   "fop",   0x0, NOT_AVAIL_REG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.core" },
+
+	/* control registers */
+	{ CR0, "cr0", 0x000000001D660000, 6, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ CR2, "cr2", 0x000000BC1D660000, 7, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ CR3, "cr3", 0x000000801D660000, 8, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ CR4, "cr4", 0x0000002C1D660000, 9, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+
+	/* debug registers */
+	{ DR0, "dr0", 0x0000007C1D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ DR1, "dr1", 0x000000FC1D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ DR2, "dr2", 0x000000021D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ DR3, "dr3", 0x000000821D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ DR6, "dr6", 0x000000301D660000, 10, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ DR7, "dr7", 0x000000B01D660000, 11, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+
+	/* descriptor tables */
+	{ IDTB, "idtbase", 0x000000581D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ IDTL, "idtlimit", 0x000000D81D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ IDTAR, "idtar", 0x000000981D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ GDTB, "gdtbase", 0x000000B81D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ GDTL, "gdtlimit", 0x000000781D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ GDTAR, "gdtar", 0x000000381D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ TR, "tr", 0x000000701D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ LDTR, "ldtr", 0x000000F01D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ LDTB, "ldbase", 0x000000041D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ LDTL, "ldlimit", 0x000000841D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ LDTAR, "ldtar", 0x000000F81D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+
+	/* segment registers */
+	{ CSB, "csbase", 0x000000F41D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ CSL, "cslimit", 0x0000000C1D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ CSAR, "csar", 0x000000741D660000, 12, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ DSB, "dsbase", 0x000000941D660000, 13, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ DSL, "dslimit", 0x000000541D660000, 14, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ DSAR, "dsar", 0x000000141D660000, 15, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ ESB, "esbase", 0x0000004C1D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ ESL, "eslimit", 0x000000CC1D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ ESAR, "esar", 0x0000008C1D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ FSB, "fsbase", 0x000000641D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ FSL, "fslimit", 0x000000E41D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ FSAR, "fsar", 0x000000A41D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ GSB, "gsbase", 0x000000C41D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ GSL, "gslimit", 0x000000241D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ GSAR, "gsar", 0x000000441D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ SSB, "ssbase", 0x000000341D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ SSL, "sslimit", 0x000000B41D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ SSAR, "ssar", 0x000000D41D660000, 16, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ TSSB, "tssbase", 0x000000E81D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ TSSL, "tsslimit", 0x000000181D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	{ TSSAR, "tssar", 0x000000681D660000, NOT_PMREG, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+	/* probemode control register */
+	{ PMCR, "pmcr", 0x000000421D660000, 17, 32, REG_TYPE_INT32, "general", "org.gnu.gdb.i386.sys" },
+};
+
+static const struct {
+	uint8_t id;
+	const char *name;
+	uint64_t op;
+} instructions[] = {
+	/* memory read/write */
+	{ MEMRDB32, "MEMRDB32", 0x0909090909090851 },
+	{ MEMRDB16, "MEMRDB16", 0x09090909090851E6 },
+	{ MEMRDH32, "MEMRDH32", 0x090909090908D166 },
+	{ MEMRDH16, "MEMRDH16", 0x090909090908D1E6 },
+	{ MEMRDW32, "MEMRDW32", 0x09090909090908D1 },
+	{ MEMRDW16, "MEMRDW16", 0x0909090908D1E666 },
+	{ MEMWRB32, "MEMWRB32", 0x0909090909090811 },
+	{ MEMWRB16, "MEMWRB16", 0x09090909090811E6 },
+	{ MEMWRH32, "MEMWRH32", 0x0909090909089166 },
+	{ MEMWRH16, "MEMWRH16", 0x09090909090891E6 },
+	{ MEMWRW32, "MEMWRW32", 0x0909090909090891 },
+	{ MEMWRW16, "MEMWRW16", 0x090909090891E666 },
+	/* IO read/write */
+	{ IORDB32, "IORDB32", 0x0909090909090937 },
+	{ IORDB16, "IORDB16", 0x09090909090937E6 },
+	{ IORDH32, "IORDH32", 0x090909090909B766 },
+	{ IORDH16, "IORDH16", 0x090909090909B7E6 },
+	{ IORDW32, "IORDW32", 0x09090909090909B7 },
+	{ IORDW16, "IORDW16", 0x0909090909B7E666 },
+	{ IOWRB32, "IOWRB32", 0x0909090909090977 },
+	{ IOWRB16, "IOWRB16", 0x09090909090977E6 },
+	{ IOWRH32, "IOWRH32", 0x090909090909F766 },
+	{ IOWRH16, "IOWRH16", 0x090909090909F7E6 },
+	{ IOWRW32, "IOWRW32", 0x09090909090909F7 },
+	{ IOWRW16, "IOWRW16", 0x0909090909F7E666 },
+	/* lakemont1 core shadow ram access opcodes */
+	{ SRAMACCESS, "SRAMACCESS", 0x0000000E9D660000 },
+	{ SRAM2PDR, "SRAM2PDR", 0x4CF0000000000000 },
+	{ PDR2SRAM, "PDR2SRAM", 0x0CF0000000000000 },
+	{ WBINVD, "WBINVD", 0x09090909090990F0 },
+	/* Model Specific Registers */
+	{ RDMSR, "RDMSR", 0x0909090909094CF0 },
+	{ WRMSR, "WRMSR", 0x0909090909090CF0 },
+	{ CPUID, "CPUID", 0x09090909090945F0 },
+};
+
+bool check_not_halted(const struct target *t)
+{
+	bool halted = t->state == TARGET_HALTED;
+	if (!halted)
+		LOG_ERROR("target running, halt it first");
+	return !halted;
+}
+
+static int irscan(struct target *t, uint8_t *out,
+			uint8_t *in, uint8_t ir_len)
+{
+	int retval = ERROR_OK;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	if (NULL == t->tap) {
+		retval = ERROR_FAIL;
+		LOG_ERROR("%s invalid target tap", __func__);
+		return retval;
+	}
+	if (ir_len != t->tap->ir_length) {
+		retval = ERROR_FAIL;
+		if (t->tap->enabled)
+			LOG_ERROR("%s tap enabled but tap irlen=%d",
+					__func__, t->tap->ir_length);
+		else
+			LOG_ERROR("%s tap not enabled and irlen=%d",
+					__func__, t->tap->ir_length);
+		return retval;
+	}
+	struct scan_field *fields = &scan.field;
+	fields->num_bits = ir_len;
+	fields->out_value = out;
+	fields->in_value = in;
+	jtag_add_ir_scan(x86_32->curr_tap, fields, TAP_IDLE);
+	if (x86_32->flush) {
+		retval = jtag_execute_queue();
+		if (retval != ERROR_OK)
+			LOG_ERROR("%s failed to execute queue", __func__);
+	}
+	return retval;
+}
+
+static int drscan(struct target *t, uint8_t *out, uint8_t *in, uint8_t len)
+{
+	int retval = ERROR_OK;
+	uint64_t data = 0;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	if (NULL == t->tap) {
+		retval = ERROR_FAIL;
+		LOG_ERROR("%s invalid target tap", __func__);
+		return retval;
+	}
+	if (len > MAX_SCAN_SIZE || 0 == len) {
+		retval = ERROR_FAIL;
+		LOG_ERROR("%s data len is %d bits, max is %d bits",
+				__func__, len, MAX_SCAN_SIZE);
+		return retval;
+	}
+	struct scan_field *fields = &scan.field;
+	fields->out_value = out;
+	fields->in_value = in;
+	fields->num_bits = len;
+	jtag_add_dr_scan(x86_32->curr_tap, 1, fields, TAP_IDLE);
+	if (x86_32->flush) {
+		retval = jtag_execute_queue();
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s drscan failed to execute queue", __func__);
+			return retval;
+		}
+	}
+	if (in != NULL) {
+		if (len >= 8) {
+			for (int n = (len / 8) - 1 ; n >= 0; n--)
+				data = (data << 8) + *(in+n);
+		} else
+			LOG_DEBUG("dr in 0x%02" PRIx8, *in);
+	} else {
+		LOG_ERROR("%s no drscan data", __func__);
+		retval = ERROR_FAIL;
+	}
+	return retval;
+}
+
+static int save_context(struct target *t)
+{
+	int err;
+	/* read core registers from lakemont sram */
+	err = read_all_core_hw_regs(t);
+	if (err != ERROR_OK) {
+		LOG_ERROR("%s error reading regs", __func__);
+		return err;
+	}
+	return ERROR_OK;
+}
+
+static int restore_context(struct target *t)
+{
+	int err = ERROR_OK;
+	uint32_t i;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	/* write core regs into the core PM SRAM from the reg_cache */
+	err = write_all_core_hw_regs(t);
+	if (err != ERROR_OK) {
+		LOG_ERROR("%s error writing regs", __func__);
+		return err;
+	}
+
+	for (i = 0; i < (x86_32->cache->num_regs); i++) {
+		x86_32->cache->reg_list[i].dirty = 0;
+		x86_32->cache->reg_list[i].valid = 0;
+	}
+	return err;
+}
+
+/*
+ * we keep reg_cache in sync with hardware at halt/resume time, we avoid
+ * writing to real hardware here bacause pm_regs reflects the hardware
+ * while we are halted then reg_cache syncs with hw on resume
+ * TODO - in order for "reg eip force" to work it assume get/set reads
+ * and writes from hardware, may be other reasons also because generally
+ * other openocd targets read/write from hardware in get/set - watch this!
+ */
+static int lakemont_get_core_reg(struct reg *reg)
+{
+	int retval = ERROR_OK;
+	struct lakemont_core_reg *lakemont_reg = reg->arch_info;
+	struct target *t = lakemont_reg->target;
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	LOG_DEBUG("reg=%s, value=0x%08" PRIx32, reg->name,
+			buf_get_u32(reg->value, 0, 32));
+	return retval;
+}
+
+static int lakemont_set_core_reg(struct reg *reg, uint8_t *buf)
+{
+	struct lakemont_core_reg *lakemont_reg = reg->arch_info;
+	struct target *t = lakemont_reg->target;
+	uint32_t value = buf_get_u32(buf, 0, 32);
+	LOG_DEBUG("reg=%s, newval=0x%08" PRIx32, reg->name, value);
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	buf_set_u32(reg->value, 0, 32, value);
+	reg->dirty = 1;
+	reg->valid = 1;
+	return ERROR_OK;
+}
+
+static const struct reg_arch_type lakemont_reg_type = {
+	/* these get called if reg_cache doesnt have a "valid" value
+	 * of an individual reg eg "reg eip" but not for "reg" block
+	 */
+	.get = lakemont_get_core_reg,
+	.set = lakemont_set_core_reg,
+};
+
+struct reg_cache *lakemont_build_reg_cache(struct target *t)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	int num_regs = ARRAY_SIZE(regs);
+	struct reg_cache **cache_p = register_get_last_cache_p(&t->reg_cache);
+	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
+	struct reg *reg_list = malloc(sizeof(struct reg) * num_regs);
+	struct lakemont_core_reg *arch_info = malloc(sizeof(struct lakemont_core_reg) * num_regs);
+	struct reg_feature *feature;
+	int i;
+
+	if (cache == NULL || reg_list == NULL || arch_info == NULL) {
+		free(cache);
+		free(reg_list);
+		free(arch_info);
+		LOG_ERROR("%s out of memory", __func__);
+		return NULL;
+	}
+
+	/* Build the process context cache */
+	cache->name = "lakemont registers";
+	cache->next = NULL;
+	cache->reg_list = reg_list;
+	cache->num_regs = num_regs;
+	(*cache_p) = cache;
+	x86_32->cache = cache;
+
+	for (i = 0; i < num_regs; i++) {
+		arch_info[i].target = t;
+		arch_info[i].x86_32_common = x86_32;
+		arch_info[i].op = regs[i].op;
+		arch_info[i].pm_idx = regs[i].pm_idx;
+		reg_list[i].name = regs[i].name;
+		reg_list[i].size = 32;
+		reg_list[i].value = calloc(1, 4);
+		reg_list[i].dirty = 0;
+		reg_list[i].valid = 0;
+		reg_list[i].type = &lakemont_reg_type;
+		reg_list[i].arch_info = &arch_info[i];
+
+		reg_list[i].group = regs[i].group;
+		reg_list[i].number = i;
+		reg_list[i].exist = true;
+		reg_list[i].caller_save = true;	/* gdb defaults to true */
+
+		feature = calloc(1, sizeof(struct reg_feature));
+		if (feature) {
+			feature->name = regs[i].feature;
+			reg_list[i].feature = feature;
+		} else
+			LOG_ERROR("%s unable to allocate feature list", __func__);
+
+		reg_list[i].reg_data_type = calloc(1, sizeof(struct reg_data_type));
+		if (reg_list[i].reg_data_type)
+			reg_list[i].reg_data_type->type = regs[i].type;
+		else
+			LOG_ERROR("%s unable to allocate reg type list", __func__);
+	}
+	return cache;
+}
+
+static uint32_t get_tapstatus(struct target *t)
+{
+	scan.out[0] = TAPSTATUS;
+	if (irscan(t, scan.out, NULL, LMT_IRLEN) != ERROR_OK)
+		return 0;
+	if (drscan(t, NULL, scan.out, TS_SIZE) != ERROR_OK)
+		return 0;
+	return buf_get_u32(scan.out, 0, 32);
+}
+
+static int enter_probemode(struct target *t)
+{
+	uint32_t tapstatus = 0;
+	tapstatus = get_tapstatus(t);
+	LOG_DEBUG("TS before PM enter = 0x%08" PRIx32, tapstatus);
+	if (tapstatus & TS_PM_BIT) {
+		LOG_DEBUG("core already in probemode");
+		return ERROR_OK;
+	}
+	scan.out[0] = PROBEMODE;
+	if (irscan(t, scan.out, NULL, LMT_IRLEN) != ERROR_OK)
+		return ERROR_FAIL;
+	scan.out[0] = 1;
+	if (drscan(t, scan.out, scan.in, 1) != ERROR_OK)
+		return ERROR_FAIL;
+
+	/* HACK */
+	int cnt = 5;
+	do {
+		tapstatus = get_tapstatus(t);
+		if (tapstatus & TS_PM_BIT)
+			return ERROR_OK;
+
+		LOG_DEBUG("%s Waiting for PM, TS = 0x%08" PRIx32,
+				__func__, tapstatus);
+		usleep(100000);
+		cnt--;
+	} while (cnt);
+	return ERROR_FAIL;
+	/* TODO: find a nicer way to wait until PM_BIT changes*/
+}
+
+static int exit_probemode(struct target *t)
+{
+	uint32_t tapstatus = get_tapstatus(t);
+	LOG_DEBUG("TS before PM exit = 0x%08" PRIx32, tapstatus);
+
+	if (!(tapstatus & TS_PM_BIT)) {
+		LOG_USER("core not in PM");
+		return ERROR_OK;
+	}
+	scan.out[0] = PROBEMODE;
+	if (irscan(t, scan.out, NULL, LMT_IRLEN) != ERROR_OK)
+		return ERROR_FAIL;
+	scan.out[0] = 0;
+	if (drscan(t, scan.out, scan.in, 1) != ERROR_OK)
+		return ERROR_FAIL;
+
+	return ERROR_OK;
+}
+
+/* do whats needed to properly enter probemode for debug on lakemont */
+static int halt_prep(struct target *t)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	if (write_hw_reg(t, DSB, PM_DSB, 0) != ERROR_OK)
+		return ERROR_FAIL;
+	LOG_DEBUG("write %s 0x%08" PRIx32, regs[DSB].name, PM_DSB);
+	if (write_hw_reg(t, DSL, PM_DSL, 0) != ERROR_OK)
+		return ERROR_FAIL;
+	LOG_DEBUG("write %s 0x%08" PRIx32, regs[DSL].name, PM_DSL);
+	if (write_hw_reg(t, DSAR, PM_DSAR, 0) != ERROR_OK)
+		return ERROR_FAIL;
+	LOG_DEBUG("write DSAR 0x%08" PRIx32, PM_DSAR);
+	if (write_hw_reg(t, CSB, PM_DSB, 0) != ERROR_OK)
+		return ERROR_FAIL;
+	LOG_DEBUG("write %s 0x%08" PRIx32, regs[CSB].name, PM_DSB);
+	if (write_hw_reg(t, CSL, PM_DSL, 0) != ERROR_OK)
+		return ERROR_FAIL;
+	LOG_DEBUG("write %s 0x%08" PRIx32, regs[CSL].name, PM_DSL);
+
+	if (write_hw_reg(t, DR7, PM_DR7, 0) != ERROR_OK)
+		return ERROR_FAIL;
+	LOG_DEBUG("write DR7 0x%08" PRIx32, PM_DR7);
+
+	uint32_t eflags = buf_get_u32(x86_32->cache->reg_list[EFLAGS].value, 0, 32);
+	uint32_t csar = buf_get_u32(x86_32->cache->reg_list[CSAR].value, 0, 32);
+	uint32_t ssar = buf_get_u32(x86_32->cache->reg_list[SSAR].value, 0, 32);
+	uint32_t cr0 = buf_get_u32(x86_32->cache->reg_list[CR0].value, 0, 32);
+
+	/* clear VM86 and IF bits if they are set */
+	LOG_DEBUG("EFLAGS = 0x%08" PRIx32 ", VM86 = %d, IF = %d", eflags,
+			eflags & EFLAGS_VM86 ? 1 : 0,
+			eflags & EFLAGS_IF ? 1 : 0);
+	if ((eflags & EFLAGS_VM86) || (eflags & EFLAGS_IF)) {
+		x86_32->pm_regs[I(EFLAGS)] = eflags & ~(EFLAGS_VM86 | EFLAGS_IF);
+		if (write_hw_reg(t, EFLAGS, x86_32->pm_regs[I(EFLAGS)], 0) != ERROR_OK)
+			return ERROR_FAIL;
+		LOG_DEBUG("EFLAGS now = 0x%08" PRIx32 ", VM86 = %d, IF = %d",
+				x86_32->pm_regs[I(EFLAGS)],
+				x86_32->pm_regs[I(EFLAGS)] & EFLAGS_VM86 ? 1 : 0,
+				x86_32->pm_regs[I(EFLAGS)] & EFLAGS_IF ? 1 : 0);
+	}
+
+	/* set CPL to 0 for memory access */
+	if (csar & CSAR_DPL) {
+		x86_32->pm_regs[I(CSAR)] = csar & ~CSAR_DPL;
+		if (write_hw_reg(t, CSAR, x86_32->pm_regs[I(CSAR)], 0) != ERROR_OK)
+			return ERROR_FAIL;
+		LOG_DEBUG("write CSAR_CPL to 0 0x%08" PRIx32, x86_32->pm_regs[I(CSAR)]);
+	}
+	if (ssar & SSAR_DPL) {
+		x86_32->pm_regs[I(SSAR)] = ssar & ~SSAR_DPL;
+		if (write_hw_reg(t, SSAR, x86_32->pm_regs[I(SSAR)], 0) != ERROR_OK)
+			return ERROR_FAIL;
+		LOG_DEBUG("write SSAR_CPL to 0 0x%08" PRIx32, x86_32->pm_regs[I(SSAR)]);
+	}
+
+	/* if cache's are enabled, disable and flush, depending on the LMT core version */
+	/* TODO: we never disable and flush for LMT3.5 and always do for LMT1, but to
+	 * be clean, on LMT3.5 and later we should check bit 20 of TAPSTATUS
+	 * (1 == don't flush the cache) and decide what action to take (see LDO 3.7.1.5).
+	 * We can update the code once we know if we ever need to support LMT2/3 or a
+	 * new LMT architecture pops up.
+	 */
+	if (!(x86_32->core_type == LMT3_5) && !(cr0 & CR0_CD)) {
+		LOG_DEBUG("caching enabled CR0 = 0x%08" PRIx32, cr0);
+		if (cr0 & CR0_PG) {
+			x86_32->pm_regs[I(CR0)] = cr0 & ~CR0_PG;
+			if (write_hw_reg(t, CR0, x86_32->pm_regs[I(CR0)], 0) != ERROR_OK)
+				return ERROR_FAIL;
+			LOG_DEBUG("cleared paging CR0_PG = 0x%08" PRIx32, x86_32->pm_regs[I(CR0)]);
+			/* submit wbinvd to flush cache */
+			if (submit_reg_pir(t, WBINVD) != ERROR_OK)
+				return ERROR_FAIL;
+			x86_32->pm_regs[I(CR0)] =
+				x86_32->pm_regs[I(CR0)] | (CR0_CD | CR0_NW | CR0_PG);
+			if (write_hw_reg(t, CR0, x86_32->pm_regs[I(CR0)], 0) != ERROR_OK)
+				return ERROR_FAIL;
+			LOG_DEBUG("set CD, NW and PG, CR0 = 0x%08" PRIx32, x86_32->pm_regs[I(CR0)]);
+		}
+	}
+	return ERROR_OK;
+}
+
+static int do_halt(struct target *t)
+{
+	/* needs proper handling later if doing a halt errors out */
+	t->state = TARGET_DEBUG_RUNNING;
+	if (enter_probemode(t) != ERROR_OK)
+		return ERROR_FAIL;
+
+	return lakemont_update_after_probemode_entry(t);
+}
+
+/* we need to expose the update to be able to complete the reset at SoC level */
+int lakemont_update_after_probemode_entry(struct target *t)
+{
+	if (save_context(t) != ERROR_OK)
+		return ERROR_FAIL;
+	if (halt_prep(t) != ERROR_OK)
+		return ERROR_FAIL;
+	t->state = TARGET_HALTED;
+
+	return target_call_event_callbacks(t, TARGET_EVENT_HALTED);
+}
+
+static int do_resume(struct target *t)
+{
+	/* needs proper handling later */
+	t->state = TARGET_DEBUG_RUNNING;
+	if (restore_context(t) != ERROR_OK)
+		return ERROR_FAIL;
+	if (exit_probemode(t) != ERROR_OK)
+		return ERROR_FAIL;
+	t->state = TARGET_RUNNING;
+
+	t->debug_reason = DBG_REASON_NOTHALTED;
+	LOG_USER("target running");
+
+	return target_call_event_callbacks(t, TARGET_EVENT_RESUMED);
+}
+
+static int read_all_core_hw_regs(struct target *t)
+{
+	int err;
+	uint32_t regval;
+	unsigned i;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	for (i = 0; i < (x86_32->cache->num_regs); i++) {
+		if (NOT_AVAIL_REG == regs[i].pm_idx)
+			continue;
+		err = read_hw_reg(t, regs[i].id, &regval, 1);
+		if (err != ERROR_OK) {
+			LOG_ERROR("%s error saving reg %s",
+					__func__, x86_32->cache->reg_list[i].name);
+			return err;
+		}
+	}
+	LOG_DEBUG("read_all_core_hw_regs read %u registers ok", i);
+	return ERROR_OK;
+}
+
+static int write_all_core_hw_regs(struct target *t)
+{
+	int err;
+	unsigned i;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	for (i = 0; i < (x86_32->cache->num_regs); i++) {
+		if (NOT_AVAIL_REG == regs[i].pm_idx)
+			continue;
+		err = write_hw_reg(t, i, 0, 1);
+		if (err != ERROR_OK) {
+			LOG_ERROR("%s error restoring reg %s",
+					__func__, x86_32->cache->reg_list[i].name);
+			return err;
+		}
+	}
+	LOG_DEBUG("write_all_core_hw_regs wrote %u registers ok", i);
+	return ERROR_OK;
+}
+
+/* read reg from lakemont core shadow ram, update reg cache if needed */
+static int read_hw_reg(struct target *t, int reg, uint32_t *regval, uint8_t cache)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	struct lakemont_core_reg *arch_info;
+	arch_info = x86_32->cache->reg_list[reg].arch_info;
+	x86_32->flush = 0; /* dont flush scans till we have a batch */
+	if (submit_reg_pir(t, reg) != ERROR_OK)
+		return ERROR_FAIL;
+	if (submit_instruction_pir(t, SRAMACCESS) != ERROR_OK)
+		return ERROR_FAIL;
+	if (submit_instruction_pir(t, SRAM2PDR) != ERROR_OK)
+		return ERROR_FAIL;
+	x86_32->flush = 1;
+	scan.out[0] = RDWRPDR;
+	if (irscan(t, scan.out, NULL, LMT_IRLEN) != ERROR_OK)
+		return ERROR_FAIL;
+	if (drscan(t, NULL, scan.out, PDR_SIZE) != ERROR_OK)
+		return ERROR_FAIL;
+
+	jtag_add_sleep(DELAY_SUBMITPIR);
+	*regval = buf_get_u32(scan.out, 0, 32);
+	if (cache) {
+		buf_set_u32(x86_32->cache->reg_list[reg].value, 0, 32, *regval);
+		x86_32->cache->reg_list[reg].valid = 1;
+		x86_32->cache->reg_list[reg].dirty = 0;
+	}
+	LOG_DEBUG("reg=%s, op=0x%016" PRIx64 ", val=0x%08" PRIx32,
+			x86_32->cache->reg_list[reg].name,
+			arch_info->op,
+			*regval);
+	return ERROR_OK;
+}
+
+/* write lakemont core shadow ram reg, update reg cache if needed */
+static int write_hw_reg(struct target *t, int reg, uint32_t regval, uint8_t cache)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	struct lakemont_core_reg *arch_info;
+	arch_info = x86_32->cache->reg_list[reg].arch_info;
+
+	uint8_t reg_buf[4];
+	if (cache)
+		regval = buf_get_u32(x86_32->cache->reg_list[reg].value, 0, 32);
+	buf_set_u32(reg_buf, 0, 32, regval);
+	LOG_DEBUG("reg=%s, op=0x%016" PRIx64 ", val=0x%08" PRIx32 " cache=0x%08" PRIx8,
+			x86_32->cache->reg_list[reg].name, arch_info->op, regval, cache);
+
+	x86_32->flush = 0; /* dont flush scans till we have a batch */
+	if (submit_reg_pir(t, reg) != ERROR_OK)
+		return ERROR_FAIL;
+	if (submit_instruction_pir(t, SRAMACCESS) != ERROR_OK)
+		return ERROR_FAIL;
+	scan.out[0] = RDWRPDR;
+	if (irscan(t, scan.out, NULL, LMT_IRLEN) != ERROR_OK)
+		return ERROR_FAIL;
+	if (drscan(t, reg_buf, scan.out, PDR_SIZE) != ERROR_OK)
+		return ERROR_FAIL;
+	x86_32->flush = 1;
+	if (submit_instruction_pir(t, PDR2SRAM) != ERROR_OK)
+		return ERROR_FAIL;
+
+	/* we are writing from the cache so ensure we reset flags */
+	if (cache) {
+		x86_32->cache->reg_list[reg].dirty = 0;
+		x86_32->cache->reg_list[reg].valid = 0;
+	}
+	return ERROR_OK;
+}
+
+static bool is_paging_enabled(struct target *t)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	if (x86_32->pm_regs[I(CR0)] & CR0_PG)
+		return true;
+	else
+		return false;
+}
+
+static uint8_t get_num_user_regs(struct target *t)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	return x86_32->cache->num_regs;
+}
+/* value of the CR0.PG (paging enabled) bit influences memory reads/writes */
+static int disable_paging(struct target *t)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	x86_32->pm_regs[I(CR0)] = x86_32->pm_regs[I(CR0)] & ~CR0_PG;
+	int err = x86_32->write_hw_reg(t, CR0, x86_32->pm_regs[I(CR0)], 0);
+	if (err != ERROR_OK) {
+		LOG_ERROR("%s error disabling paging", __func__);
+		return err;
+	}
+	return err;
+}
+
+static int enable_paging(struct target *t)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	x86_32->pm_regs[I(CR0)] = (x86_32->pm_regs[I(CR0)] | CR0_PG);
+	int err = x86_32->write_hw_reg(t, CR0, x86_32->pm_regs[I(CR0)], 0);
+	if (err != ERROR_OK) {
+		LOG_ERROR("%s error enabling paging", __func__);
+		return err;
+	}
+	return err;
+}
+
+static bool sw_bpts_supported(struct target *t)
+{
+	uint32_t tapstatus = get_tapstatus(t);
+	if (tapstatus & TS_SBP_BIT)
+		return true;
+	else
+		return false;
+}
+
+static bool io_bpts_supported(struct target *t)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	if (x86_32->core_type == LMT3_5)
+		return true;
+	else
+		return false;
+}
+
+static int transaction_status(struct target *t)
+{
+	uint32_t tapstatus = 0;
+
+	/* HACK */
+	int cnt = 5;
+	do {
+		tapstatus = get_tapstatus(t);
+		if (!((TS_EN_PM_BIT | TS_PRDY_BIT) & tapstatus))
+			return ERROR_OK;
+
+		LOG_DEBUG("%s Waiting for PRDY & PM, TS = 0x%08" PRIx32,
+						 __func__, tapstatus);
+		usleep(100000);
+		cnt--;
+	} while (cnt);
+
+	return ERROR_FAIL;
+	/* TODO: find a nicer way to wait until PM_BIT & PRDY_BIT changes*/
+
+}
+
+static int submit_instruction(struct target *t, int num)
+{
+	int err = submit_instruction_pir(t, num);
+	if (err != ERROR_OK) {
+		LOG_ERROR("%s error submitting pir", __func__);
+		return err;
+	}
+	return err;
+}
+
+static int submit_reg_pir(struct target *t, int num)
+{
+	LOG_DEBUG("reg %s op=0x%016" PRIx64, regs[num].name, regs[num].op);
+	int err = submit_pir(t, regs[num].op);
+	if (err != ERROR_OK) {
+		LOG_ERROR("%s error submitting pir", __func__);
+		return err;
+	}
+	return err;
+}
+
+static int submit_instruction_pir(struct target *t, int num)
+{
+	LOG_DEBUG("%s op=0x%016" PRIx64, instructions[num].name,
+			instructions[num].op);
+
+	/*
+	 * TODO: switch off the CR0.PG bit
+	 * is not disabled by default here in order to make reads faster
+	 * but should be done before submitting an instruction
+	 * maybe recommended to do it in halt_prep()
+	 */
+	if (is_paging_enabled(t))
+		LOG_DEBUG("%s CR0.PG not disable: possible instruction fault", __func__);
+
+	int err = submit_pir(t, instructions[num].op);
+	if (err != ERROR_OK) {
+		LOG_ERROR("%s error submitting pir", __func__);
+		return err;
+	}
+	return err;
+}
+
+/*
+ * PIR (Probe Mode Instruction Register), SUBMITPIR is an "IR only" TAP
+ * command; there is no corresponding data register
+ */
+static int submit_pir(struct target *t, uint64_t op)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	uint32_t tapstatus = 0;
+
+	uint8_t op_buf[8];
+	buf_set_u64(op_buf, 0, 64, op);
+	int flush = x86_32->flush;
+	x86_32->flush = 0;
+	scan.out[0] = WRPIR;
+	if (irscan(t, scan.out, NULL, LMT_IRLEN) != ERROR_OK)
+		return ERROR_FAIL;
+	if (drscan(t, op_buf, scan.out, PIR_SIZE) != ERROR_OK)
+		return ERROR_FAIL;
+	scan.out[0] = SUBMITPIR;
+	x86_32->flush = flush;
+	if (irscan(t, scan.out, NULL, LMT_IRLEN) != ERROR_OK)
+		return ERROR_FAIL;
+	jtag_add_sleep(DELAY_SUBMITPIR);
+
+	/* HACK */
+	if (x86_32->flush) {
+		int cnt = 10;
+		do {
+			tapstatus = get_tapstatus(t);
+			if (!(tapstatus & TS_PIR_BIT))
+				return ERROR_OK;
+
+			LOG_DEBUG("%s Waiting for TS_PIR_BIT, TS = 0x%08" PRIx32,
+					__func__, tapstatus);
+			usleep(100);
+			cnt--;
+		} while (cnt);
+		LOG_ERROR("%s TS_PIR_BIT did not clear, TS = 0x%08" PRIx32,
+				__func__, tapstatus);
+		return ERROR_FAIL;
+		/* TODO: find a nicer way to wait until PM_BIT changes*/
+	}
+
+	return ERROR_OK;
+
+}
+
+int lakemont_init_target(struct command_context *cmd_ctx, struct target *t)
+{
+	lakemont_build_reg_cache(t);
+	t->state = TARGET_RUNNING;
+	t->debug_reason = DBG_REASON_NOTHALTED;
+	return ERROR_OK;
+}
+
+int lakemont_init_arch_info(struct target *t, struct x86_32_common *x86_32)
+{
+	x86_32->submit_instruction = submit_instruction;
+	x86_32->transaction_status = transaction_status;
+	x86_32->read_hw_reg = read_hw_reg;
+	x86_32->write_hw_reg = write_hw_reg;
+	x86_32->sw_bpts_supported = sw_bpts_supported;
+	x86_32->io_bpts_supported = io_bpts_supported;
+	x86_32->get_num_user_regs = get_num_user_regs;
+	x86_32->is_paging_enabled = is_paging_enabled;
+	x86_32->disable_paging = disable_paging;
+	x86_32->enable_paging = enable_paging;
+	return ERROR_OK;
+}
+
+int lakemont_poll(struct target *t)
+{
+	/* LMT1 PMCR register currently allows code breakpoints, data breakpoints,
+	 * single stepping and shutdowns to be redirected to PM but does not allow
+	 * redirecting into PM as a result of SMM enter and SMM exit
+	 */
+	uint32_t ts = get_tapstatus(t);
+
+	if (ts == 0xFFFFFFFF && t->state != TARGET_DEBUG_RUNNING) {
+		/* something is wrong here */
+		LOG_ERROR("tapstatus invalid - scan_chain serialization or locked JTAG access issues");
+		/* TODO: Give a hint that unlocking is wrong or maybe a
+		 * 'jtag arp_init' helps
+		 */
+		t->state = TARGET_DEBUG_RUNNING;
+		return ERROR_OK;
+	}
+
+	if ((!(ts & TS_PM_BIT))) {
+		if (t->state == TARGET_HALTED) {
+			LOG_USER("target running for unknown reason");
+		} else if (t->state == TARGET_DEBUG_RUNNING) {
+			LOG_USER("Debug running tapstatus=0x%08" PRIx32, ts);
+		}
+		LOG_DEBUG("tapstatus=0x%08" PRIx32, ts);
+		t->state = TARGET_RUNNING;
+	}
+
+
+	if (t->state == TARGET_RUNNING ||
+		t->state == TARGET_DEBUG_RUNNING) {
+
+		if (ts & TS_PM_BIT) {
+
+			LOG_USER("redirect to PM, tapstatus=0x%08" PRIx32, get_tapstatus(t));
+
+			t->state = TARGET_DEBUG_RUNNING;
+			if (save_context(t) != ERROR_OK)
+				return ERROR_FAIL;
+			if (halt_prep(t) != ERROR_OK)
+				return ERROR_FAIL;
+			t->state = TARGET_HALTED;
+			t->debug_reason = DBG_REASON_UNDEFINED;
+
+			struct x86_32_common *x86_32 = target_to_x86_32(t);
+			uint32_t eip = buf_get_u32(x86_32->cache->reg_list[EIP].value, 0, 32);
+			uint32_t dr6 = buf_get_u32(x86_32->cache->reg_list[DR6].value, 0, 32);
+			uint32_t hwbreakpoint = (uint32_t)-1;
+
+			if (dr6 & DR6_BRKDETECT_0)
+				hwbreakpoint = 0;
+			if (dr6 & DR6_BRKDETECT_1)
+				hwbreakpoint = 1;
+			if (dr6 & DR6_BRKDETECT_2)
+				hwbreakpoint = 2;
+			if (dr6 & DR6_BRKDETECT_3)
+				hwbreakpoint = 3;
+
+			if (hwbreakpoint != (uint32_t)-1) {
+				uint32_t dr7 = buf_get_u32(x86_32->cache->reg_list[DR7].value, 0, 32);
+				uint32_t type = dr7 & (0x03 << (DR7_RW_SHIFT + hwbreakpoint*DR7_RW_LEN_SIZE));
+				if (type == DR7_BP_EXECUTE) {
+					LOG_USER("hit hardware breakpoint (hwreg=%" PRIu32 ") at 0x%08" PRIx32, hwbreakpoint, eip);
+				} else {
+					uint32_t address = 0;
+					switch (hwbreakpoint) {
+					default:
+					case 0:
+						address = buf_get_u32(x86_32->cache->reg_list[DR0].value, 0, 32);
+					break;
+					case 1:
+						address = buf_get_u32(x86_32->cache->reg_list[DR1].value, 0, 32);
+					break;
+					case 2:
+						address = buf_get_u32(x86_32->cache->reg_list[DR2].value, 0, 32);
+					break;
+					case 3:
+						address = buf_get_u32(x86_32->cache->reg_list[DR3].value, 0, 32);
+					break;
+					}
+					LOG_USER("hit '%s' watchpoint for 0x%08" PRIx32 " (hwreg=%" PRIu32 ") at 0x%08" PRIx32,
+								type == DR7_BP_WRITE ? "write" : "access", address,
+								hwbreakpoint, eip);
+				}
+				t->debug_reason = DBG_REASON_BREAKPOINT;
+			} else {
+				/* Check if the target hit a software breakpoint.
+				 * ! Watch out: EIP is currently pointing after the breakpoint opcode
+				 */
+				struct breakpoint *bp = NULL;
+				bp = breakpoint_find(t, eip-1);
+				if (bp != NULL) {
+					t->debug_reason = DBG_REASON_BREAKPOINT;
+					if (bp->type == BKPT_SOFT) {
+						/* The EIP is now pointing the the next byte after the
+						 * breakpoint instruction. This needs to be corrected.
+						 */
+						buf_set_u32(x86_32->cache->reg_list[EIP].value, 0, 32, eip-1);
+						x86_32->cache->reg_list[EIP].dirty = 1;
+						x86_32->cache->reg_list[EIP].valid = 1;
+						LOG_USER("hit software breakpoint at 0x%08" PRIx32, eip-1);
+					} else {
+						/* it's not a hardware breakpoint (checked already in DR6 state)
+						 * and it's also not a software breakpoint ...
+						 */
+						LOG_USER("hit unknown breakpoint at 0x%08" PRIx32, eip);
+					}
+				} else {
+
+					/* There is also the case that we hit an breakpoint instruction,
+					 * which was not set by us. This needs to be handled be the
+					 * application that introduced the breakpoint.
+					 */
+
+					LOG_USER("unknown break reason at 0x%08" PRIx32, eip);
+				}
+			}
+
+			return target_call_event_callbacks(t, TARGET_EVENT_HALTED);
+		}
+	}
+	return ERROR_OK;
+}
+
+int lakemont_arch_state(struct target *t)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	LOG_USER("target halted due to %s at 0x%08" PRIx32 " in %s mode",
+			debug_reason_name(t),
+			buf_get_u32(x86_32->cache->reg_list[EIP].value, 0, 32),
+			(buf_get_u32(x86_32->cache->reg_list[CR0].value, 0, 32) & CR0_PE) ? "protected" : "real");
+
+	return ERROR_OK;
+}
+
+int lakemont_halt(struct target *t)
+{
+	if (t->state == TARGET_RUNNING) {
+		t->debug_reason = DBG_REASON_DBGRQ;
+		if (do_halt(t) != ERROR_OK)
+			return ERROR_FAIL;
+		return ERROR_OK;
+	} else {
+		LOG_ERROR("%s target not running", __func__);
+		return ERROR_FAIL;
+	}
+}
+
+int lakemont_resume(struct target *t, int current, uint32_t address,
+			int handle_breakpoints, int debug_execution)
+{
+	struct breakpoint *bp = NULL;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	/* TODO lakemont_enable_breakpoints(t); */
+	if (t->state == TARGET_HALTED) {
+
+		/* running away for a software breakpoint needs some special handling */
+		uint32_t eip = buf_get_u32(x86_32->cache->reg_list[EIP].value, 0, 32);
+		bp = breakpoint_find(t, eip);
+		if (bp != NULL /*&& bp->type == BKPT_SOFT*/) {
+			/* the step will step over the breakpoint */
+			if (lakemont_step(t, 0, 0, 1) != ERROR_OK) {
+				LOG_ERROR("%s stepping over a software breakpoint at 0x%08" PRIx32 " "
+						"failed to resume the target", __func__, eip);
+				return ERROR_FAIL;
+			}
+		}
+
+		/* if breakpoints are enabled, we need to redirect these into probe mode */
+		struct breakpoint *activeswbp = t->breakpoints;
+		while (activeswbp != NULL && activeswbp->set == 0)
+			activeswbp = activeswbp->next;
+		struct watchpoint *activehwbp = t->watchpoints;
+		while (activehwbp != NULL && activehwbp->set == 0)
+			activehwbp = activehwbp->next;
+		if (activeswbp != NULL || activehwbp != NULL)
+			buf_set_u32(x86_32->cache->reg_list[PMCR].value, 0, 32, 1);
+
+		if (do_resume(t) != ERROR_OK)
+			return ERROR_FAIL;
+	} else {
+		LOG_USER("target not halted");
+		return ERROR_FAIL;
+	}
+	return ERROR_OK;
+}
+
+int lakemont_step(struct target *t, int current,
+			uint32_t address, int handle_breakpoints)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	uint32_t eflags = buf_get_u32(x86_32->cache->reg_list[EFLAGS].value, 0, 32);
+	uint32_t eip = buf_get_u32(x86_32->cache->reg_list[EIP].value, 0, 32);
+	uint32_t pmcr = buf_get_u32(x86_32->cache->reg_list[PMCR].value, 0, 32);
+	struct breakpoint *bp = NULL;
+	int retval = ERROR_OK;
+	uint32_t tapstatus = 0;
+
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	bp = breakpoint_find(t, eip);
+	if (retval == ERROR_OK && bp != NULL/*&& bp->type == BKPT_SOFT*/) {
+		/* TODO: This should only be done for software breakpoints.
+		 * Stepping from hardware breakpoints should be possible with the resume flag
+		 * Needs testing.
+		 */
+		retval = x86_32_common_remove_breakpoint(t, bp);
+	}
+
+	/* Set EFLAGS[TF] and PMCR[IR], exit pm and wait for PRDY# */
+	LOG_DEBUG("modifying PMCR = 0x%08" PRIx32 " and EFLAGS = 0x%08" PRIx32, pmcr, eflags);
+	eflags = eflags | (EFLAGS_TF | EFLAGS_RF);
+	buf_set_u32(x86_32->cache->reg_list[EFLAGS].value, 0, 32, eflags);
+	buf_set_u32(x86_32->cache->reg_list[PMCR].value, 0, 32, 1);
+	LOG_DEBUG("EFLAGS [TF] [RF] bits set=0x%08" PRIx32 ", PMCR=0x%08" PRIx32 ", EIP=0x%08" PRIx32,
+			eflags, pmcr, eip);
+
+	tapstatus = get_tapstatus(t);
+
+	t->debug_reason = DBG_REASON_SINGLESTEP;
+	t->state = TARGET_DEBUG_RUNNING;
+	if (restore_context(t) != ERROR_OK)
+		return ERROR_FAIL;
+	if (exit_probemode(t) != ERROR_OK)
+		return ERROR_FAIL;
+
+	target_call_event_callbacks(t, TARGET_EVENT_RESUMED);
+
+	tapstatus = get_tapstatus(t);
+	if (tapstatus & (TS_PM_BIT | TS_EN_PM_BIT | TS_PRDY_BIT | TS_PMCR_BIT)) {
+		/* target has stopped */
+		if (save_context(t) != ERROR_OK)
+			return ERROR_FAIL;
+		if (halt_prep(t) != ERROR_OK)
+			return ERROR_FAIL;
+		t->state = TARGET_HALTED;
+
+		LOG_USER("step done from EIP 0x%08" PRIx32 " to 0x%08" PRIx32, eip,
+				buf_get_u32(x86_32->cache->reg_list[EIP].value, 0, 32));
+		target_call_event_callbacks(t, TARGET_EVENT_HALTED);
+	} else {
+		/* target didn't stop
+		 * I hope the poll() will catch it, but the deleted breakpoint is gone
+		 */
+		LOG_ERROR("%s target didn't stop after executing a single step", __func__);
+		t->state = TARGET_RUNNING;
+		return ERROR_FAIL;
+	}
+
+	/* try to re-apply the breakpoint, even of step failed
+	 * TODO: When a bp was set, we should try to stop the target - fix the return above
+	 */
+	if (bp != NULL/*&& bp->type == BKPT_SOFT*/) {
+		/* TODO: This should only be done for software breakpoints.
+		 * Stepping from hardware breakpoints should be possible with the resume flag
+		 * Needs testing.
+		 */
+		retval = x86_32_common_add_breakpoint(t, bp);
+	}
+
+	return retval;
+}
+
+/* TODO - implement resetbreak fully through CLTAP registers */
+int lakemont_reset_assert(struct target *t)
+{
+	LOG_DEBUG("-");
+	return ERROR_OK;
+}
+
+int lakemont_reset_deassert(struct target *t)
+{
+	LOG_DEBUG("-");
+	return ERROR_OK;
+}
diff --git a/src/target/lakemont.h b/src/target/lakemont.h
new file mode 100644
index 0000000..8329b84
--- /dev/null
+++ b/src/target/lakemont.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * Adrian Burns (adrian.burns@intel.com)
+ * Thomas Faust (thomas.faust@intel.com)
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Julien Carreno (julien.carreno@intel.com)
+ * Jeffrey Maxwell (jeffrey.r.maxwell@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * This is the interface to the probemode operations for Lakemont 1 (LMT1).
+ */
+
+#ifndef LAKEMONT_H
+#define LAKEMONT_H
+#include <jtag/jtag.h>
+#include <helper/types.h>
+
+/* The Intel Quark SoC X1000 Core is codenamed lakemont */
+
+#define LMT_IRLEN		8
+
+/* lakemont tap instruction opcodes */
+#define IDCODE			2
+#define SUBMITPIR		3
+#define PROBEMODE		4
+#define WRPIR			6
+#define RDWRPDR			8
+#define TAPSTATUS		11
+#define BYPASS			255
+#define NOT_NULL		2
+
+/* DR sizes */
+#define ID_SIZE			32
+#define PM_SIZE			1
+#define PIR_SIZE		64
+#define PDR_SIZE		32
+#define TS_SIZE			32
+#define BP_SIZE			1
+#define MAX_SCAN_SIZE	PIR_SIZE
+
+/* needed during lakemont probemode */
+#define NOT_PMREG		0xfe
+#define NOT_AVAIL_REG		0xff
+#define PM_DSB			((uint32_t)0x00000000)
+#define PM_DSL			((uint32_t)0xFFFFFFFF)
+#define PM_DSAR			((uint32_t)0x004F9300)
+#define PM_DR7			((uint32_t)0x00000400)
+#define DELAY_SUBMITPIR		0 /* for now 0 is working */
+
+/* lakemont tapstatus bits */
+#define TS_PRDY_BIT		((uint32_t)0x00000001)
+#define TS_EN_PM_BIT		((uint32_t)0x00000002)
+#define TS_PM_BIT		((uint32_t)0x00000004)
+#define TS_PMCR_BIT		((uint32_t)0x00000008)
+#define TS_SBP_BIT		((uint32_t)0x00000010)
+#define TS_PIR_BIT		((uint32_t)0x00000200)
+
+struct lakemont_core_reg {
+	uint32_t num;
+	struct target *target;
+	struct x86_32_common *x86_32_common;
+	uint64_t op;
+	uint8_t pm_idx;
+};
+
+struct scan_blk {
+	uint8_t out[MAX_SCAN_SIZE]; /* scanned out to the tap */
+	uint8_t in[MAX_SCAN_SIZE]; /* in to our capture buf */
+	struct scan_field field;
+};
+
+#define I(name) (((struct lakemont_core_reg *)x86_32->cache->reg_list[name].arch_info)->pm_idx)
+
+int lakemont_init_target(struct command_context *cmd_ctx, struct target *t);
+int lakemont_init_arch_info(struct target *t, struct x86_32_common *x86_32);
+int lakemont_update_after_probemode_entry(struct target *t);
+int lakemont_poll(struct target *t);
+int lakemont_arch_state(struct target *t);
+int lakemont_halt(struct target *t);
+int lakemont_resume(struct target *t, int current, uint32_t address,
+			int handle_breakpoints, int debug_execution);
+int lakemont_step(struct target *t, int current,
+			uint32_t address, int handle_breakpoints);
+int lakemont_reset_assert(struct target *t);
+int lakemont_reset_deassert(struct target *t);
+
+#endif /* LAKEMONT_H */
diff --git a/src/target/quark_d2000.c b/src/target/quark_d2000.c
new file mode 100755
index 0000000..5266a1e
--- /dev/null
+++ b/src/target/quark_d2000.c
@@ -0,0 +1,531 @@
+/*
+ * Copyright(c) 2015 Intel Corporation.
+ *
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * Debugger for Intel Quark D2000
+ * TODO: update this text (Quark) with the Quark D2000 specific one
+ * The CPU TAP (Lakemont TAP) is used for software debug and the CLTAP is
+ * used for SoC level operations.
+ * Useful docs are here: https://communities.intel.com/community/makers/documentation
+ * Intel Quark SoC X1000 OpenOCD/GDB/Eclipse App Note (web search for doc num 330015)
+ * Intel Quark SoC X1000 Debug Operations User Guide (web search for doc num 329866)
+ * Intel Quark SoC X1000 Datasheet (web search for doc num 329676)
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/log.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "breakpoints.h"
+#include "lakemont.h"
+#include "quark_d2000.h"
+#include "x86_32_common.h"
+
+extern struct command_context *global_cmd_ctx;
+
+int quark_d2000_target_create(struct target *t, Jim_Interp *interp)
+{
+	struct x86_32_common *x86_32 = calloc(1, sizeof(struct x86_32_common));
+	if (x86_32 == NULL) {
+		LOG_ERROR("%s out of memory", __func__);
+		return ERROR_FAIL;
+	}
+	x86_32_common_init_arch_info(t, x86_32);
+	lakemont_init_arch_info(t, x86_32);
+	x86_32->core_type = LMT3_5;
+	return ERROR_OK;
+}
+
+int quark_d2000_init_target(struct command_context *cmd_ctx, struct target *t)
+{
+	return lakemont_init_target(cmd_ctx, t);
+}
+
+/*
+ * issue a system reset using a mem write, preparing the CLTAP to resetbreak
+ */
+static int quark_d2000_target_reset(struct target *t)
+{
+	LOG_DEBUG("issuing target reset");
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	int retval = ERROR_OK;
+
+	/* update target state if SRST was triggered */
+	lakemont_poll(t);
+
+	/* we can't be running when writing to memory */
+	if (t->state == TARGET_RUNNING) {
+		retval = lakemont_halt(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not halt target", __func__);
+			return retval;
+		}
+	}
+
+	/* remove breakpoints and watchpoints */
+	/* restore flash memory in case sw breaks were set here */
+	/* TODO: check if there is a better way to do it */
+	x86_32_common_reset_breakpoints_watchpoints(t);
+
+	/* set reset break */
+	static struct scan_blk scan;
+	struct scan_field *fields = &scan.field;
+	scan.out[0] = 0x35;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->in_value = NULL;
+	fields->num_bits = 8;
+	jtag_add_ir_scan(x86_32->curr_tap, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s irscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	scan.out[0] = 0x1;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->num_bits = 1;
+	jtag_add_dr_scan(x86_32->curr_tap, 1, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s drscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	/* write 0x2 to address 0xb0800570 to cause a warm reset */
+	LOG_DEBUG("%s writing mem to reset NOW!", __func__);
+	const uint8_t buf[] = { 0x2, 0x0, 0x0, 0x0 };
+	retval = x86_32_common_write_memory(t, 0xb0800570, 4, 1, buf);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s could not write memory", __func__);
+		return retval;
+	}
+
+	/* entered PM after reset, update the state */
+	t->state = TARGET_RESET;
+	t->debug_reason = DBG_REASON_DBGRQ;
+	retval = lakemont_update_after_probemode_entry(t);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s could not update state after probemode entry", __func__);
+		return retval;
+	}
+
+	/* clear reset break */
+	scan.out[0] = 0x35;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->in_value = NULL;
+	fields->num_bits = 8;
+	jtag_add_ir_scan(x86_32->curr_tap, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s irscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	scan.out[0] = 0x0;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->num_bits = 1;
+	jtag_add_dr_scan(x86_32->curr_tap, 1, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s drscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	/* resume target if reset mode is run */
+	if (!t->reset_halt) {
+		retval = lakemont_resume(t, 1, 0, 0, 0);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not resume target", __func__);
+			return retval;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int quark_d2000_wait_flash_mask(struct target *t, uint32_t addr, uint32_t bit_mask)
+{
+	int cnt = 100;
+	int retval = ERROR_OK;
+	uint8_t ctl_buff[4];
+
+	do {
+		retval = target_read_memory(t, addr, 4, 1, ctl_buff);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s: Error reading memory addr = 0x%08" PRIx32, __func__, addr);
+			return retval;
+		}
+
+		if ((uint32_t) *ctl_buff & bit_mask) {
+			return ERROR_OK;
+		}
+
+		/* Give some time to bit get set */
+		LOG_DEBUG("%s: Waiting for addr = 0x%08" PRIx32, __func__, addr);
+		usleep(10000);
+	} while (--cnt);
+
+	return ERROR_FAIL;
+}
+
+int quark_d2000_flash_write(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, const uint8_t *buf)
+{
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+				addr, size, count, buf);
+
+	/* FLASH and ROM Control Registers */
+	uint32_t FC_SUPPORT_ADDR; /* Register Field to specify if WR is enabled */
+	uint32_t FC_SUPPORT_MASK; /* Bit mask that specifies WR enabled */
+	uint32_t FC_START_ADDR;   /* Start Address in SoC memory map */
+	uint32_t FC_LIMIT_ADDR;   /* End Address in SoC memory map */
+	uint32_t FC_OFFSET;       /* Delta between SoC memory map and flash map */
+	uint32_t FC_WR_CTL;       /* Control- Sets erase/write flag and address */
+	uint32_t FC_WR_DATA;      /* 32bit register of data to be write */
+	uint32_t FC_STTS;         /* Notifies when write/erase is done */
+
+	/* OTP-ROM bit protection */
+	/* by default we don't enable writing to the OTP bit */
+	Jim_Obj *otp_write_enabled_obj;
+	long otp_write_enabled = 0;
+
+	/* Wait for FLASH_STTS for every word write */
+	/* by default we don't need to wait, JTAG mem writes take long enough */
+	Jim_Obj *flash_word_write_wait_obj;
+	long flash_word_write_wait = 0;
+
+	/* Avoid to erase page by page and wait FLASH_STTS for page delete */
+	/* by default we erase page by page */
+	Jim_Obj *flash_page_erase_disabled_obj;
+	long flash_page_erase_disabled = 0;
+
+	/* TODO: check if the TCL calls below are expensive, in case move the code to a better place */
+	otp_write_enabled_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_D2000_OTP_WRITE_ENABLED", JIM_NONE);
+	if (otp_write_enabled_obj != NULL) {
+		int result = Jim_GetLong(global_cmd_ctx->interp, otp_write_enabled_obj, &otp_write_enabled);
+		LOG_DEBUG("result %d, val %ld", result, otp_write_enabled);
+	}
+	flash_word_write_wait_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_D2000_FLASH_WORD_WRITE_WAIT", JIM_NONE);
+	if (flash_word_write_wait_obj != NULL) {
+		int result = Jim_GetLong(global_cmd_ctx->interp, flash_word_write_wait_obj, &flash_word_write_wait);
+		LOG_DEBUG("flash_word_write_wait - result %d, val %ld", result, flash_word_write_wait);
+	}
+	flash_page_erase_disabled_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_D2000_FLASH_PAGE_ERASE_DISABLED", JIM_NONE);
+	if (flash_page_erase_disabled_obj != NULL) {
+		int result = Jim_GetLong(global_cmd_ctx->interp, flash_page_erase_disabled_obj, &flash_page_erase_disabled);
+	    LOG_DEBUG("flash_page_erase_disabled - result %d, val %ld", result, flash_page_erase_disabled);
+	}
+
+	/* Select control registers based on the desired flashing region */
+	/* TODO: define a function that defines these parameters in a more scalable way */
+	if (addr < OTPC_LIMIT) {
+		LOG_DEBUG("%s: OTPC WRITE", __func__);
+		FC_SUPPORT_ADDR = FLASH_STTS;
+		FC_SUPPORT_MASK = ROM_CTL_WR_DIS_MASK;
+		FC_START_ADDR = OTPC_BASE_ADDR;
+		FC_LIMIT_ADDR = OTPC_LIMIT;
+		FC_OFFSET = OTPC_OFFSET;
+		FC_WR_CTL = ROM_WR_CTL;
+		FC_WR_DATA = ROM_WR_DATA;
+		FC_STTS = FLASH_STTS;
+
+		if ((addr == OTPC_BASE_ADDR) && ((buf[0] & 0x1) == 0)) {
+			LOG_USER("Trying to clear the OTP bit at address 0xFFFFE000, "
+					"this will lock further writes to the flash ROM after reset.");
+			if (otp_write_enabled != 1) {
+				LOG_ERROR("The QUARK_D2000_OTP_WRITE_ENABLED variable isn't set to 1 "
+						"so the operation wasn't performed.");
+				LOG_ERROR("The following command will allow it: "
+						"set QUARK_D2000_OTP_WRITE_ENABLED 1");
+				return ERROR_FAIL;
+			}
+		}
+	} else if ((addr >= FLASH_BASE_ADDR) && (addr <= FLASH_LIMT)) {
+		LOG_DEBUG("%s: FLASH WRITE", __func__);
+		FC_SUPPORT_ADDR = FLASH_CTL;
+		FC_SUPPORT_MASK = FLASH_CTL_WR_DIS_MASK;
+		FC_START_ADDR = FLASH_BASE_ADDR;
+		FC_LIMIT_ADDR = FLASH_LIMT;
+		FC_OFFSET = FLASH_OFFSET;
+		FC_WR_CTL = FLASH_WR_CTL;
+		FC_WR_DATA = FLASH_WR_DATA;
+		FC_STTS = FLASH_STTS;
+
+	} else if ((addr >= OTPD_BASE_ADDR) && (addr <= OTPD_LIMT)) {
+		LOG_DEBUG("%s: OTPD WRITE", __func__);
+		FC_SUPPORT_ADDR = FLASH_CTL;
+		FC_SUPPORT_MASK = FLASH_CTL_WR_DIS_MASK;
+		FC_START_ADDR = OTPD_BASE_ADDR;
+		FC_LIMIT_ADDR = OTPD_LIMT;
+		FC_OFFSET = OTPD_OFFSET;
+		FC_WR_CTL = FLASH_WR_CTL;
+		FC_WR_DATA = FLASH_WR_DATA;
+		FC_STTS = FLASH_STTS;
+
+	} else {
+		LOG_ERROR("%s: Invalid address=0x%08" PRIx32, __func__, addr);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	uint8_t ctl_buff[4]; /* temp location we use to write/read memory */
+
+	/* Check that write is enabled*/
+	if ((target_read_memory(t, FC_SUPPORT_ADDR, 4, 1, ctl_buff) != ERROR_OK)
+			|| ((uint32_t) *ctl_buff & FC_SUPPORT_MASK)) {
+		LOG_ERROR("%s: Write Flash Disabled", __func__);
+		return ERROR_FAIL;
+	}
+
+	/* clear flags */
+	if (target_read_memory(t, FC_STTS, 1, 1, ctl_buff) != ERROR_OK) {
+		LOG_ERROR("%s: Couldn't clear WR/ER flags", __func__);
+		return ERROR_FAIL;
+	}
+
+	/* If SW breakpoints are overwritten by the debugger then t->running_alg=1 */
+	/* if the user is just rewriting memory - notify that SW breakpoints will be overwritten */
+	if  (t->running_alg == 0) {
+		struct breakpoint *iter = t->breakpoints;
+		while (iter != NULL) {
+			if ((iter->set != 0) && (iter->type == BKPT_SOFT) &&
+					((iter->address >= FC_START_ADDR) && (iter->address <= FC_LIMIT_ADDR)) &&
+					((iter->address >= addr) && (iter->address <= addr + (size * count)))) {
+				LOG_USER("Breakpoint at address 0x%08" PRIx32 " will be overwritten!!", iter->address);
+				iter->set = 0;
+			}
+			iter = iter->next;
+		}
+	}
+
+	/* Flash's offset address */
+	uint32_t flash_addr = addr - FC_START_ADDR;
+	/* Page's number ID */
+	uint32_t flash_page_num = (flash_addr >> 11);
+	/* Page's first address */
+	uint32_t flash_page_start = FC_START_ADDR + ((flash_page_num) * FC_BYTE_PAGE_SIZE);
+	/* Page's last address */
+	uint32_t flash_page_limit = flash_page_start + FC_BYTE_PAGE_SIZE - 1;
+	/* Page's offset to be modified */
+	uint32_t flash_page_offset = addr - flash_page_start;
+	/* Page's address counter */
+	uint32_t copy_addr = flash_page_start - FC_START_ADDR;
+	/* Array to shadow page content and modify desired data */
+	uint8_t data_buff[FC_BYTE_PAGE_SIZE];
+	/* Amount of bytes pending to be written */
+	uint32_t rest_count = count * size;
+	/* Amount of bytes to be modified in the page */
+	uint32_t page_count;
+
+	/* Loop until necessary pages are saved, cleared and modified */
+	while (rest_count) {
+
+		LOG_DEBUG("pagelimit=%" PRIx32 ", pagestart=%" PRIx32 ", flashaddr=%" PRIx32 ", restcount=%" PRIx32,
+				flash_page_limit, flash_page_start, flash_addr, rest_count);
+
+		/* if the requested write overlaps two pages, write to this page
+		 * page_count bytes and leave rest_count for the next page write
+		 */
+		if ((rest_count > flash_page_limit) || (flash_addr + FC_START_ADDR > flash_page_limit - rest_count)) {
+			page_count = (flash_page_limit - flash_addr - FC_START_ADDR) +1;
+			rest_count = rest_count - page_count;
+			LOG_USER_N(".");
+		} else {
+			page_count = rest_count;
+			rest_count = 0;
+		}
+
+		/* Save Page */
+		if (page_count != FC_BYTE_PAGE_SIZE) {
+			/* Do not waste time if all page will be overwritten */
+			if (target_read_memory(t, flash_page_start, 4, 512, &data_buff[0]) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't save content of page #%d. Request failed!", __func__, flash_page_num);
+				return ERROR_FAIL;
+			}
+		}
+
+		if (!flash_page_erase_disabled) {
+			/* Erase Page */
+			buf_set_u32(ctl_buff, 0, 32, (((flash_addr + FC_OFFSET) << FC_WR_CTL_ADDR) | FC_WR_CTR_DREQ));
+			if (target_write_memory(t, FC_WR_CTL, 4, 1, ctl_buff) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't delete page #%d. Request failed!", __func__, flash_page_num);
+				return ERROR_FAIL;
+			}
+
+			/* Check for FLASH_STTS */
+			if (quark_d2000_wait_flash_mask(t, FC_STTS, FC_STTS_ER_DONE) != ERROR_OK) {
+				LOG_ERROR("%s: Bit ER_DONE in FLASH_STTS Timeout!", __func__);
+				return ERROR_FAIL;
+			}
+		}
+
+		/* Write Page */
+		memcpy(&data_buff[0] + flash_page_offset, buf, page_count);
+		for (uint32_t i = 0; i < 512; i++) {
+
+			/* Write word data */
+			if (target_write_memory(t, FC_WR_DATA, 4, 1, &data_buff[i*4]) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't write WR_DATA register in SRAM", __func__);
+				return ERROR_FAIL;
+			}
+
+			/* Select address and flag WR request */
+			buf_set_u32(ctl_buff, 0, 32, (((copy_addr + FC_OFFSET) << FC_WR_CTL_ADDR) | FC_WR_CTL_WREQ));
+			if (target_write_memory(t, FC_WR_CTL, 4, 1, ctl_buff) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't write WR_CTL register in SRAM", __func__);
+				return ERROR_FAIL;
+			}
+
+			/* Check for FLASH_STTS */
+			if (flash_word_write_wait) {
+				if (quark_d2000_wait_flash_mask(t, FC_STTS, FC_STTS_WR_DONE) != ERROR_OK) {
+					LOG_ERROR("%s: Bit WR_DONE in FLASH_STTS Timeout!", __func__);
+					return ERROR_FAIL;
+				}
+			}
+
+			/* given that doing word writes */
+			copy_addr += 4;
+		}
+
+		/* Prepare next page info */
+		flash_addr = copy_addr;
+		flash_page_num = (flash_addr >> 11);
+		flash_page_start = FC_START_ADDR + ((flash_page_num) * FC_BYTE_PAGE_SIZE);
+		flash_page_limit = flash_page_start + FC_BYTE_PAGE_SIZE - 1;
+		flash_page_offset = 0;
+
+		buf = buf + page_count;
+
+		/* Check if new page is not in other flash region */
+		if ((rest_count > 0) && (flash_page_start >= FC_LIMIT_ADDR)) {
+			return target_write_memory(t, flash_page_start, 1, rest_count, buf);
+		}
+
+	}
+
+	return ERROR_OK;
+}
+
+int quark_d2000_write_memory(struct target *t, uint32_t addr, uint32_t size,
+			uint32_t count, const uint8_t *buf)
+{
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+				addr, size, count, buf);
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if (!count || !buf) {
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+					__func__, count, buf, addr);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	/*
+	 * Check if we have an overlapping write to the protected area.
+	 * In case we are allowed to write to it, the usual code path will be taken,
+	 * otherwise give it a special treatment using the code in this block.
+	 * We switch to bytes writes, it makes the calculations simpler (no need to
+	 * take care of tails). The flash algorithm works by words anyway so it
+	 * won't affect performance
+	 */
+	if ((addr <= OTPC_DATA_LIMIT)) {
+		/* OTPC DATA bit protection */
+		/* by default we don't enable writing to the OTPC DATA area */
+		Jim_Obj *otpc_data_write_enabled_obj;
+		long otpc_data_write_enabled = 0;
+		otpc_data_write_enabled_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_D2000_OTPC_DATA_WRITE_ENABLED", JIM_NONE);
+		if (otpc_data_write_enabled_obj != NULL) {
+			int result = Jim_GetLong(global_cmd_ctx->interp, otpc_data_write_enabled_obj, &otpc_data_write_enabled);
+			LOG_DEBUG("otpc_data_write_enabled %d, val %ld", result, otpc_data_write_enabled);
+		}
+		if (!otpc_data_write_enabled) {
+			uint32_t delta = (OTPC_DATA_LIMIT - addr + 1);
+			count = size * count;
+			size = 1;
+			LOG_DEBUG("%s: delta 0x%08" PRIx32 " count 0x%08" PRIx32 " buf=%p - buf+delta=%p",
+						__func__, delta, count, buf, buf + delta);
+			if (count <= delta) {
+				LOG_USER_N("The requested flash write is contained inside the OTP DATA protected region ");
+				LOG_USER("0x%08" PRIx32 " - 0x%08" PRIx32 ", skipping that part", OTPC_BASE_ADDR, OTPC_DATA_LIMIT);
+				LOG_USER("The following command will allow it: ");
+				LOG_USER("set QUARK_D2000_OTPC_DATA_WRITE_ENABLED 1");
+				return ERROR_OK;
+			}
+			count -= delta;
+			addr = OTPC_DATA_LIMIT + 1;
+			LOG_USER_N("The requested flash write overlaps the OTP DATA protected region ");
+			LOG_USER("0x%08" PRIx32 " - 0x%08" PRIx32 ", skipping that part", OTPC_BASE_ADDR, OTPC_DATA_LIMIT);
+			LOG_USER("The following command will allow it: ");
+			LOG_USER("set QUARK_D2000_OTPC_DATA_WRITE_ENABLED 1");
+			return quark_d2000_flash_write(t, addr, size, count, buf + delta);
+		}
+	}
+
+	/*
+	 * Default write behavior, we execute here if
+	 * - write to RAM
+	 * - write to normal flash
+	 * - write to the protected flash area and the enabling is on
+	 */
+	if ((addr <= OTPC_LIMIT) || ((addr >= FLASH_BASE_ADDR) && (addr <= FLASH_LIMT))
+			|| ((addr >= OTPD_BASE_ADDR) && (addr <= OTPD_LIMT))) {
+		/* FLASH&ROM WRITE */
+		return quark_d2000_flash_write(t, addr, size, count, buf);
+	} else {
+		/* SRAM WRITE */
+		return x86_32_common_write_memory(t, addr, size, count, buf);
+	}
+}
+
+struct target_type quark_d2000_target = {
+	.name = "quark_d2000",
+	/* Quark X1000 SoC */
+	.target_create = quark_d2000_target_create,
+	.init_target = quark_d2000_init_target,
+	/* lakemont probemode specific code */
+	.poll = lakemont_poll,
+	.arch_state = lakemont_arch_state,
+	.halt = lakemont_halt,
+	.resume = lakemont_resume,
+	.step = lakemont_step,
+	.assert_reset = quark_d2000_target_reset,
+	.deassert_reset = lakemont_reset_deassert,
+	/* common x86 code */
+	.commands = x86_32_command_handlers,
+	.get_gdb_reg_list = x86_32_get_gdb_reg_list,
+	.read_memory = x86_32_common_read_memory,
+	.write_memory = quark_d2000_write_memory,
+	.add_breakpoint = x86_32_common_add_breakpoint,
+	.remove_breakpoint = x86_32_common_remove_breakpoint,
+	.add_watchpoint = x86_32_common_add_watchpoint,
+	.remove_watchpoint = x86_32_common_remove_watchpoint,
+	.virt2phys = x86_32_common_virt2phys,
+	.read_phys_memory = x86_32_common_read_phys_mem,
+	.write_phys_memory = x86_32_common_write_phys_mem,
+	.mmu = x86_32_common_mmu,
+};
diff --git a/src/target/quark_d2000.h b/src/target/quark_d2000.h
new file mode 100755
index 0000000..c76bf7e
--- /dev/null
+++ b/src/target/quark_d2000.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright(c) 2015 Intel Corporation.
+ *
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * Debugger for Intel Quark D2000
+ * This file implements any Quark SoC specific features such as resetbreak (TODO)
+ */
+
+#ifndef QUARK_D2000_H
+#define QUARK_D2000_H
+#include <jtag/jtag.h>
+#include <helper/types.h>
+
+/* QUARK D2000 FLASH ADDRESS */
+
+/* check protection bits */
+#define FLASH_STTS             ((uint32_t)0xB0100014)
+#define FLASH_CTL              ((uint32_t)0xB0100018)
+#define FLASH_CTL_WR_DIS_MASK  ((uint32_t)0x00000010) /* CTL */
+#define ROM_CTL_WR_DIS_MASK    ((uint32_t)0x00000004) /* FLASH_STTS */
+
+/* control flash(32kB) and OTPD(4kB) */
+#define FLASH_WR_CTL           ((uint32_t)0xB010000C)
+#define FLASH_WR_DATA          ((uint32_t)0xB0100010)
+
+#define FLASH_BASE_ADDR        ((uint32_t)0x00180000)
+#define FLASH_LIMT             ((uint32_t)0x00187FFF)
+#define FLASH_OFFSET           ((uint32_t)0x1000)
+
+#define OTPD_BASE_ADDR         ((uint32_t)0x00200000)
+#define OTPD_LIMT              ((uint32_t)0x00200FFF)
+#define OTPD_OFFSET            ((uint32_t)0x0)
+
+/* control rom OTPC(8kB) */
+#define ROM_WR_CTL             ((uint32_t)0xB0100004)
+#define ROM_WR_DATA            ((uint32_t)0xB0100008)
+
+#define OTPC_BASE_ADDR         ((uint32_t)0x00000000)
+#define OTPC_LIMIT             ((uint32_t)0x00001FFF)
+#define OTPC_OFFSET            ((uint32_t)0x0)
+
+/* data area in OTPC(0x0-0x14F) */
+#define OTPC_DATA_LIMIT        ((uint32_t)0x0000014F)
+
+/* flash and rom generic */
+#define FC_WR_CTL_ADDR      2
+#define FC_WR_CTR_DREQ    (1<<1)
+#define FC_WR_CTL_WREQ    (1<<0)
+#define FC_STTS_WR_DONE   (1<<1)
+#define FC_STTS_ER_DONE   (1<<0)
+#define FC_BYTE_PAGE_SIZE (4*512)
+
+/* public interface */
+int quark_d2000_flash_write(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, const uint8_t *buf);
+
+#endif /* QUARK_D2000_H */
diff --git a/src/target/quark_se.c b/src/target/quark_se.c
new file mode 100644
index 0000000..c2c853c
--- /dev/null
+++ b/src/target/quark_se.c
@@ -0,0 +1,483 @@
+/*
+ * Copyright(c) 2014 Intel Corporation.
+ *
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * Debugger for Intel Quark SE
+ * TODO: update this text (Quark) with the Quark SE specific one
+ * Intel Quark X10xx is the first product in the Quark family of SoCs.
+ * It is an IA-32 (Pentium x86 ISA) compatible SoC. The core CPU in the
+ * X10xx is codenamed Lakemont. Lakemont version 1 (LMT1) is used in X10xx.
+ * The CPU TAP (Lakemont TAP) is used for software debug and the CLTAP is
+ * used for SoC level operations.
+ * Useful docs are here: https://communities.intel.com/community/makers/documentation
+ * Intel Quark SoC X1000 OpenOCD/GDB/Eclipse App Note (web search for doc num 330015)
+ * Intel Quark SoC X1000 Debug Operations User Guide (web search for doc num 329866)
+ * Intel Quark SoC X1000 Datasheet (web search for doc num 329676)
+ *
+ * This file implements any Quark SoC specific features such as resetbreak (TODO)
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/log.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "breakpoints.h"
+#include "lakemont.h"
+#include "quark_se.h"
+#include "x86_32_common.h"
+
+extern struct command_context *global_cmd_ctx;
+
+int quark_se_target_create(struct target *t, Jim_Interp *interp)
+{
+	struct x86_32_common *x86_32 = calloc(1, sizeof(struct x86_32_common));
+	if (x86_32 == NULL) {
+		LOG_ERROR("%s out of memory", __func__);
+		return ERROR_FAIL;
+	}
+	x86_32_common_init_arch_info(t, x86_32);
+	lakemont_init_arch_info(t, x86_32);
+	x86_32->core_type = LMT3_5;
+	return ERROR_OK;
+}
+
+int quark_se_init_target(struct command_context *cmd_ctx, struct target *t)
+{
+	return lakemont_init_target(cmd_ctx, t);
+}
+
+/*
+ * issue a system reset using a mem write, preparing the CLTAP to resetbreak
+ */
+static int quark_se_target_reset(struct target *t)
+{
+	LOG_DEBUG("issuing target reset");
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	int retval = ERROR_OK;
+
+	/* we can't be running when writing to memory */
+	if (t->state == TARGET_RUNNING) {
+		retval = lakemont_halt(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not halt target", __func__);
+			return retval;
+		}
+	}
+
+	/* remove breakpoints and watchpoints */
+	/* restore flash memory in case sw breaks were set here */
+	/* TODO: check if there is a better way to do it */
+	x86_32_common_reset_breakpoints_watchpoints(t);
+
+	/* set reset break */
+	static struct scan_blk scan;
+	struct scan_field *fields = &scan.field;
+	scan.out[0] = 0x35;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->in_value = NULL;
+	fields->num_bits = 8;
+	jtag_add_ir_scan(x86_32->curr_tap, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s irscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	scan.out[0] = 0x1;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->num_bits = 1;
+	jtag_add_dr_scan(x86_32->curr_tap, 1, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s drscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	/* write 0x2 to address 0xb0800570 to cause a warm reset */
+	LOG_DEBUG("%s writing mem to reset NOW!", __func__);
+	const uint8_t buf[] = { 0x2, 0x0, 0x0, 0x0 };
+	retval = x86_32_common_write_memory(t, 0xb0800570, 4, 1, buf);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s could not write memory", __func__);
+		return retval;
+	}
+
+	/* entered PM after reset, update the state */
+	t->state = TARGET_RESET;
+	t->debug_reason = DBG_REASON_DBGRQ;
+	retval = lakemont_update_after_probemode_entry(t);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s could not update state after probemode entry", __func__);
+		return retval;
+	}
+
+	/* clear reset break */
+	scan.out[0] = 0x35;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->in_value = NULL;
+	fields->num_bits = 8;
+	jtag_add_ir_scan(x86_32->curr_tap, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s irscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	scan.out[0] = 0x0;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->num_bits = 1;
+	jtag_add_dr_scan(x86_32->curr_tap, 1, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s drscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	/* resume target if reset mode is run */
+	if (!t->reset_halt) {
+		retval = lakemont_resume(t, 1, 0, 0, 0);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not resume target", __func__);
+			return retval;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int quark_se_wait_flash_mask(struct target *t, uint32_t addr, uint32_t bit_mask)
+{
+	int cnt = 100;
+	int retval = ERROR_OK;
+	uint8_t ctl_buff[4];
+
+	do {
+		retval = target_read_memory(t, addr, 4, 1, ctl_buff);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s: Error reading memory addr = 0x%08" PRIx32, __func__, addr);
+			return retval;
+		}
+
+		if ((uint32_t) *ctl_buff & bit_mask) {
+			return ERROR_OK;
+		}
+
+		/* Give some time to bit get set */
+		LOG_DEBUG("%s: Waiting for addr = 0x%08" PRIx32, __func__, addr);
+		usleep(10000);
+	} while (--cnt);
+
+	return ERROR_FAIL;
+}
+
+int quark_se_flash_write(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, const uint8_t *buf)
+{
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+				addr, size, count, buf);
+
+	/* FLASH0, FLASH1 and ROM Control Registers */
+	uint32_t FC_SUPPORT_ADDR; /* Register Field to specify if WR is enabled */
+	uint32_t FC_SUPPORT_MASK; /* Bit mask that specifies WR enabled */
+	uint32_t FC_START_ADDR;   /* Start Address in SoC memory map */
+	uint32_t FC_LIMIT_ADDR;   /* End Address in SoC memory map */
+	uint32_t FC_WR_CTL;       /* Control- Sets erase/write flag and address */
+	uint32_t FC_WR_DATA;      /* 32bit register of data to be write */
+	uint32_t FC_STTS;         /* Notifies when write/erase is done */
+
+	/* OTP-ROM bit protection */
+	/* by default we don't enable writing to the OTP bit */
+	Jim_Obj *otp_write_enabled_obj;
+	long otp_write_enabled = 0;
+
+	/* Wait for FLASH_STTS for every word write */
+	/* by default we don't need to wait, JTAG mem writes take long enough */
+	Jim_Obj *flash_word_write_wait_obj;
+	long flash_word_write_wait = 0;
+
+	/* Avoid to erase page by page and wait FLASH_STTS for page delete */
+	/* by default we erase page by page */
+	Jim_Obj *flash_page_erase_disabled_obj;
+	long flash_page_erase_disabled = 0;
+
+	/* TODO: check if the TCL calls below are expensive, in case move the code to a better place */
+	otp_write_enabled_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_SE_OTP_WRITE_ENABLED", JIM_NONE);
+	if (otp_write_enabled_obj != NULL) {
+		int result = Jim_GetLong(global_cmd_ctx->interp, otp_write_enabled_obj, &otp_write_enabled);
+		LOG_DEBUG("otp_write_enabled - result %d, val %ld", result, otp_write_enabled);
+	}
+	flash_word_write_wait_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_SE_FLASH_WORD_WRITE_WAIT", JIM_NONE);
+	if (flash_word_write_wait_obj != NULL) {
+		int result = Jim_GetLong(global_cmd_ctx->interp, flash_word_write_wait_obj, &flash_word_write_wait);
+		LOG_DEBUG("flash_word_write_wait - result %d, val %ld", result, flash_word_write_wait);
+	}
+	flash_page_erase_disabled_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_SE_FLASH_PAGE_ERASE_DISABLED", JIM_NONE);
+	if (flash_page_erase_disabled_obj != NULL) {
+		int result = Jim_GetLong(global_cmd_ctx->interp, flash_page_erase_disabled_obj, &flash_page_erase_disabled);
+	    LOG_DEBUG("flash_page_erase_disabled - result %d, val %ld", result, flash_page_erase_disabled);
+	}
+
+	/* Select control registers based on the desired flashing region */
+	if ((addr >= FLASH1_BASE_ADDR) && (addr <= FLASH1_LIMT)) {
+		LOG_DEBUG("%s: FLASH1 WRITE", __func__);
+		FC_SUPPORT_ADDR = FLASH1_CTL;
+		FC_SUPPORT_MASK = FLASH_CTL_WR_DIS_MASK;
+		FC_START_ADDR = FLASH1_BASE_ADDR;
+		FC_LIMIT_ADDR = FLASH1_LIMT;
+		FC_WR_CTL = FLASH1_WR_CTL;
+		FC_WR_DATA = FLASH1_WR_DATA;
+		FC_STTS = FLASH1_STTS;
+	} else if ((addr >= FLASH0_BASE_ADDR) && (addr <= FLASH0_LIMT)) {
+		LOG_DEBUG("%s: FLASH0 WRITE", __func__);
+		FC_SUPPORT_ADDR = FLASH0_CTL;
+		FC_SUPPORT_MASK = FLASH_CTL_WR_DIS_MASK;
+		FC_START_ADDR = FLASH0_BASE_ADDR;
+		FC_LIMIT_ADDR = FLASH0_LIMT;
+		FC_WR_CTL = FLASH0_WR_CTL;
+		FC_WR_DATA = FLASH0_WR_DATA;
+		FC_STTS = FLASH0_STTS;
+	} else if ((addr >= ROM_BASE_ADDR) && (addr <= ROM_LIMIT)) {
+		LOG_DEBUG("%s: ROM WRITE", __func__);
+		FC_SUPPORT_ADDR = FLASH0_STTS;
+		FC_SUPPORT_MASK = ROM_CTL_WR_DIS_MASK;
+		FC_START_ADDR = ROM_BASE_ADDR;
+		FC_LIMIT_ADDR = ROM_LIMIT;
+		FC_WR_CTL = ROM_WR_CTL;
+		FC_WR_DATA = ROM_WR_DATA;
+		FC_STTS = FLASH0_STTS;
+
+		if ((addr == ROM_BASE_ADDR) && ((buf[0] & 0x1) == 0)) {
+			LOG_USER("Trying to clear the OTP bit at address 0xFFFFE000, "
+					"this will lock further writes to the flash ROM after reset.");
+			if (otp_write_enabled != 1) {
+				LOG_ERROR("The QUARK_SE_OTP_WRITE_ENABLED variable isn't set to 1 "
+						"so the operation wasn't performed.");
+				LOG_ERROR("The following command will allow it: "
+						"set QUARK_SE_OTP_WRITE_ENABLED 1");
+				return ERROR_FAIL;
+			}
+		}
+
+	} else {
+		LOG_ERROR("%s: Invalid address=0x%08" PRIx32, __func__, addr);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	uint8_t ctl_buff[4]; /* temp location we use to write/read memory */
+
+	/* Check that write is enabled*/
+	if ((target_read_memory(t, FC_SUPPORT_ADDR, 4, 1, ctl_buff) != ERROR_OK)
+			|| ((uint32_t) *ctl_buff & FC_SUPPORT_MASK)) {
+		LOG_ERROR("%s: Write Flash Disabled", __func__);
+		return ERROR_FAIL;
+	}
+
+	/* clear flags */
+	if (target_read_memory(t, FC_STTS, 1, 1, ctl_buff) != ERROR_OK) {
+		LOG_ERROR("%s: Couldn't clear WR/ER flags", __func__);
+		return ERROR_FAIL;
+	}
+
+	/* If SW breakpoints are overwritten by the debugger then t->running_alg=1 */
+	/* if the user is just rewriting memory - notify that SW breakpoints will be overwritten */
+	if  (t->running_alg == 0) {
+		struct breakpoint *iter = t->breakpoints;
+		while (iter != NULL) {
+			if ((iter->set != 0) && (iter->type == BKPT_SOFT) &&
+					((iter->address >= FC_START_ADDR) && (iter->address <= FC_LIMIT_ADDR)) &&
+					((iter->address >= addr) && (iter->address <= addr + (size * count)))) {
+				LOG_USER("Breakpoint at address 0x%08" PRIx32 " will be overwritten!!", iter->address);
+				iter->set = 0;
+			}
+			iter = iter->next;
+		}
+	}
+
+	/* Flash's offset address */
+	uint32_t flash_addr = addr - FC_START_ADDR;
+	/* Page's number ID */
+	uint32_t flash_page_num = (flash_addr >> 11);
+	/* Page's first address */
+	uint32_t flash_page_start = FC_START_ADDR + ((flash_page_num) * FC_BYTE_PAGE_SIZE);
+	/* Page's last address */
+	uint32_t flash_page_limit = flash_page_start + FC_BYTE_PAGE_SIZE - 1;
+	/* Page's offset to be modified */
+	uint32_t flash_page_offset = addr - flash_page_start;
+	/* Page's address counter */
+	uint32_t copy_addr = flash_page_start - FC_START_ADDR;
+	/* Array to shadow page content and modify desired data */
+	uint8_t data_buff[FC_BYTE_PAGE_SIZE];
+	/* Amount of bytes pending to be written */
+	uint32_t rest_count = count * size;
+	/* Amount of bytes to be modified in the page */
+	uint32_t page_count;
+
+	/* Loop until necessary pages are saved, cleared and modified */
+	while (rest_count) {
+
+		LOG_DEBUG("pagelimit=%" PRIx32 ", pagestart=%" PRIx32 ", flashaddr=%" PRIx32 ", restcount=%" PRIx32,
+				flash_page_limit, flash_page_start, flash_addr, rest_count);
+
+		/* if the requested write overlaps two pages, write to this page
+		 * page_count bytes and leave rest_count for the next page write
+		 */
+		if (flash_addr + FC_START_ADDR > flash_page_limit - rest_count) {
+			page_count = flash_page_limit - ((flash_addr - 1) + FC_START_ADDR);
+			rest_count = rest_count - page_count;
+			LOG_USER_N(".");
+		} else {
+			page_count = rest_count;
+			rest_count = 0;
+		}
+
+		/* Save Page */
+		if (target_read_memory(t, flash_page_start, 4, 512, &data_buff[0]) != ERROR_OK) {
+			LOG_ERROR("%s: Couldn't save content of page #%d. Request failed!", __func__, flash_page_num);
+			return ERROR_FAIL;
+		}
+
+		if (!flash_page_erase_disabled) {
+			/* Erase Page */
+			buf_set_u32(ctl_buff, 0, 32, ((flash_addr << FC_WR_CTL_ADDR) | FC_WR_CTR_DREQ));
+			if (target_write_memory(t, FC_WR_CTL, 4, 1, ctl_buff) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't delete page #%d. Request failed!", __func__, flash_page_num);
+				return ERROR_FAIL;
+			}
+
+			/* Check for FLASH_STTS */
+			if (quark_se_wait_flash_mask(t, FC_STTS, FC_STTS_ER_DONE) != ERROR_OK) {
+				LOG_ERROR("%s: Bit ER_DONE in FLASH_STTS Timeout!", __func__);
+				return ERROR_FAIL;
+			}
+		}
+
+		/* Write Page */
+		memcpy(&data_buff[0] + flash_page_offset, buf, page_count);
+		for (uint32_t i = 0; i < 512; i++) {
+
+			/* Write word data */
+			if (target_write_memory(t, FC_WR_DATA, 4, 1, &data_buff[i*4]) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't write WR_DATA register in SRAM", __func__);
+				return ERROR_FAIL;
+			}
+
+			/* Select address and flag WR request */
+			buf_set_u32(ctl_buff, 0, 32, (((copy_addr) << FC_WR_CTL_ADDR) | FC_WR_CTL_WREQ));
+			if (target_write_memory(t, FC_WR_CTL, 4, 1, ctl_buff) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't write WR_CTL register in SRAM", __func__);
+				return ERROR_FAIL;
+			}
+
+			/* Check for FLASH_STTS */
+			if (flash_word_write_wait) {
+				if (quark_se_wait_flash_mask(t, FC_STTS, FC_STTS_WR_DONE) != ERROR_OK) {
+					LOG_ERROR("%s: Bit WR_DONE in FLASH_STTS Timeout!", __func__);
+					return ERROR_FAIL;
+				}
+			}
+
+			/* given that doing word writes */
+			copy_addr += 4;
+		}
+
+		/* avoid overflowing */
+		if ((flash_page_limit == ROM_LIMIT) && (rest_count != 0)) {
+			LOG_ERROR("Trying to write above memory limit 0xFFFFFFFF");
+			return ERROR_COMMAND_ARGUMENT_OVERFLOW;
+		}
+
+		/* Prepare next page info */
+		flash_addr = copy_addr;
+		flash_page_num = (flash_addr >> 11);
+		flash_page_start = FC_START_ADDR + ((flash_page_num) * FC_BYTE_PAGE_SIZE);
+		flash_page_limit = flash_page_start + FC_BYTE_PAGE_SIZE - 1;
+		flash_page_offset = 0;
+
+		buf = buf + page_count;
+
+		/* Check if new page is not in other flash region */
+		if ((rest_count > 0) && (flash_page_start >= FC_LIMIT_ADDR)) {
+			return target_write_memory(t, flash_page_start, 1, rest_count, buf);
+		}
+
+	}
+
+	return ERROR_OK;
+}
+
+int quark_se_write_memory(struct target *t, uint32_t addr, uint32_t size,
+			uint32_t count, const uint8_t *buf)
+{
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+				addr, size, count, buf);
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if (!count || !buf || !addr) {
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+					__func__, count, buf, addr);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	if (((addr >= FLASH0_BASE_ADDR) && (addr <= FLASH0_LIMT))
+			|| ((addr >= FLASH1_BASE_ADDR) && (addr <= FLASH1_LIMT))
+			|| ((addr >= ROM_BASE_ADDR) && (addr <= ROM_LIMIT))) {
+		/* Quark SE FLASH&ROM WRITE */
+		return quark_se_flash_write(t, addr, size, count, buf);
+	} else {
+		/* Quark SE SRAM WRITE */
+		return x86_32_common_write_memory(t, addr, size, count, buf);
+	}
+
+}
+
+struct target_type quark_se_target = {
+	.name = "quark_se",
+	.target_create = quark_se_target_create,
+	.init_target = quark_se_init_target,
+	/* lakemont probemode specific code */
+	.poll = lakemont_poll,
+	.arch_state = lakemont_arch_state,
+	.halt = lakemont_halt,
+	.resume = lakemont_resume,
+	.step = lakemont_step,
+	.assert_reset = quark_se_target_reset,
+	.deassert_reset = lakemont_reset_deassert,
+	/* common x86 code */
+	.commands = x86_32_command_handlers,
+	.get_gdb_reg_list = x86_32_get_gdb_reg_list,
+	.read_memory = x86_32_common_read_memory,
+	.write_memory = quark_se_write_memory,
+	.add_breakpoint = x86_32_common_add_breakpoint,
+	.remove_breakpoint = x86_32_common_remove_breakpoint,
+	.add_watchpoint = x86_32_common_add_watchpoint,
+	.remove_watchpoint = x86_32_common_remove_watchpoint,
+	.virt2phys = x86_32_common_virt2phys,
+	.read_phys_memory = x86_32_common_read_phys_mem,
+	.write_phys_memory = x86_32_common_write_phys_mem,
+	.mmu = x86_32_common_mmu,
+};
diff --git a/src/target/quark_se.h b/src/target/quark_se.h
new file mode 100644
index 0000000..d948606
--- /dev/null
+++ b/src/target/quark_se.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright(c) 2015 Intel Corporation.
+ *
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * Debugger for Intel Quark SE
+ * This file implements any Quark SE SoC specific features such as resetbreak
+ */
+
+#ifndef QUARK_SE_H
+#define QUARK_SE_H
+#include <jtag/jtag.h>
+#include <helper/types.h>
+
+/* Quark SE FLASH ADDRESS */
+#define FLASH0_STTS      ((uint32_t)0xB0100014)
+#define FLASH0_CTL       ((uint32_t)0xB0100018)
+#define FLASH0_WR_CTL    ((uint32_t)0xB010000C)
+#define FLASH0_WR_DATA   ((uint32_t)0xB0100010)
+#define FLASH0_BASE_ADDR ((uint32_t)0x40000000)
+#define FLASH0_LIMT      ((uint32_t)0x4002FFFF)
+
+#define FLASH1_STTS      ((uint32_t)0xB0200014)
+#define FLASH1_CTL       ((uint32_t)0xB0200018)
+#define FLASH1_WR_CTL    ((uint32_t)0xB020000C)
+#define FLASH1_WR_DATA   ((uint32_t)0xB0200010)
+#define FLASH1_BASE_ADDR ((uint32_t)0x40030000)
+#define FLASH1_LIMT      ((uint32_t)0x4005FFFF)
+
+#define ROM_WR_CTL     ((uint32_t)0xB0100004)
+#define ROM_WR_DATA    ((uint32_t)0xB0100008)
+#define ROM_BASE_ADDR  ((uint32_t)0xFFFFE000)
+#define ROM_LIMIT      ((uint32_t)0xFFFFFFFF)
+
+#define FLASH_CTL_WR_DIS_MASK  ((uint32_t)0x00000010) /* CTL */
+#define ROM_CTL_WR_DIS_MASK    ((uint32_t)0x00000004) /* FLASH_STTS */
+
+/* FLASH0, FLASH1 and ROM generic */
+#define FC_WR_CTL_ADDR      2
+#define FC_WR_CTR_DREQ    (1<<1)
+#define FC_WR_CTL_WREQ    (1<<0)
+#define FC_STTS_WR_DONE   (1<<1)
+#define FC_STTS_ER_DONE   (1<<0)
+#define FC_BYTE_PAGE_SIZE (4*512)
+
+/* public interface */
+int quark_se_flash_write(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, const uint8_t *buf);
+
+#endif /* QUARK_SE_H */
diff --git a/src/target/quark_x10xx.c b/src/target/quark_x10xx.c
new file mode 100644
index 0000000..9eb0141
--- /dev/null
+++ b/src/target/quark_x10xx.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright(c) 2013-2014 Intel Corporation.
+ *
+ * Adrian Burns (adrian.burns@intel.com)
+ * Thomas Faust (thomas.faust@intel.com)
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Julien Carreno (julien.carreno@intel.com)
+ * Jeffrey Maxwell (jeffrey.r.maxwell@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * Debugger for Intel Quark SoC X1000
+ * Intel Quark X10xx is the first product in the Quark family of SoCs.
+ * It is an IA-32 (Pentium x86 ISA) compatible SoC. The core CPU in the
+ * X10xx is codenamed Lakemont. Lakemont version 1 (LMT1) is used in X10xx.
+ * The CPU TAP (Lakemont TAP) is used for software debug and the CLTAP is
+ * used for SoC level operations.
+ * Useful docs are here: https://communities.intel.com/community/makers/documentation
+ * Intel Quark SoC X1000 OpenOCD/GDB/Eclipse App Note (web search for doc num 330015)
+ * Intel Quark SoC X1000 Debug Operations User Guide (web search for doc num 329866)
+ * Intel Quark SoC X1000 Datasheet (web search for doc num 329676)
+ *
+ * This file implements any Quark SoC specific features such as resetbreak (TODO)
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/log.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "lakemont.h"
+#include "x86_32_common.h"
+
+int quark_x10xx_target_create(struct target *t, Jim_Interp *interp)
+{
+	struct x86_32_common *x86_32 = calloc(1, sizeof(struct x86_32_common));
+	if (x86_32 == NULL) {
+		LOG_ERROR("%s out of memory", __func__);
+		return ERROR_FAIL;
+	}
+	x86_32_common_init_arch_info(t, x86_32);
+	lakemont_init_arch_info(t, x86_32);
+	x86_32->core_type = LMT1;
+	return ERROR_OK;
+}
+
+int quark_x10xx_init_target(struct command_context *cmd_ctx, struct target *t)
+{
+	return lakemont_init_target(cmd_ctx, t);
+}
+
+struct target_type quark_x10xx_target = {
+	.name = "quark_x10xx",
+	/* Quark X1000 SoC */
+	.target_create = quark_x10xx_target_create,
+	.init_target = quark_x10xx_init_target,
+	/* lakemont probemode specific code */
+	.poll = lakemont_poll,
+	.arch_state = lakemont_arch_state,
+	.halt = lakemont_halt,
+	.resume = lakemont_resume,
+	.step = lakemont_step,
+	.assert_reset = lakemont_reset_assert,
+	.deassert_reset = lakemont_reset_deassert,
+	/* common x86 code */
+	.commands = x86_32_command_handlers,
+	.get_gdb_reg_list = x86_32_get_gdb_reg_list,
+	.read_memory = x86_32_common_read_memory,
+	.write_memory = x86_32_common_write_memory,
+	.add_breakpoint = x86_32_common_add_breakpoint,
+	.remove_breakpoint = x86_32_common_remove_breakpoint,
+	.add_watchpoint = x86_32_common_add_watchpoint,
+	.remove_watchpoint = x86_32_common_remove_watchpoint,
+	.virt2phys = x86_32_common_virt2phys,
+	.read_phys_memory = x86_32_common_read_phys_mem,
+	.write_phys_memory = x86_32_common_write_phys_mem,
+	.mmu = x86_32_common_mmu,
+};
diff --git a/src/target/register.h b/src/target/register.h
index 354a179..d233388 100644
--- a/src/target/register.h
+++ b/src/target/register.h
@@ -43,6 +43,7 @@ enum reg_type {
 	REG_TYPE_FLOAT,
 	REG_TYPE_IEEE_SINGLE,
 	REG_TYPE_IEEE_DOUBLE,
+	REG_TYPE_i387_EXT,
 	REG_TYPE_ARCH_DEFINED,
 };
 
diff --git a/src/target/target.c b/src/target/target.c
index b7abffe..553eff9 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -97,11 +97,15 @@ extern struct target_type dsp563xx_target;
 extern struct target_type dsp5680xx_target;
 extern struct target_type testee_target;
 extern struct target_type avr32_ap7k_target;
+extern struct target_type arc32_target;
 extern struct target_type hla_target;
 extern struct target_type nds32_v2_target;
 extern struct target_type nds32_v3_target;
 extern struct target_type nds32_v3m_target;
 extern struct target_type or1k_target;
+extern struct target_type quark_x10xx_target;
+extern struct target_type quark_d2000_target;
+extern struct target_type quark_se_target;
 
 static struct target_type *target_types[] = {
 	&arm7tdmi_target,
@@ -125,11 +129,15 @@ static struct target_type *target_types[] = {
 	&dsp5680xx_target,
 	&testee_target,
 	&avr32_ap7k_target,
+	&arc32_target,
 	&hla_target,
 	&nds32_v2_target,
 	&nds32_v3_target,
 	&nds32_v3m_target,
 	&or1k_target,
+	&quark_x10xx_target,
+	&quark_d2000_target,
+	&quark_se_target,
 	NULL,
 };
 
@@ -448,7 +456,7 @@ struct target *get_target(const char *id)
 
 	for (target = all_targets; target; target = target->next) {
 		if (target->target_number == (int)num) {
-			LOG_WARNING("use '%s' as target identifier, not '%u'",
+			LOG_DEBUG("Target: '%s' selected, with number '%u'",
 					target_name(target), num);
 			return target;
 		}
@@ -3000,18 +3008,18 @@ COMMAND_HANDLER(handle_load_image_command)
 
 		/* DANGER!!! beware of unsigned comparision here!!! */
 
-		if ((image.sections[i].base_address + buf_cnt >= min_address) &&
+		if ((image.sections[i].base_address + image.sections[i].size >= min_address) &&
 				(image.sections[i].base_address < max_address)) {
 
+			if ((image.sections[i].size >= 1) && ((image.sections[i].size - 1) > (max_address - image.sections[i].base_address)))
+				length = max_address - image.sections[i].base_address + 1;
+
 			if (image.sections[i].base_address < min_address) {
 				/* clip addresses below */
 				offset += min_address-image.sections[i].base_address;
 				length -= offset;
 			}
 
-			if (image.sections[i].base_address + buf_cnt > max_address)
-				length -= (image.sections[i].base_address + buf_cnt)-max_address;
-
 			retval = target_write_buffer(target,
 					image.sections[i].base_address + offset, length, buffer + offset);
 			if (retval != ERROR_OK) {
@@ -3101,15 +3109,15 @@ COMMAND_HANDLER(handle_dump_image_command)
 	return retval;
 }
 
-static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
+static COMMAND_HELPER(handle_verify_image_command_body_internal, int verify, int section_offset)
 {
 	uint8_t *buffer;
 	size_t buf_cnt;
 	uint32_t image_size;
 	int i;
 	int retval;
-	uint32_t checksum = 0;
-	uint32_t mem_checksum = 0;
+	uint32_t section_offset_val = 0;
+	uint32_t total_bytes_verified = 0;
 
 	struct image image;
 
@@ -3138,7 +3146,13 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 
 	image.start_address_set = 0;
 
-	retval = image_open(&image, CMD_ARGV[0], (CMD_ARGC == 3) ? CMD_ARGV[2] : NULL);
+	if (section_offset == 0) {
+		retval = image_open(&image, CMD_ARGV[0], (CMD_ARGC == 3) ? CMD_ARGV[2] : NULL);
+	} else {
+		retval = image_open(&image, CMD_ARGV[0], NULL);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], section_offset_val);
+		LOG_DEBUG("Section_offset_val 0x%08" PRIx32, section_offset_val);
+	}
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -3160,26 +3174,12 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 		}
 
 		if (verify) {
-			/* calculate checksum of image */
-			retval = image_calculate_checksum(buffer, buf_cnt, &checksum);
-			if (retval != ERROR_OK) {
-				free(buffer);
-				break;
-			}
-
-			retval = target_checksum_memory(target, image.sections[i].base_address, buf_cnt, &mem_checksum);
-			if (retval != ERROR_OK) {
-				free(buffer);
-				break;
-			}
-
-			if (checksum != mem_checksum) {
-				/* failed crc checksum, fall back to a binary compare */
+			if (buf_cnt < section_offset_val) {
+				LOG_ERROR("Can't skip 0x%08" PRIx32 " bytes, section %d contains only 0x%08" PRIx32,
+					section_offset_val, i, (uint32_t)buf_cnt);
+			} else {
+				/* do a binary compare */
 				uint8_t *data;
-
-				if (diffs == 0)
-					LOG_ERROR("checksum mismatch - attempting binary compare");
-
 				data = (uint8_t *)malloc(buf_cnt);
 
 				/* Can we use 32bit word accesses? */
@@ -3192,7 +3192,7 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 				retval = target_read_memory(target, image.sections[i].base_address, size, count, data);
 				if (retval == ERROR_OK) {
 					uint32_t t;
-					for (t = 0; t < buf_cnt; t++) {
+					for (t = 0 + section_offset_val; t < buf_cnt; t++, total_bytes_verified++) {
 						if (data[t] != buffer[t]) {
 							command_print(CMD_CTX,
 										  "diff %d address 0x%08x. Was 0x%02x instead of 0x%02x",
@@ -3200,8 +3200,8 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 										  (unsigned)(t + image.sections[i].base_address),
 										  data[t],
 										  buffer[t]);
-							if (diffs++ >= 127) {
-								command_print(CMD_CTX, "More than 128 errors, the rest are not printed.");
+							if (diffs++ >= 7) {
+								command_print(CMD_CTX, "More than 8 errors, the rest are not printed.");
 								free(data);
 								free(buffer);
 								goto done;
@@ -3228,7 +3228,7 @@ done:
 		retval = ERROR_FAIL;
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK)) {
 		command_print(CMD_CTX, "verified %" PRIu32 " bytes "
-				"in %fs (%0.3f KiB/s)", image_size,
+				"in %fs (%0.3f KiB/s)", total_bytes_verified,
 				duration_elapsed(&bench), duration_kbps(&bench, image_size));
 	}
 
@@ -3237,14 +3237,24 @@ done:
 	return retval;
 }
 
+static COMMAND_HELPER(handle_verify_image_command_internal, int verify, int section_offset)
+{
+	return CALL_COMMAND_HANDLER(handle_verify_image_command_body_internal, verify, section_offset);
+}
+
 COMMAND_HANDLER(handle_verify_image_command)
 {
-	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, 1);
+	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, 1, 0);
+}
+
+COMMAND_HANDLER(handle_verify_image_offset_command)
+{
+	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, 1, 1);
 }
 
 COMMAND_HANDLER(handle_test_image_command)
 {
-	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, 0);
+	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, 0, 0);
 }
 
 static int handle_bp_command_list(struct command_context *cmd_ctx)
@@ -3385,7 +3395,7 @@ COMMAND_HANDLER(handle_wp_command)
 		while (watchpoint) {
 			command_print(CMD_CTX, "address: 0x%8.8" PRIx32
 					", len: 0x%8.8" PRIx32
-					", r/w/a: %i, value: 0x%8.8" PRIx32
+					", r/w/a/i: %i, value: 0x%8.8" PRIx32
 					", mask: 0x%8.8" PRIx32,
 					watchpoint->address,
 					watchpoint->length,
@@ -3421,6 +3431,9 @@ COMMAND_HANDLER(handle_wp_command)
 		case 'a':
 			type = WPT_ACCESS;
 			break;
+		case 'i':
+			type = WPT_IO;
+			break;
 		default:
 			LOG_ERROR("invalid watchpoint mode ('%c')", CMD_ARGV[2][0]);
 			return ERROR_COMMAND_SYNTAX_ERROR;
@@ -5325,7 +5338,6 @@ static int jim_target_number(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
 
 	/* It's OK to remove this mechanism sometime after August 2010 or so */
-	LOG_WARNING("don't use numbers as target identifiers; use names");
 	if (goi.argc != 1) {
 		Jim_SetResultFormatted(goi.interp, "usage: target number <number>");
 		return JIM_ERR;
@@ -5988,7 +6000,7 @@ static const struct command_registration target_exec_command_handlers[] = {
 		.handler = handle_wp_command,
 		.mode = COMMAND_EXEC,
 		.help = "list (no params) or create watchpoints",
-		.usage = "[address length [('r'|'w'|'a') value [mask]]]",
+		.usage = "[address length [('r'|'w'|'a'|'i') value [mask]]]",
 	},
 	{
 		.name = "rwp",
@@ -6017,6 +6029,12 @@ static const struct command_registration target_exec_command_handlers[] = {
 		.usage = "filename [offset [type]]",
 	},
 	{
+		.name = "verify_image_offset",
+		.handler = handle_verify_image_offset_command,
+		.mode = COMMAND_EXEC,
+		.usage = "filename [offset [section_offset]]",
+	},
+	{
 		.name = "test_image",
 		.handler = handle_test_image_command,
 		.mode = COMMAND_EXEC,
diff --git a/src/target/target_type.h b/src/target/target_type.h
index cf3c864..ab5bb2a 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -29,7 +29,11 @@
 
 #include <jim-nvp.h>
 
+/*
+ * Prevent from compiler warning on typedef scoping to target_type
+ */
 struct target;
+struct reg;
 
 /**
  * This holds methods shared between all instances of a given target
@@ -60,7 +64,8 @@ struct target_type {
 	int (*step)(struct target *target, int current, uint32_t address,
 			int handle_breakpoints);
 
-	/* target reset control. assert reset can be invoked when OpenOCD and
+	/**
+	 * target reset control. assert reset can be invoked when OpenOCD and
 	 * the target is out of sync.
 	 *
 	 * A typical example is that the target was power cycled while OpenOCD
diff --git a/src/target/x86_32_common.c b/src/target/x86_32_common.c
new file mode 100644
index 0000000..433b606
--- /dev/null
+++ b/src/target/x86_32_common.c
@@ -0,0 +1,1899 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * Adrian Burns (adrian.burns@intel.com)
+ * Thomas Faust (thomas.faust@intel.com)
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Julien Carreno (julien.carreno@intel.com)
+ * Jeffrey Maxwell (jeffrey.r.maxwell@intel.com)
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * This implements generic x86 32 bit memory and breakpoint operations.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/log.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "register.h"
+#include "breakpoints.h"
+#include "x86_32_common.h"
+
+static int set_debug_ext_reg(struct target *t);
+static int set_debug_regs(struct target *t, uint32_t address,
+			uint8_t bp_num, uint8_t bp_type, uint8_t bp_length);
+static int unset_debug_regs(struct target *t, uint8_t bp_num);
+static int read_mem(struct target *t, uint32_t size,
+			uint32_t addr, uint8_t *buf);
+static int write_mem(struct target *t, uint32_t size,
+			uint32_t addr, const uint8_t *buf);
+static int calcaddr_pyhsfromlin(struct target *t, uint32_t addr,
+			uint32_t *physaddr);
+static int read_phys_mem(struct target *t, uint32_t phys_address,
+			uint32_t size, uint32_t count, uint8_t *buffer);
+static int write_phys_mem(struct target *t, uint32_t phys_address,
+			uint32_t size, uint32_t count, const uint8_t *buffer);
+static int set_breakpoint(struct target *target,
+			struct breakpoint *breakpoint);
+static int unset_breakpoint(struct target *target,
+			struct breakpoint *breakpoint);
+static int set_watchpoint(struct target *target,
+			struct watchpoint *watchpoint);
+static int unset_watchpoint(struct target *target,
+			struct watchpoint *watchpoint);
+static int read_hw_reg_to_cache(struct target *t, int num);
+static int write_hw_reg_from_cache(struct target *t, int num);
+
+int x86_32_get_gdb_reg_list(struct target *t,
+			struct reg **reg_list[], int *reg_list_size,
+			enum target_register_class reg_class)
+{
+
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	int i;
+	*reg_list_size = x86_32->cache->num_regs;
+	LOG_DEBUG("num_regs=%d, reg_class=%d", (*reg_list_size), reg_class);
+	*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
+	if (*reg_list == NULL) {
+		LOG_ERROR("%s out of memory", __func__);
+		return ERROR_FAIL;
+	}
+	/* this will copy the values from our reg list to gdbs */
+	for (i = 0; i < (*reg_list_size); i++) {
+		(*reg_list)[i] = &x86_32->cache->reg_list[i];
+		LOG_DEBUG("value %s = %08" PRIx32, x86_32->cache->reg_list[i].name,
+				buf_get_u32(x86_32->cache->reg_list[i].value, 0, 32));
+	}
+	return ERROR_OK;
+}
+
+int x86_32_common_init_arch_info(struct target *t, struct x86_32_common *x86_32)
+{
+	t->arch_info = x86_32;
+	x86_32->common_magic = X86_32_COMMON_MAGIC;
+	x86_32->num_hw_bpoints = MAX_DEBUG_REGS;
+	x86_32->hw_break_list = calloc(x86_32->num_hw_bpoints,
+				sizeof(struct x86_32_dbg_reg));
+	if (x86_32->hw_break_list == NULL) {
+		LOG_ERROR("%s out of memory", __func__);
+		return ERROR_FAIL;
+	}
+	x86_32->curr_tap = t->tap;
+	x86_32->fast_data_area = NULL;
+	x86_32->flush = 1;
+	x86_32->read_hw_reg_to_cache = read_hw_reg_to_cache;
+	x86_32->write_hw_reg_from_cache = write_hw_reg_from_cache;
+	return ERROR_OK;
+}
+
+int x86_32_common_mmu(struct target *t, int *enabled)
+{
+	*enabled = true;
+	return ERROR_OK;
+}
+
+int x86_32_common_virt2phys(struct target *t, uint32_t address, uint32_t *physical)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	/*
+	 * We need to ignore 'segmentation' for now, as OpenOCD can't handle
+	 * segmented addresses.
+	 * In protected mode that is almost OK, as (almost) any known OS is using
+	 * flat segmentation. In real mode we use use the base of the DS segment,
+	 * as we don't know better ...
+	 */
+
+	uint32_t cr0 = buf_get_u32(x86_32->cache->reg_list[CR0].value, 0, 32);
+	if (!(cr0 & CR0_PG)) {
+		/* target halted in real mode */
+		/* TODO: needs validation !!! */
+		uint32_t dsb = buf_get_u32(x86_32->cache->reg_list[DSB].value, 0, 32);
+		*physical = dsb + address;
+
+	} else {
+		/* target halted in protected mode */
+		if (calcaddr_pyhsfromlin(t, address, physical) != ERROR_OK) {
+			LOG_ERROR("%s failed to calculate physical address from 0x%08" PRIx32,
+					__func__, address);
+			return ERROR_FAIL;
+		}
+	}
+	return ERROR_OK;
+}
+
+int x86_32_common_read_phys_mem(struct target *t, uint32_t phys_address,
+			uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	int error;
+
+	error = read_phys_mem(t, phys_address, size, count, buffer);
+	if (error != ERROR_OK)
+		return error;
+
+	/* After reading memory from target, we must replace software breakpoints
+	 * with the original instructions again.
+	 */
+	if  (t->running_alg == 0) {
+		struct swbp_mem_patch *iter = x86_32->swbbp_mem_patch_list;
+		while (iter != NULL) {
+			if (iter->physaddr >= phys_address && iter->physaddr < phys_address + (size * count)) {
+				uint32_t offset = iter->physaddr - phys_address;
+				buffer[offset] = iter->orig_byte;
+			}
+			iter = iter->next;
+		}
+	}
+	return ERROR_OK;
+}
+
+static int read_phys_mem(struct target *t, uint32_t phys_address,
+			uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	int retval = ERROR_OK;
+	bool pg_disabled = false;
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+			phys_address, size, count, buffer);
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if (!count || !buffer) {
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+				__func__, count, buffer, phys_address);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	/* to access physical memory, switch off the CR0.PG bit */
+	if (x86_32->is_paging_enabled(t)) {
+		retval = x86_32->disable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not disable paging", __func__);
+			return retval;
+		}
+		pg_disabled = true;
+	}
+
+	for (uint32_t i = 0; i < count; i++) {
+		switch (size) {
+		case BYTE:
+			retval = read_mem(t, size, phys_address + i, buffer + i);
+			break;
+		case WORD:
+			retval = read_mem(t, size, phys_address + i * 2, buffer + i * 2);
+			break;
+		case DWORD:
+			retval = read_mem(t, size, phys_address + i * 4, buffer + i * 4);
+			break;
+		default:
+			LOG_ERROR("%s invalid read size", __func__);
+			break;
+		}
+	}
+	/* restore CR0.PG bit if needed (regardless of retval) */
+	if (pg_disabled) {
+		retval = x86_32->enable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not enable paging", __func__);
+			return retval;
+		}
+		pg_disabled = true;
+	}
+	/* TODO: After reading memory from target, we must replace
+	 * software breakpoints with the original instructions again.
+	 * Solve this with the breakpoint fix
+	 */
+	return retval;
+}
+
+int x86_32_common_write_phys_mem(struct target *t, uint32_t phys_address,
+			uint32_t size, uint32_t count, const uint8_t *buffer)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	int error = ERROR_OK;
+	uint8_t *newbuffer = NULL;
+
+	check_not_halted(t);
+	if (!count || !buffer || !phys_address) {
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+				__func__, count, buffer, phys_address);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+	/* Before writing memory to target, we must update software breakpoints
+	 * with the new instructions and patch the memory buffer with the
+	 * breakpoint instruction.
+	 */
+	newbuffer = malloc(size*count);
+	if (newbuffer == NULL) {
+		LOG_ERROR("%s out of memory", __func__);
+		return ERROR_FAIL;
+	}
+	memcpy(newbuffer, buffer, size*count);
+	struct swbp_mem_patch *iter = x86_32->swbbp_mem_patch_list;
+	while (iter != NULL) {
+		if (iter->physaddr >= phys_address && iter->physaddr < phys_address+(size*count)) {
+			uint32_t offset = iter->physaddr - phys_address;
+			newbuffer[offset] = SW_BP_OPCODE;
+
+			/* update the breakpoint */
+			struct breakpoint *pbiter = t->breakpoints;
+			while (pbiter != NULL && pbiter->unique_id != iter->swbp_unique_id)
+				pbiter = pbiter->next;
+			if (pbiter)
+				pbiter->orig_instr[0] = buffer[offset];
+		}
+		iter = iter->next;
+	}
+
+	error = write_phys_mem(t, phys_address, size, count, newbuffer);
+	free(newbuffer);
+	return error;
+}
+
+static int write_phys_mem(struct target *t, uint32_t phys_address,
+			uint32_t size, uint32_t count, const uint8_t *buffer)
+{
+	int retval = ERROR_OK;
+	bool pg_disabled = false;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+			phys_address, size, count, buffer);
+
+	check_not_halted(t);
+	if (!count || !buffer) {
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+				__func__, count, buffer, phys_address);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+	/* TODO: Before writing memory to target, we must update
+	 * software breakpoints with the new instructions and
+	 * patch the memory buffer with the breakpoint instruction.
+	 * Solve this with the breakpoint fix
+	 */
+
+	/* to access physical memory, switch off the CR0.PG bit */
+	if (x86_32->is_paging_enabled(t)) {
+		retval = x86_32->disable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not disable paging", __func__);
+			return retval;
+		}
+		pg_disabled = true;
+	}
+	for (uint32_t i = 0; i < count; i++) {
+		switch (size) {
+		case BYTE:
+			retval = write_mem(t, size, phys_address + i, buffer + i);
+			break;
+		case WORD:
+			retval = write_mem(t, size, phys_address + i * 2, buffer + i * 2);
+			break;
+		case DWORD:
+			retval = write_mem(t, size, phys_address + i * 4, buffer + i * 4);
+			break;
+		default:
+			LOG_DEBUG("invalid read size");
+			break;
+		}
+	}
+	/* restore CR0.PG bit if needed (regardless of retval) */
+	if (pg_disabled) {
+		retval = x86_32->enable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not enable paging", __func__);
+			return retval;
+		}
+	}
+	return retval;
+}
+
+static int read_mem(struct target *t, uint32_t size,
+			uint32_t addr, uint8_t *buf)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	/* if CS.D bit=1 then its a 32 bit code segment, else 16 */
+	bool use32 = (buf_get_u32(x86_32->cache->reg_list[CSAR].value, 0, 32)) & CSAR_D;
+
+	int retval = x86_32->write_hw_reg(t, EAX, addr, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error write EAX", __func__);
+		return retval;
+	}
+
+	switch (size) {
+		case BYTE:
+			if (use32)
+				retval = x86_32->submit_instruction(t, MEMRDB32);
+			else
+				retval = x86_32->submit_instruction(t, MEMRDB16);
+			break;
+		case WORD:
+			if (use32)
+				retval = x86_32->submit_instruction(t, MEMRDH32);
+			else
+				retval = x86_32->submit_instruction(t, MEMRDH16);
+			break;
+		case DWORD:
+			if (use32)
+				retval = x86_32->submit_instruction(t, MEMRDW32);
+			else
+				retval = x86_32->submit_instruction(t, MEMRDW16);
+			break;
+		default:
+			LOG_ERROR("%s invalid read mem size", __func__);
+			break;
+	}
+
+	/* read_hw_reg() will write to 4 bytes (uint32_t)
+	 * Watch out, the buffer passed into read_mem() might be 1 or 2 bytes.
+	 */
+	uint32_t regval = 0;
+	retval = x86_32->read_hw_reg(t, EDX, &regval, 0);
+
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error read EDX", __func__);
+		return retval;
+	}
+	for (uint8_t i = 0; i < size; i++)
+		buf[i] = (regval >> (i*8)) & 0x000000FF;
+
+	retval = x86_32->transaction_status(t);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error on mem read", __func__);
+		return retval;
+	}
+	return retval;
+}
+
+static int write_mem(struct target *t, uint32_t size,
+			uint32_t addr, const uint8_t *buf)
+{
+	uint32_t i = 0;
+	uint32_t buf4bytes = 0;
+	int retval = ERROR_OK;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	for (i = 0; i < size; ++i) {
+		buf4bytes = buf4bytes << 8; /* first time we only shift 0s */
+		buf4bytes += buf[(size-1)-i]; /* it was hard to write, should be hard to read! */
+	}
+	/* if CS.D bit=1 then its a 32 bit code segment, else 16 */
+	bool use32 = (buf_get_u32(x86_32->cache->reg_list[CSAR].value, 0, 32)) & CSAR_D;
+
+	retval = x86_32->write_hw_reg(t, EAX, addr, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error write EAX", __func__);
+		return retval;
+	}
+
+	/* write_hw_reg() will write to 4 bytes (uint32_t)
+	 * Watch out, the buffer passed into write_mem() might be 1 or 2 bytes.
+	 */
+	retval = x86_32->write_hw_reg(t, EDX, buf4bytes, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error write EDX", __func__);
+		return retval;
+	}
+	switch (size) {
+		case BYTE:
+			if (use32)
+				retval = x86_32->submit_instruction(t, MEMWRB32);
+			else
+				retval = x86_32->submit_instruction(t, MEMWRB16);
+			break;
+		case WORD:
+			if (use32)
+				retval = x86_32->submit_instruction(t, MEMWRH32);
+			else
+				retval = x86_32->submit_instruction(t, MEMWRH16);
+			break;
+		case DWORD:
+			if (use32)
+				retval = x86_32->submit_instruction(t, MEMWRW32);
+			else
+				retval = x86_32->submit_instruction(t, MEMWRW16);
+			break;
+		default:
+			LOG_ERROR("%s invalid write mem size", __func__);
+			return ERROR_FAIL;
+	}
+	retval = x86_32->transaction_status(t);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error on mem write", __func__);
+		return retval;
+	}
+	return retval;
+}
+
+int calcaddr_pyhsfromlin(struct target *t, uint32_t addr, uint32_t *physaddr)
+{
+	uint8_t entry_buffer[8];
+
+	if (physaddr == NULL || t == NULL)
+		return ERROR_FAIL;
+
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	/* The 'user-visible' CR0.PG should be set - otherwise the function shouldn't be called
+	 * (Don't check the CR0.PG on the target, this might be temporally disabled at this point)
+	 */
+	uint32_t cr0 = buf_get_u32(x86_32->cache->reg_list[CR0].value, 0, 32);
+	if (!(cr0 & CR0_PG)) {
+		/* you are wrong in this function, never mind */
+		*physaddr = addr;
+		return ERROR_OK;
+	}
+
+	uint32_t cr4 = buf_get_u32(x86_32->cache->reg_list[CR4].value, 0, 32);
+	bool isPAE = cr4 & 0x00000020; /* PAE - Physical Address Extension */
+
+	uint32_t cr3 = buf_get_u32(x86_32->cache->reg_list[CR3].value, 0, 32);
+	if (isPAE) {
+		uint32_t pdpt_base = cr3 & 0xFFFFF000; /* lower 12 bits of CR3 must always be 0 */
+		uint32_t pdpt_index = (addr & 0xC0000000) >> 30; /* A[31:30] index to PDPT */
+		uint32_t pdpt_addr = pdpt_base + (8 * pdpt_index);
+		if (x86_32_common_read_phys_mem(t, pdpt_addr, 4, 2, entry_buffer) != ERROR_OK) {
+			LOG_ERROR("%s couldn't read page directory pointer table entry at 0x%08" PRIx32,
+					__func__, pdpt_addr);
+			return ERROR_FAIL;
+		}
+		uint64_t pdpt_entry = target_buffer_get_u64(t, entry_buffer);
+		if (!(pdpt_entry & 0x0000000000000001)) {
+			LOG_ERROR("%s page directory pointer table entry at 0x%08" PRIx32 " is not present",
+					__func__, pdpt_addr);
+			return ERROR_FAIL;
+		}
+
+		uint32_t pd_base = pdpt_entry & 0xFFFFF000; /* A[31:12] is PageTable/Page Base Address */
+		uint32_t pd_index = (addr & 0x3FE00000) >> 21; /* A[29:21] index to PD entry with PAE */
+		uint32_t pd_addr = pd_base + (8 * pd_index);
+		if (x86_32_common_read_phys_mem(t, pd_addr, 4, 2, entry_buffer) != ERROR_OK) {
+			LOG_ERROR("%s couldn't read page directory entry at 0x%08" PRIx32,
+					__func__, pd_addr);
+			return ERROR_FAIL;
+		}
+		uint64_t pd_entry = target_buffer_get_u64(t, entry_buffer);
+		if (!(pd_entry & 0x0000000000000001)) {
+			LOG_ERROR("%s page directory entry at 0x%08" PRIx32 " is not present",
+					__func__, pd_addr);
+			return ERROR_FAIL;
+		}
+
+		/* PS bit in PD entry is indicating 4KB or 2MB page size */
+		if (pd_entry & 0x0000000000000080) {
+
+			uint32_t page_base = (uint32_t)(pd_entry & 0x00000000FFE00000); /* [31:21] */
+			uint32_t offset = addr & 0x001FFFFF; /* [20:0] */
+			*physaddr = page_base + offset;
+			return ERROR_OK;
+
+		} else {
+
+			uint32_t pt_base = (uint32_t)(pd_entry & 0x00000000FFFFF000); /*[31:12]*/
+			uint32_t pt_index = (addr & 0x001FF000) >> 12; /*[20:12]*/
+			uint32_t pt_addr = pt_base + (8 * pt_index);
+			if (x86_32_common_read_phys_mem(t, pt_addr, 4, 2, entry_buffer) != ERROR_OK) {
+				LOG_ERROR("%s couldn't read page table entry at 0x%08" PRIx32, __func__, pt_addr);
+				return ERROR_FAIL;
+			}
+			uint64_t pt_entry = target_buffer_get_u64(t, entry_buffer);
+			if (!(pt_entry & 0x0000000000000001)) {
+				LOG_ERROR("%s page table entry at 0x%08" PRIx32 " is not present", __func__, pt_addr);
+				return ERROR_FAIL;
+			}
+
+			uint32_t page_base = (uint32_t)(pt_entry & 0x00000000FFFFF000); /*[31:12]*/
+			uint32_t offset =  addr & 0x00000FFF; /*[11:0]*/
+			*physaddr = page_base + offset;
+			return ERROR_OK;
+		}
+	} else {
+		uint32_t pd_base = cr3 & 0xFFFFF000; /* lower 12 bits of CR3 must always be 0 */
+		uint32_t pd_index = (addr & 0xFFC00000) >> 22; /* A[31:22] index to PD entry */
+		uint32_t pd_addr = pd_base + (4 * pd_index);
+		if (x86_32_common_read_phys_mem(t, pd_addr, 4, 1, entry_buffer) != ERROR_OK) {
+			LOG_ERROR("%s couldn't read page directory entry at 0x%08" PRIx32, __func__, pd_addr);
+			return ERROR_FAIL;
+		}
+		uint32_t pd_entry = target_buffer_get_u32(t, entry_buffer);
+		if (!(pd_entry & 0x00000001)) {
+			LOG_ERROR("%s page directory entry at 0x%08" PRIx32 " is not present", __func__, pd_addr);
+			return ERROR_FAIL;
+		}
+
+		/* Bit 7 in page directory entry is page size.
+		 */
+		if (pd_entry & 0x00000080) {
+			/* 4MB pages */
+			uint32_t page_base = pd_entry & 0xFFC00000;
+			*physaddr = page_base + (addr & 0x003FFFFF);
+
+		} else {
+			/* 4KB pages */
+			uint32_t pt_base = pd_entry & 0xFFFFF000; /* A[31:12] is PageTable/Page Base Address */
+			uint32_t pt_index = (addr & 0x003FF000) >> 12; /* A[21:12] index to page table entry */
+			uint32_t pt_addr = pt_base + (4 * pt_index);
+			if (x86_32_common_read_phys_mem(t, pt_addr, 4, 1, entry_buffer) != ERROR_OK) {
+				LOG_ERROR("%s couldn't read page table entry at 0x%08" PRIx32, __func__, pt_addr);
+				return ERROR_FAIL;
+			}
+			uint32_t pt_entry = target_buffer_get_u32(t, entry_buffer);
+			if (!(pt_entry & 0x00000001)) {
+				LOG_ERROR("%s page table entry at 0x%08" PRIx32 " is not present", __func__, pt_addr);
+				return ERROR_FAIL;
+			}
+			uint32_t page_base = pt_entry & 0xFFFFF000; /* A[31:12] is PageTable/Page Base Address */
+			*physaddr = page_base + (addr & 0x00000FFF); /* A[11:0] offset to 4KB page in linear address */
+		}
+	}
+	return ERROR_OK;
+}
+
+int x86_32_common_read_memory(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, uint8_t *buf)
+{
+	int retval = ERROR_OK;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+			addr, size, count, buf);
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if (!count || !buf) {
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+				__func__, count, buf, addr);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	if (x86_32->is_paging_enabled(t)) {
+		/* all memory accesses from debugger must be physical (CR0.PG == 0)
+		 * conversion to physical address space needed
+		 */
+		retval = x86_32->disable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not disable paging", __func__);
+			return retval;
+		}
+		uint32_t physaddr = 0;
+		if (calcaddr_pyhsfromlin(t, addr, &physaddr) != ERROR_OK) {
+			LOG_ERROR("%s failed to calculate physical address from 0x%08" PRIx32, __func__, addr);
+			retval = ERROR_FAIL;
+		}
+		/* TODO: !!! Watch out for page boundaries
+		 * for every 4kB, the physical address has to be re-calculated
+		 * This should be fixed together with bulk memory reads
+		 */
+
+		if (retval == ERROR_OK
+			&& x86_32_common_read_phys_mem(t, physaddr, size, count, buf) != ERROR_OK) {
+			LOG_ERROR("%s failed to read memory from physical address 0x%08" PRIx32, __func__, physaddr);
+			retval = ERROR_FAIL;
+		}
+		/* restore PG bit if it was cleared prior (regardless of retval) */
+		retval = x86_32->enable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not enable paging", __func__);
+			return retval;
+		}
+	} else {
+		/* paging is off - linear address is physical address */
+		if (x86_32_common_read_phys_mem(t, addr, size, count, buf) != ERROR_OK) {
+			LOG_ERROR("%s failed to read memory from address 0%08" PRIx32, __func__, addr);
+			retval = ERROR_FAIL;
+		}
+	}
+
+	return retval;
+}
+
+int x86_32_common_write_memory(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, const uint8_t *buf)
+{
+	int retval = ERROR_OK;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+			addr, size, count, buf);
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if (!count || !buf) {
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+					__func__, count, buf, addr);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	if (x86_32->is_paging_enabled(t)) {
+		/* all memory accesses from debugger must be physical (CR0.PG == 0)
+		 * conversion to physical address space needed
+		 */
+		retval = x86_32->disable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not disable paging", __func__);
+			return retval;
+		}
+		uint32_t physaddr = 0;
+		if (calcaddr_pyhsfromlin(t, addr, &physaddr) != ERROR_OK) {
+			LOG_ERROR("%s failed to calculate physical address from 0x%08" PRIx32,
+					__func__, addr);
+			retval = ERROR_FAIL;
+		}
+		/* TODO: !!! Watch out for page boundaries
+		 * for every 4kB, the physical address has to be re-calculated
+		 * This should be fixed together with bulk memory reads
+		 */
+		if (retval == ERROR_OK
+			&& x86_32_common_write_phys_mem(t, physaddr, size, count, buf) != ERROR_OK) {
+			LOG_ERROR("%s failed to write memory to physical address 0x%08" PRIx32,
+					__func__, physaddr);
+			retval = ERROR_FAIL;
+		}
+		/* restore PG bit if it was cleared prior (regardless of retval) */
+		retval = x86_32->enable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not enable paging", __func__);
+			return retval;
+		}
+	} else {
+
+		/* paging is off - linear address is physical address */
+		if (x86_32_common_write_phys_mem(t, addr, size, count, buf) != ERROR_OK) {
+			LOG_ERROR("%s failed to write memory to address 0x%08" PRIx32,
+					__func__, addr);
+			retval = ERROR_FAIL;
+		}
+	}
+	return retval;
+}
+
+int x86_32_common_read_io(struct target *t, uint32_t addr,
+			uint32_t size, uint8_t *buf)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	/* if CS.D bit=1 then its a 32 bit code segment, else 16 */
+	bool use32 = (buf_get_u32(x86_32->cache->reg_list[CSAR].value, 0, 32)) & CSAR_D;
+	int retval = ERROR_FAIL;
+	bool pg_disabled = false;
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", buf=%p", addr, size, buf);
+	check_not_halted(t);
+	if (!buf || !addr) {
+		LOG_ERROR("%s invalid params buf=%p, addr=%08" PRIx32, __func__, buf, addr);
+		return retval;
+	}
+	retval = x86_32->write_hw_reg(t, EDX, addr, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error EDX write", __func__);
+		return retval;
+	}
+	/* to access physical memory, switch off the CR0.PG bit */
+	if (x86_32->is_paging_enabled(t)) {
+		retval = x86_32->disable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not disable paging", __func__);
+			return retval;
+		}
+		pg_disabled = true;
+	}
+	switch (size) {
+		case BYTE:
+			if (use32)
+				retval = x86_32->submit_instruction(t, IORDB32);
+			else
+				retval = x86_32->submit_instruction(t, IORDB16);
+			break;
+		case WORD:
+			if (use32)
+				retval = x86_32->submit_instruction(t, IORDH32);
+			else
+				retval = x86_32->submit_instruction(t, IORDH16);
+			break;
+		case DWORD:
+			if (use32)
+				retval = x86_32->submit_instruction(t, IORDW32);
+			else
+				retval = x86_32->submit_instruction(t, IORDW16);
+			break;
+		default:
+			LOG_ERROR("%s invalid read io size", __func__);
+			return ERROR_FAIL;
+	}
+	/* restore CR0.PG bit if needed */
+	if (pg_disabled) {
+		retval = x86_32->enable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not enable paging", __func__);
+			return retval;
+		}
+		pg_disabled = false;
+	}
+	uint32_t regval = 0;
+	retval = x86_32->read_hw_reg(t, EAX, &regval, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error on read EAX", __func__);
+		return retval;
+	}
+	for (uint8_t i = 0; i < size; i++)
+		buf[i] = (regval >> (i*8)) & 0x000000FF;
+	retval = x86_32->transaction_status(t);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error on io read", __func__);
+		return retval;
+	}
+	return retval;
+}
+
+int x86_32_common_write_io(struct target *t, uint32_t addr,
+			uint32_t size, const uint8_t *buf)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	/* if CS.D bit=1 then its a 32 bit code segment, else 16 */
+	bool use32 = (buf_get_u32(x86_32->cache->reg_list[CSAR].value, 0, 32)) & CSAR_D;
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", buf=%p", addr, size, buf);
+	check_not_halted(t);
+	int retval = ERROR_FAIL;
+	bool pg_disabled = false;
+	if (!buf || !addr) {
+		LOG_ERROR("%s invalid params buf=%p, addr=0x%08" PRIx32, __func__, buf, addr);
+		return retval;
+	}
+	/* no do the write */
+	retval = x86_32->write_hw_reg(t, EDX, addr, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error on EDX write", __func__);
+		return retval;
+	}
+	uint32_t regval = 0;
+	for (uint8_t i = 0; i < size; i++)
+		regval += (buf[i] << (i*8));
+	retval = x86_32->write_hw_reg(t, EAX, regval, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error on EAX write", __func__);
+		return retval;
+	}
+	/* to access physical memory, switch off the CR0.PG bit */
+	if (x86_32->is_paging_enabled(t)) {
+		retval = x86_32->disable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not disable paging", __func__);
+			return retval;
+		}
+		pg_disabled = true;
+	}
+	switch (size) {
+		case BYTE:
+			if (use32)
+				retval = x86_32->submit_instruction(t, IOWRB32);
+			else
+				retval = x86_32->submit_instruction(t, IOWRB16);
+			break;
+		case WORD:
+			if (use32)
+				retval = x86_32->submit_instruction(t, IOWRH32);
+			else
+				retval = x86_32->submit_instruction(t, IOWRH16);
+			break;
+		case DWORD:
+			if (use32)
+				retval = x86_32->submit_instruction(t, IOWRW32);
+			else
+				retval = x86_32->submit_instruction(t, IOWRW16);
+			break;
+		default:
+			LOG_ERROR("%s invalid write io size", __func__);
+			return ERROR_FAIL;
+	}
+	/* restore CR0.PG bit if needed */
+	if (pg_disabled) {
+		retval = x86_32->enable_paging(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not enable paging", __func__);
+			return retval;
+		}
+		pg_disabled = false;
+	}
+	retval = x86_32->transaction_status(t);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error on io write", __func__);
+		return retval;
+	}
+	return retval;
+}
+
+int x86_32_common_add_watchpoint(struct target *t, struct watchpoint *wp)
+{
+	check_not_halted(t);
+	/* set_watchpoint() will return ERROR_TARGET_RESOURCE_NOT_AVAILABLE if all
+	 * hardware registers are gone
+	 */
+	return set_watchpoint(t, wp);
+}
+
+int x86_32_common_remove_watchpoint(struct target *t, struct watchpoint *wp)
+{
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if (wp->set)
+		unset_watchpoint(t, wp);
+	return ERROR_OK;
+}
+
+int x86_32_common_add_breakpoint(struct target *t, struct breakpoint *bp)
+{
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	/* set_breakpoint() will return ERROR_TARGET_RESOURCE_NOT_AVAILABLE if all
+	 * hardware registers are gone (for hardware breakpoints)
+	 */
+	return set_breakpoint(t, bp);
+}
+
+int x86_32_common_remove_breakpoint(struct target *t, struct breakpoint *bp)
+{
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if (bp->set)
+		unset_breakpoint(t, bp);
+
+	return ERROR_OK;
+}
+
+static int set_debug_ext_reg(struct target *t)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	uint32_t cr4 = buf_get_u32(x86_32->cache->reg_list[CR4].value, 0, 32);
+
+	if (cr4 & 0x8) {
+		LOG_DEBUG("%s register CR4.DR already set, val=%08" PRIx32, __func__, cr4);
+	} else {
+		/* update regs in the reg cache ready to be written to hardware
+		 * when we exit PM
+		 */
+		buf_set_u32(x86_32->cache->reg_list[CR4].value, 0, 32, cr4|=0x8);
+		x86_32->cache->reg_list[CR4].dirty = 1;
+		x86_32->cache->reg_list[CR4].valid = 1;
+		LOG_DEBUG("%s setting register CR4.DR, val=%08" PRIx32, __func__, cr4);
+	}
+
+	return ERROR_OK;
+}
+
+static int set_debug_regs(struct target *t, uint32_t address,
+			uint8_t bp_num, uint8_t bp_type, uint8_t bp_length)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	LOG_DEBUG("addr=0x%08" PRIx32 ", bp_num=%" PRIu8 ", bp_type=%" PRIu8 ", pb_length=%" PRIu8,
+			address, bp_num, bp_type, bp_length);
+
+	/* DR7 - set global enable */
+	uint32_t dr7 = buf_get_u32(x86_32->cache->reg_list[DR7].value, 0, 32);
+
+	if (bp_length != 1 && bp_length != 2 && bp_length != 4)
+		return ERROR_FAIL;
+
+	if (DR7_BP_FREE(dr7, bp_num))
+		DR7_GLOBAL_ENABLE(dr7, bp_num);
+	else {
+		LOG_ERROR("%s dr7 error, already enabled, val=%08" PRIx32, __func__, dr7);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	switch (bp_type) {
+		case 0:
+			/* 00 - only on instruction execution */
+			DR7_SET_EXE(dr7, bp_num);
+			DR7_SET_LENGTH(dr7, bp_num, bp_length);
+		break;
+		case 1:
+			/* 01 - only on data writes */
+			DR7_SET_WRITE(dr7, bp_num);
+			DR7_SET_LENGTH(dr7, bp_num, bp_length);
+		break;
+		case 2:
+			/* 10 - on I/O read or write */
+			DR7_SET_IO(dr7, bp_num);
+			DR7_SET_LENGTH(dr7, bp_num, bp_length);
+		break;
+		case 3:
+			/* on data read or data write */
+			DR7_SET_ACCESS(dr7, bp_num);
+			DR7_SET_LENGTH(dr7, bp_num, bp_length);
+		break;
+		default:
+			LOG_ERROR("%s invalid request [only 0-3] bp_type=%d", __func__, bp_type);
+			return ERROR_FAIL;
+	}
+
+	/* update regs in the reg cache ready to be written to hardware
+	 * when we exit PM
+	 */
+	buf_set_u32(x86_32->cache->reg_list[bp_num+DR0].value, 0, 32, address);
+	x86_32->cache->reg_list[bp_num+DR0].dirty = 1;
+	x86_32->cache->reg_list[bp_num+DR0].valid = 1;
+	buf_set_u32(x86_32->cache->reg_list[DR6].value, 0, 32, PM_DR6);
+	x86_32->cache->reg_list[DR6].dirty = 1;
+	x86_32->cache->reg_list[DR6].valid = 1;
+	buf_set_u32(x86_32->cache->reg_list[DR7].value, 0, 32, dr7);
+	x86_32->cache->reg_list[DR7].dirty = 1;
+	x86_32->cache->reg_list[DR7].valid = 1;
+	return ERROR_OK;
+}
+
+static int unset_debug_regs(struct target *t, uint8_t bp_num)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	LOG_DEBUG("bp_num=%" PRIu8, bp_num);
+
+	uint32_t dr7 = buf_get_u32(x86_32->cache->reg_list[DR7].value, 0, 32);
+
+	if (!(DR7_BP_FREE(dr7, bp_num))) {
+		DR7_GLOBAL_DISABLE(dr7, bp_num);
+	} else {
+		LOG_ERROR("%s dr7 error, not enabled, val=0x%08" PRIx32, __func__, dr7);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+	/* this will clear rw and len bits */
+	DR7_RESET_RWLEN_BITS(dr7, bp_num);
+
+	/* update regs in the reg cache ready to be written to hardware
+	 * when we exit PM
+	 */
+	buf_set_u32(x86_32->cache->reg_list[bp_num+DR0].value, 0, 32, 0);
+	x86_32->cache->reg_list[bp_num+DR0].dirty = 1;
+	x86_32->cache->reg_list[bp_num+DR0].valid = 1;
+	buf_set_u32(x86_32->cache->reg_list[DR6].value, 0, 32, PM_DR6);
+	x86_32->cache->reg_list[DR6].dirty = 1;
+	x86_32->cache->reg_list[DR6].valid = 1;
+	buf_set_u32(x86_32->cache->reg_list[DR7].value, 0, 32, dr7);
+	x86_32->cache->reg_list[DR7].dirty = 1;
+	x86_32->cache->reg_list[DR7].valid = 1;
+	return ERROR_OK;
+}
+
+static int set_hwbp(struct target *t, struct breakpoint *bp)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
+	uint8_t hwbp_num = 0;
+
+	while (debug_reg_list[hwbp_num].used && (hwbp_num < x86_32->num_hw_bpoints))
+		hwbp_num++;
+	if (hwbp_num >= x86_32->num_hw_bpoints) {
+		LOG_ERROR("%s no free hw breakpoint bpid=0x%" PRIx32, __func__, bp->unique_id);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+	if (set_debug_regs(t, bp->address, hwbp_num, DR7_BP_EXECUTE, 1) != ERROR_OK)
+		return ERROR_FAIL;
+	bp->set = hwbp_num + 1;
+	debug_reg_list[hwbp_num].used = 1;
+	debug_reg_list[hwbp_num].bp_value = bp->address;
+	LOG_USER("%s hardware breakpoint %" PRIu32 " set at 0x%08" PRIx32 " (hwreg=%" PRIu8 ")", __func__,
+			bp->unique_id, debug_reg_list[hwbp_num].bp_value, hwbp_num);
+	return ERROR_OK;
+}
+
+static int unset_hwbp(struct target *t, struct breakpoint *bp)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
+	int hwbp_num = bp->set - 1;
+
+	if ((hwbp_num < 0) || (hwbp_num >= x86_32->num_hw_bpoints)) {
+		LOG_ERROR("%s invalid breakpoint number=%d, bpid=%" PRIu32,
+				__func__, hwbp_num, bp->unique_id);
+		return ERROR_OK;
+	}
+
+	if (unset_debug_regs(t, hwbp_num) != ERROR_OK)
+		return ERROR_FAIL;
+	debug_reg_list[hwbp_num].used = 0;
+	debug_reg_list[hwbp_num].bp_value = 0;
+
+	LOG_USER("%s hardware breakpoint %" PRIu32 " removed from 0x%08" PRIx32 " (hwreg=%d)",
+			__func__, bp->unique_id, bp->address, hwbp_num);
+	return ERROR_OK;
+}
+
+static int set_swbp(struct target *t, struct breakpoint *bp)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	LOG_DEBUG("id %" PRIx32, bp->unique_id);
+	uint32_t physaddr;
+	uint8_t opcode = SW_BP_OPCODE;
+	uint8_t readback;
+
+	if (calcaddr_pyhsfromlin(t, bp->address, &physaddr) != ERROR_OK)
+		return ERROR_FAIL;
+	if (read_phys_mem(t, physaddr, 1, 1, bp->orig_instr))
+		return ERROR_FAIL;
+
+	LOG_DEBUG("set software breakpoint - orig byte=0x%02" PRIx8 "", *bp->orig_instr);
+
+	/* just write the instruction trap byte */
+	t->running_alg = 1;
+	if (target_write_memory(t, physaddr, 1, 1, &opcode))
+		return ERROR_FAIL;
+	t->running_alg = 0;
+
+	/* verify that this is not invalid/read-only memory */
+	if (read_phys_mem(t, physaddr, 1, 1, &readback))
+		return ERROR_FAIL;
+
+	if (readback != SW_BP_OPCODE) {
+		LOG_ERROR("%s software breakpoint error at 0x%08" PRIx32 ", check memory",
+				__func__, bp->address);
+		LOG_ERROR("%s readback=0x%02" PRIx8 " orig=0x%02" PRIx8 "",
+				__func__, readback, *bp->orig_instr);
+		return ERROR_FAIL;
+	}
+	bp->set = SW_BP_OPCODE; /* just non 0 */
+
+	/* add the memory patch */
+	struct swbp_mem_patch *new_patch = malloc(sizeof(struct swbp_mem_patch));
+	if (new_patch == NULL) {
+		LOG_ERROR("%s out of memory", __func__);
+		return ERROR_FAIL;
+	}
+	new_patch->next = NULL;
+	new_patch->orig_byte = *bp->orig_instr;
+	new_patch->physaddr = physaddr;
+	new_patch->swbp_unique_id = bp->unique_id;
+
+	struct swbp_mem_patch *addto = x86_32->swbbp_mem_patch_list;
+	if (addto == NULL)
+		x86_32->swbbp_mem_patch_list = new_patch;
+	else {
+		while (addto->next != NULL)
+			addto = addto->next;
+		addto->next = new_patch;
+	}
+	LOG_USER("%s software breakpoint %" PRIu32 " set at 0x%08" PRIx32,
+			__func__, bp->unique_id, bp->address);
+	return ERROR_OK;
+}
+
+static int unset_swbp(struct target *t, struct breakpoint *bp)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	LOG_DEBUG("id %" PRIx32, bp->unique_id);
+	uint32_t physaddr;
+	uint8_t current_instr;
+
+	/* check that user program has not modified breakpoint instruction */
+	if (calcaddr_pyhsfromlin(t, bp->address, &physaddr) != ERROR_OK)
+		return ERROR_FAIL;
+	if (read_phys_mem(t, physaddr, 1, 1, &current_instr))
+		return ERROR_FAIL;
+
+	if (current_instr == SW_BP_OPCODE) {
+		t->running_alg = 1;
+		if (target_write_memory(t, physaddr, 1, 1, bp->orig_instr))
+			return ERROR_FAIL;
+		t->running_alg = 0;
+	} else {
+		LOG_ERROR("%s software breakpoint remove error at 0x%08" PRIx32 ", check memory",
+				__func__, bp->address);
+		LOG_ERROR("%s current=0x%02" PRIx8 " orig=0x%02" PRIx8 "",
+				__func__, current_instr, *bp->orig_instr);
+		return ERROR_FAIL;
+	}
+
+	/* remove from patch */
+	struct swbp_mem_patch *iter = x86_32->swbbp_mem_patch_list;
+	if (iter != NULL) {
+		if (iter->swbp_unique_id == bp->unique_id) {
+			/* it's the first item */
+			x86_32->swbbp_mem_patch_list = iter->next;
+			free(iter);
+		} else {
+			while (iter->next != NULL && iter->next->swbp_unique_id != bp->unique_id)
+				iter = iter->next;
+			if (iter->next != NULL) {
+				/* it's the next one */
+				struct swbp_mem_patch *freeme = iter->next;
+				iter->next = iter->next->next;
+				free(freeme);
+			}
+		}
+	}
+
+	LOG_USER("%s software breakpoint %" PRIu32 " removed from 0x%08" PRIx32,
+			__func__, bp->unique_id, bp->address);
+	return ERROR_OK;
+}
+
+static int set_breakpoint(struct target *t, struct breakpoint *bp)
+{
+	int error = ERROR_OK;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	if (bp->set) {
+		LOG_ERROR("breakpoint already set");
+		return error;
+	}
+	if (bp->type == BKPT_HARD) {
+		error = set_hwbp(t, bp);
+		if (error != ERROR_OK) {
+			LOG_ERROR("%s error setting hardware breakpoint at 0x%08" PRIx32,
+					__func__, bp->address);
+			return error;
+		}
+	} else {
+		if (x86_32->sw_bpts_supported(t)) {
+			error = set_swbp(t, bp);
+			if (error != ERROR_OK) {
+				LOG_ERROR("%s error setting software breakpoint at 0x%08" PRIx32,
+						__func__, bp->address);
+				return error;
+			}
+		} else {
+			LOG_ERROR("%s core doesn't support SW breakpoints", __func__);
+			error = ERROR_FAIL;
+			return ERROR_FAIL;
+		}
+	}
+	return error;
+}
+
+static int unset_breakpoint(struct target *t, struct breakpoint *bp)
+{
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	if (!bp->set) {
+		LOG_WARNING("breakpoint not set");
+		return ERROR_OK;
+	}
+
+	if (bp->type == BKPT_HARD) {
+		if (unset_hwbp(t, bp) != ERROR_OK) {
+			LOG_ERROR("%s error removing hardware breakpoint at 0x%08" PRIx32,
+					__func__, bp->address);
+			return ERROR_FAIL;
+		}
+	} else {
+		if (unset_swbp(t, bp) != ERROR_OK) {
+			LOG_ERROR("%s error removing software breakpoint at 0x%08" PRIx32,
+					__func__, bp->address);
+			return ERROR_FAIL;
+		}
+	}
+	bp->set = 0;
+	return ERROR_OK;
+}
+
+static int set_watchpoint(struct target *t, struct watchpoint *wp)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
+	int wp_num = 0;
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, wp->rw, wp->address);
+
+	if (wp->set) {
+		LOG_ERROR("%s watchpoint already set", __func__);
+		return ERROR_OK;
+	}
+
+	if (wp->rw == WPT_READ) {
+		LOG_ERROR("%s no support for 'read' watchpoints, use 'access', 'write' or 'io'"
+				, __func__);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	while (debug_reg_list[wp_num].used && (wp_num < x86_32->num_hw_bpoints))
+		wp_num++;
+	if (wp_num >= x86_32->num_hw_bpoints) {
+		LOG_ERROR("%s no debug registers left", __func__);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (wp->length != 4 && wp->length != 2 && wp->length != 1) {
+		LOG_ERROR("%s only watchpoints of length 1, 2 or 4 are supported", __func__);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	switch (wp->rw) {
+		case WPT_WRITE:
+			if (set_debug_regs(t, wp->address, wp_num,
+						DR7_BP_WRITE, wp->length) != ERROR_OK) {
+				return ERROR_FAIL;
+			}
+			break;
+		case WPT_ACCESS:
+			if (set_debug_regs(t, wp->address, wp_num, DR7_BP_READWRITE,
+						wp->length) != ERROR_OK) {
+				return ERROR_FAIL;
+			}
+			break;
+		case WPT_IO:
+			if (x86_32->io_bpts_supported(t)) {
+				set_debug_ext_reg(t);
+				if (set_debug_regs(t, wp->address, wp_num, DR7_RW_IO,
+							wp->length) != ERROR_OK) {
+					LOG_ERROR("%s error setting IO watchpoint at 0x%08" PRIx32,
+							__func__, wp->address);
+					return ERROR_FAIL;
+				}
+			} else {
+				LOG_ERROR("%s core doesn't support IO watchpoints", __func__);
+				return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+			}
+			break;
+		default:
+			LOG_ERROR("%s only 'access', 'write' or 'io' watchpoints are supported", __func__);
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+			break;
+	}
+	wp->set = wp_num + 1;
+	debug_reg_list[wp_num].used = 1;
+	debug_reg_list[wp_num].bp_value = wp->address;
+	LOG_USER("'%s' watchpoint %d set at 0x%08" PRIx32 " with length %" PRIu32 " (hwreg=%d)",
+			wp->rw == WPT_READ ? "read" : wp->rw == WPT_WRITE ?
+			"write" : wp->rw == WPT_ACCESS ? "access" : wp->rw == WPT_IO ?
+			"IO" : "?",
+			wp->unique_id, wp->address, wp->length, wp_num);
+	return ERROR_OK;
+}
+
+static int unset_watchpoint(struct target *t, struct watchpoint *wp)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, wp->rw, wp->address);
+	if (!wp->set) {
+		LOG_WARNING("watchpoint not set");
+		return ERROR_OK;
+	}
+
+	int wp_num = wp->set - 1;
+	if ((wp_num < 0) || (wp_num >= x86_32->num_hw_bpoints)) {
+		LOG_DEBUG("Invalid FP Comparator number in watchpoint");
+		return ERROR_OK;
+	}
+	if (unset_debug_regs(t, wp_num) != ERROR_OK)
+		return ERROR_FAIL;
+
+	debug_reg_list[wp_num].used = 0;
+	debug_reg_list[wp_num].bp_value = 0;
+	wp->set = 0;
+
+	LOG_USER("'%s' watchpoint %d removed from 0x%08" PRIx32 " with length %" PRIu32 " (hwreg=%d)",
+			wp->rw == WPT_READ ? "read" : wp->rw == WPT_WRITE ?
+			"write" : wp->rw == WPT_ACCESS ? "access" : wp->rw == WPT_IO ?
+			"IO" : "?",
+			wp->unique_id, wp->address, wp->length, wp_num);
+
+	return ERROR_OK;
+}
+
+/* after reset breakpoints and watchpoints in memory are not valid anymore and
+ * debug registers are cleared.
+ * we can't afford to remove sw breakpoints using the default methods as the
+ * memory doesn't have the same layout yet and an access might crash the target,
+ * so we just clear the openocd breakpoints structures.
+ */
+void x86_32_common_reset_breakpoints_watchpoints(struct target *t)
+{
+	struct breakpoint *next_b;
+	struct watchpoint *next_w;
+
+	while (t->breakpoints) {
+		next_b = t->breakpoints->next;
+		x86_32_common_remove_breakpoint(t, t->breakpoints);
+		free(t->breakpoints->orig_instr);
+		free(t->breakpoints);
+		t->breakpoints = next_b;
+	}
+	while (t->watchpoints) {
+		next_w = t->watchpoints->next;
+		x86_32_common_remove_watchpoint(t, t->watchpoints);
+		free(t->watchpoints);
+		t->watchpoints = next_w;
+	}
+}
+
+static int read_hw_reg_to_cache(struct target *t, int num)
+{
+	uint32_t reg_value;
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if ((num < 0) || (num >= x86_32->get_num_user_regs(t)))
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	if (x86_32->read_hw_reg(t, num, &reg_value, 1) != ERROR_OK) {
+		LOG_ERROR("%s fail for %s", x86_32->cache->reg_list[num].name, __func__);
+		return ERROR_FAIL;
+	}
+	LOG_DEBUG("reg %s value 0x%08" PRIx32,
+			x86_32->cache->reg_list[num].name, reg_value);
+	return ERROR_OK;
+}
+
+static int write_hw_reg_from_cache(struct target *t, int num)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if ((num < 0) || (num >= x86_32->get_num_user_regs(t)))
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	if (x86_32->write_hw_reg(t, num, 0, 1) != ERROR_OK) {
+		LOG_ERROR("%s fail for %s", x86_32->cache->reg_list[num].name, __func__);
+		return ERROR_FAIL;
+	}
+	LOG_DEBUG("reg %s value 0x%08" PRIx32, x86_32->cache->reg_list[num].name,
+			buf_get_u32(x86_32->cache->reg_list[num].value, 0, 32));
+	return ERROR_OK;
+}
+
+/* x86 32 commands */
+static void handle_iod_output(struct command_context *cmd_ctx,
+		struct target *target, uint32_t address, unsigned size,
+		unsigned count, const uint8_t *buffer)
+{
+	const unsigned line_bytecnt = 32;
+	unsigned line_modulo = line_bytecnt / size;
+
+	char output[line_bytecnt * 4 + 1];
+	unsigned output_len = 0;
+
+	const char *value_fmt;
+	switch (size) {
+	case 4:
+		value_fmt = "%8.8x ";
+		break;
+	case 2:
+		value_fmt = "%4.4x ";
+		break;
+	case 1:
+		value_fmt = "%2.2x ";
+		break;
+	default:
+		/* "can't happen", caller checked */
+		LOG_ERROR("%s invalid memory read size: %u", __func__, size);
+		return;
+	}
+
+	for (unsigned i = 0; i < count; i++) {
+		if (i % line_modulo == 0) {
+			output_len += snprintf(output + output_len,
+					sizeof(output) - output_len,
+					"0x%8.8x: ",
+					(unsigned)(address + (i*size)));
+		}
+
+		uint32_t value = 0;
+		const uint8_t *value_ptr = buffer + i * size;
+		switch (size) {
+		case 4:
+			value = target_buffer_get_u32(target, value_ptr);
+			break;
+		case 2:
+			value = target_buffer_get_u16(target, value_ptr);
+			break;
+		case 1:
+			value = *value_ptr;
+		}
+		output_len += snprintf(output + output_len,
+				sizeof(output) - output_len,
+				value_fmt, value);
+
+		if ((i % line_modulo == line_modulo - 1) || (i == count - 1)) {
+			command_print(cmd_ctx, "%s", output);
+			output_len = 0;
+		}
+	}
+}
+
+COMMAND_HANDLER(handle_iod_command)
+{
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	uint32_t address;
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	if (address > 0xffff) {
+		LOG_ERROR("%s IA-32 I/O space is 2^16, 0x%08" PRIx32 " exceeds max", __func__, address);
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	unsigned size = 0;
+	switch (CMD_NAME[2]) {
+	case 'w':
+		size = 4;
+		break;
+	case 'h':
+		size = 2;
+		break;
+	case 'b':
+		size = 1;
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	unsigned count = 1;
+	uint8_t *buffer = calloc(count, size);
+	struct target *target = get_current_target(CMD_CTX);
+	int retval = x86_32_common_read_io(target, address, size, buffer);
+	if (ERROR_OK == retval)
+		handle_iod_output(CMD_CTX, target, address, size, count, buffer);
+	free(buffer);
+	return retval;
+}
+
+static int target_fill_io(struct target *target,
+		uint32_t address,
+		unsigned data_size,
+		/* value */
+		uint32_t b)
+{
+	LOG_DEBUG("address=0x%08" PRIx32 ", data_size=%u, b=0x%08" PRIx32,
+			address, data_size, b);
+	uint8_t target_buf[data_size];
+	switch (data_size) {
+	case 4:
+		target_buffer_set_u32(target, target_buf, b);
+		break;
+	case 2:
+		target_buffer_set_u16(target, target_buf, b);
+		break;
+	case 1:
+		target_buf[0] = (b & 0x0ff);
+		break;
+	default:
+		exit(-1);
+	}
+	return x86_32_common_write_io(target, address, data_size, target_buf);
+}
+
+COMMAND_HANDLER(handle_iow_command)
+{
+	if (CMD_ARGC != 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	uint32_t address;
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	uint32_t value;
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
+	struct target *target = get_current_target(CMD_CTX);
+
+	unsigned wordsize;
+	switch (CMD_NAME[2]) {
+		case 'w':
+			wordsize = 4;
+			break;
+		case 'h':
+			wordsize = 2;
+			break;
+		case 'b':
+			wordsize = 1;
+			break;
+		default:
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	return target_fill_io(target, address, wordsize, value);
+}
+
+
+static int handle_msr_read(struct target *target, uint32_t address, uint64_t *value)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(target);
+	uint64_t msrval = 0;
+	uint32_t regval = 0;
+	int retval;
+
+	/* switch off the CR0.PG bit before rdmsr instruction */
+	bool pg_disabled = false;
+	if (x86_32->is_paging_enabled(target)) {
+		retval = x86_32->disable_paging(target);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not disable paging", __func__);
+			return retval;
+		}
+		pg_disabled = true;
+	}
+
+	/* write MSR index to ECX */
+	retval = x86_32->write_hw_reg(target, ECX, address, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error write ECX", __func__);
+		return retval;
+	}
+
+	/* submit 'rdmsr' instruction */
+	x86_32->flush = 0;
+	retval = x86_32->submit_instruction(target, RDMSR);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error submitting RDMSR", __func__);
+		return retval;
+	}
+
+	/*
+	 * read MSR value
+	 * EDX: MSR's 63:32 bits
+	 * EAX: MSR's 31:0 bits
+	 */
+	retval = x86_32->read_hw_reg(target, EDX, &regval, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error read EDX", __func__);
+		return retval;
+	}
+
+	msrval += ((uint64_t)regval << 32);
+	retval = x86_32->read_hw_reg(target, EAX, &regval, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error read EAX", __func__);
+		return retval;
+	}
+
+	msrval += regval;
+	*value = msrval;
+	LOG_USER("0x%08" PRIx32 " (/64): 0x%016" PRIx64, address, msrval);
+
+	/* restore CR0.PG bit if needed */
+	if (pg_disabled) {
+		retval = x86_32->enable_paging(target);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not enable paging", __func__);
+			return retval;
+		}
+	}
+
+	return retval;
+
+}
+
+static int handle_msr_write(struct target *target, uint32_t address, uint64_t value)
+{
+	struct x86_32_common *x86_32 = target_to_x86_32(target);
+	int retval;
+
+	/* switch off CR0.PG bit before 'wrmsr' instruction */
+	bool pg_disabled = false;
+	if (x86_32->is_paging_enabled(target)) {
+		retval = x86_32->disable_paging(target);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not disable paging", __func__);
+			return retval;
+		}
+		pg_disabled = true;
+	}
+
+	/* write MSR index to ECX */
+	retval = x86_32->write_hw_reg(target, ECX, address, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error write ECX", __func__);
+		return retval;
+	}
+
+	uint32_t low_bits  = (uint32_t)value;
+	uint32_t high_bits = ((uint32_t)(value >> 32));
+
+	/*
+	 * write MSR value
+	 * EDX: MSR's 63:32 bits
+	 * EAX: MSR's 31:0 bits
+	 */
+	retval = x86_32->write_hw_reg(target, EAX, low_bits, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error write EAX", __func__);
+		return retval;
+	}
+
+	retval = x86_32->write_hw_reg(target, EDX, high_bits, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error write EDX", __func__);
+		return retval;
+	}
+
+	/* submit 'wrmsr' instruction */
+	x86_32->flush = 0;
+	retval = x86_32->submit_instruction(target, WRMSR);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error submitting WRMSR", __func__);
+		return retval;
+	}
+
+	/* restore CR0.PG bit if needed */
+	if (pg_disabled) {
+		retval = x86_32->enable_paging(target);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not enable paging", __func__);
+			return retval;
+		}
+	}
+
+	/* final MSR value */
+	uint64_t readval;
+	retval  = handle_msr_read(target, address, &readval);
+	return retval;
+}
+
+static int handle_cpuid_read(struct target *target, uint32_t eax_leaf, uint32_t ecx_subleaf)
+{
+
+	struct x86_32_common *x86_32 = target_to_x86_32(target);
+	uint32_t r_eax, r_ebx, r_ecx, r_edx;
+	uint32_t r_eflags, rt_eflags;
+	int retval;
+
+	/* making sure that EFLAGS.ID[21] is changeable */
+	retval = x86_32->read_hw_reg(target, EFLAGS, &r_eflags, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error read EFLAGS", __func__);
+		return retval;
+	}
+
+	retval = x86_32->write_hw_reg(target, EFLAGS, r_eflags ^ EFLAGS_ID, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error setting eflags.id", __func__);
+		return retval;
+	}
+
+	retval = x86_32->read_hw_reg(target, EFLAGS, &rt_eflags, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error read EFLAGS", __func__);
+		return retval;
+	}
+
+	if (rt_eflags != (r_eflags ^ EFLAGS_ID)) {
+		LOG_ERROR("%s The HW is not capable to perform cpuid instruction."
+				" Bit EFLAGS.ID[21] is not changeable", __func__);
+		return ERROR_FAIL;
+	}
+
+	/* restoring EFLAGS.ID[21] value */
+	retval = x86_32->write_hw_reg(target, EFLAGS, r_eflags, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error setting eflags.id", __func__);
+		return retval;
+	}
+
+	/* switch off the CR0.PG bit before cpuid instruction */
+	bool pg_disabled = false;
+	if (x86_32->is_paging_enabled(target)) {
+		retval = x86_32->disable_paging(target);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not disable paging", __func__);
+			return retval;
+		}
+		pg_disabled = true;
+	}
+
+	/* set desired leaf in register EAX */
+	retval = x86_32->write_hw_reg(target, EAX, eax_leaf, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error setting eax_leaf register", __func__);
+		return retval;
+	}
+
+	/* set desired subleaf in register ECX */
+	retval = x86_32->write_hw_reg(target, ECX, ecx_subleaf, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error setting ecx_subleaf register", __func__);
+		return retval;
+	}
+
+	/* submit 'cpuid' instruction */
+	x86_32->flush = 0;
+	retval = x86_32->submit_instruction(target, CPUID);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error submitting CPUID", __func__);
+		return retval;
+	}
+
+	/* get information */
+	retval = x86_32->read_hw_reg(target, EAX, &r_eax, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error read EAX", __func__);
+		return retval;
+	}
+	LOG_USER("eax (/32): 0x%08" PRIx32 "", r_eax);
+
+	retval = x86_32->read_hw_reg(target, EBX, &r_ebx, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error read EBX", __func__);
+		return retval;
+	}
+	LOG_USER("ebx (/32): 0x%08" PRIx32 "", r_ebx);
+
+	retval = x86_32->read_hw_reg(target, ECX, &r_ecx, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error read ECX", __func__);
+		return retval;
+	}
+	LOG_USER("ecx (/32): 0x%08" PRIx32 "", r_ecx);
+
+	retval = x86_32->read_hw_reg(target, EDX, &r_edx, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s error read EDX", __func__);
+		return retval;
+	}
+	LOG_USER("edx (/32): 0x%08" PRIx32 "", r_edx);
+
+	/* restore CR0.PG bit if needed */
+	if (pg_disabled) {
+		retval = x86_32->enable_paging(target);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not enable paging", __func__);
+			return retval;
+		}
+	}
+
+	return ERROR_OK;
+
+}
+
+COMMAND_HANDLER(handle_msr_command)
+{
+
+	struct target *target = get_current_target(CMD_CTX);
+	uint32_t address;
+	uint64_t value;
+
+	/* TODO: Find a better way to find supported targets */
+	if ((strncmp(target_type_name(target), "quark", 5) != 0)) {
+		LOG_ERROR("Invalid target type - please select a x86_32 target");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	if (check_not_halted(target))
+		return ERROR_TARGET_NOT_HALTED;
+
+	switch (CMD_ARGC) {
+		case 1:
+			/* read msr */
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+			return handle_msr_read(target, address, &value);
+			break;
+		case 2:
+			/* write msr */
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+			COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], value);
+			return handle_msr_write(target, address, value);
+			break;
+		default:
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+}
+
+COMMAND_HANDLER(handle_cpuid_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	uint32_t eax_leaf, ecx_subleaf;
+
+	/* TODO: Find a better way to find supported targets */
+	if ((strncmp(target_type_name(target), "quark", 5) != 0)) {
+		LOG_ERROR("Invalid target type - please select a x86_32 target");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	switch (CMD_ARGC) {
+		case 1:
+			/* only eax_leaf */
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], eax_leaf);
+			return handle_cpuid_read(target, eax_leaf, 0);
+			break;
+		case 2:
+			/* eax_leaf + ecx_subleaf */
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], eax_leaf);
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], ecx_subleaf);
+			return handle_cpuid_read(target, eax_leaf, ecx_subleaf);
+			break;
+		default:
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+}
+
+static const struct command_registration x86_32_exec_command_handlers[] = {
+	{
+		.name = "iww",
+		.mode = COMMAND_EXEC,
+		.handler = handle_iow_command,
+		.help = "write I/O port word",
+		.usage = "port data[word]",
+	},
+	{
+		.name = "iwh",
+		.mode = COMMAND_EXEC,
+		.handler = handle_iow_command,
+		.help = "write I/O port halfword",
+		.usage = "port data[halfword]",
+	},
+	{
+		.name = "iwb",
+		.mode = COMMAND_EXEC,
+		.handler = handle_iow_command,
+		.help = "write I/O port byte",
+		.usage = "port data[byte]",
+	},
+	{
+		.name = "idw",
+		.mode = COMMAND_EXEC,
+		.handler = handle_iod_command,
+		.help = "display I/O port word",
+		.usage = "port",
+	},
+	{
+		.name = "idh",
+		.mode = COMMAND_EXEC,
+		.handler = handle_iod_command,
+		.help = "display I/O port halfword",
+		.usage = "port",
+	},
+	{
+		.name = "idb",
+		.mode = COMMAND_EXEC,
+		.handler = handle_iod_command,
+		.help = "display I/O port byte",
+		.usage = "port",
+	},
+	{
+		.name = "msr",
+		.mode = COMMAND_EXEC,
+		.handler = handle_msr_command,
+		.help = "read/write msr",
+		.usage = "opcode [value]",
+	},
+	{
+		.name = "cpuid",
+		.mode = COMMAND_EXEC,
+		.handler = handle_cpuid_command,
+		.help = "display cpuid information",
+		.usage = "eax_leaf [ecx_subleaf]",
+	},
+
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration x86_32_command_handlers[] = {
+	{
+		.name = "x86_32",
+		.mode = COMMAND_ANY,
+		.help = "x86_32 target commands",
+		.usage = "",
+		.chain = x86_32_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
diff --git a/src/target/x86_32_common.h b/src/target/x86_32_common.h
new file mode 100644
index 0000000..22e1afa
--- /dev/null
+++ b/src/target/x86_32_common.h
@@ -0,0 +1,341 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * Adrian Burns (adrian.burns@intel.com)
+ * Thomas Faust (thomas.faust@intel.com)
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Julien Carreno (julien.carreno@intel.com)
+ * Jeffrey Maxwell (jeffrey.r.maxwell@intel.com)
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * This is the interface to the x86 32 bit memory and breakpoint operations.
+ */
+
+#ifndef X86_32_COMMON_H
+#define X86_32_COMMON_H
+
+#include <jtag/jtag.h>
+#include <helper/command.h>
+#include <helper/types.h>
+
+extern const struct command_registration x86_32_command_handlers[];
+
+/* for memory access */
+#define BYTE			1
+#define WORD			2
+#define DWORD			4
+
+#define EFLAGS_TF		((uint32_t)0x00000100) /* Trap Flag */
+#define EFLAGS_IF		((uint32_t)0x00000200) /* Interrupt Flag */
+#define EFLAGS_RF		((uint32_t)0x00010000) /* Resume Flag */
+#define EFLAGS_VM86		((uint32_t)0x00020000) /* Virtual 8086 Mode */
+#define EFLAGS_ID		((uint32_t)0x00200000) /* CPUID  capable */
+
+#define CSAR_DPL		((uint32_t)0x00006000)
+#define CSAR_D			((uint32_t)0x00400000)
+#define SSAR_DPL		((uint32_t)0x00006000)
+
+#define CR0_PE			((uint32_t)0x00000001) /* Protected Mode Enable */
+#define CR0_NW			((uint32_t)0x20000000) /* Non Write-Through */
+#define CR0_CD			((uint32_t)0x40000000) /* Cache Disable */
+#define CR0_PG			((uint32_t)0x80000000) /* Paging Enable */
+
+/* TODO - move back to PM specific file */
+#define PM_DR6			((uint32_t)0xFFFF0FF0)
+
+#define DR6_BRKDETECT_0		((uint32_t)0x00000001) /* B0 through B3 */
+#define DR6_BRKDETECT_1		((uint32_t)0x00000002) /* breakpoint condition detected */
+#define DR6_BRKDETECT_2		((uint32_t)0x00000004)
+#define DR6_BRKDETECT_3		((uint32_t)0x00000008)
+
+enum {
+	/* general purpose registers */
+	EAX = 0,
+	ECX,
+	EDX,
+	EBX,
+	ESP,
+	EBP,
+	ESI,
+	EDI,
+	/* instruction pointer & flags */
+	EIP,
+	EFLAGS,
+
+	/* segment registers */
+	CS,
+	SS,
+	DS,
+	ES,
+	FS,
+	GS,
+
+	/* floating point unit registers */
+	ST0,
+	ST1,
+	ST2,
+	ST3,
+	ST4,
+	ST5,
+	ST6,
+	ST7,
+	FCTRL,
+	FSTAT,
+	FTAG,
+	FISEG,
+	FIOFF,
+	FOSEG,
+	FOOFF,
+	FOP,
+
+	/* control registers */
+	CR0,
+	CR2,
+	CR3,
+	CR4,
+
+	/* debug registers */
+	DR0,
+	DR1,
+	DR2,
+	DR3,
+	DR6,
+	DR7,
+
+	/* descriptor tables */
+	IDTB,
+	IDTL,
+	IDTAR,
+	GDTB,
+	GDTL,
+	GDTAR,
+	TR,
+	LDTR,
+	LDTB,
+	LDTL,
+	LDTAR,
+
+	/* segment registers */
+	CSB,
+	CSL,
+	CSAR,
+	DSB,
+	DSL,
+	DSAR,
+	ESB,
+	ESL,
+	ESAR,
+	FSB,
+	FSL,
+	FSAR,
+	GSB,
+	GSL,
+	GSAR,
+	SSB,
+	SSL,
+	SSAR,
+	TSSB,
+	TSSL,
+	TSSAR,
+
+	/* PM control reg */
+	PMCR,
+};
+
+#define X86_32_COMMON_MAGIC 0x86328632
+
+enum {
+	/* memory read/write */
+	MEMRDB32 = 0,
+	MEMRDB16,
+	MEMRDH32,
+	MEMRDH16,
+	MEMRDW32,
+	MEMRDW16,
+	MEMWRB32,
+	MEMWRB16,
+	MEMWRH32,
+	MEMWRH16,
+	MEMWRW32,
+	MEMWRW16,
+	/* IO read/write */
+	IORDB32,
+	IORDB16,
+	IORDH32,
+	IORDH16,
+	IORDW32,
+	IORDW16,
+	IOWRB32,
+	IOWRB16,
+	IOWRH32,
+	IOWRH16,
+	IOWRW32,
+	IOWRW16,
+	/* lakemont1 core shadow ram access opcodes */
+	SRAMACCESS,
+	SRAM2PDR,
+	PDR2SRAM,
+	WBINVD,
+	/* Model Specific Registers */
+	RDMSR,
+	WRMSR,
+	CPUID,
+};
+
+enum x86_core_type {
+	LMT1,
+	LMT3_5
+};
+
+struct swbp_mem_patch {
+	uint8_t orig_byte;
+	uint32_t swbp_unique_id;
+	uint32_t physaddr;
+	struct swbp_mem_patch *next;
+};
+
+/* TODO - probemode specific - consider removing */
+#define NUM_PM_REGS		18 /* regs used in save/restore */
+
+struct x86_32_common {
+	uint32_t common_magic;
+	void *arch_info;
+	enum x86_core_type core_type;
+	struct reg_cache *cache;
+	struct jtag_tap *curr_tap;
+	uint32_t stored_pc;
+	int flush;
+
+	/* pm_regs are for probemode save/restore state */
+	uint32_t pm_regs[NUM_PM_REGS];
+
+	/* working area for fastdata access */
+	struct working_area *fast_data_area;
+
+	int num_hw_bpoints;
+	struct x86_32_dbg_reg *hw_break_list;
+	struct swbp_mem_patch *swbbp_mem_patch_list;
+
+	/* core probemode implementation dependent functions */
+	uint8_t (*get_num_user_regs)(struct target *t);
+	bool (*is_paging_enabled)(struct target *t);
+	int (*disable_paging)(struct target *t);
+	int (*enable_paging)(struct target *t);
+	bool (*sw_bpts_supported)(struct target *t);
+	bool (*io_bpts_supported)(struct target *t);
+	int (*transaction_status)(struct target *t);
+	int (*submit_instruction)(struct target *t, int num);
+	int (*read_hw_reg)(struct target *t, int reg, uint32_t *regval, uint8_t cache);
+	int (*write_hw_reg)(struct target *t, int reg,
+				uint32_t regval, uint8_t cache);
+
+	/* register cache to processor synchronization */
+	int (*read_hw_reg_to_cache)(struct target *target, int num);
+	int (*write_hw_reg_from_cache)(struct target *target, int num);
+};
+
+static inline struct x86_32_common *
+target_to_x86_32(struct target *target)
+{
+	return target->arch_info;
+}
+bool check_not_halted(const struct target *t);
+
+/* breakpoint defines */
+#define MAX_DEBUG_REGS		4
+#define SW_BP_OPCODE		0xf1
+#define MAX_SW_BPTS		20
+
+struct x86_32_dbg_reg {
+	int used;
+	uint32_t bp_value;
+};
+
+#define DR7_G_ENABLE_SHIFT		1
+#define DR7_ENABLE_SIZE			2 /* 2 bits per debug reg */
+#define DR7_RW_SHIFT			16
+#define DR7_LENGTH_SHIFT		18
+#define DR7_RW_LEN_SIZE			4
+#define DR7_BP_EXECUTE			0 /* 00 - only on instruction execution*/
+#define DR7_BP_WRITE			1 /* 01 - only on data writes */
+#define DR7_RW_IO				2 /* 10 - on I/O read or write */
+#define DR7_BP_READWRITE		3 /* 11 - on data read or data write */
+#define DR7_BP_LENGTH_1			0 /* 00 - 1 byte length */
+#define DR7_BP_LENGTH_2			1 /* 01 - 2 byte length */
+#define DR7_BP_LENGTH_4			3 /* 11 - 4 byte length */
+
+#define DR7_GLOBAL_ENABLE(val, regnum) \
+	(val |= (1 << (DR7_G_ENABLE_SHIFT + (DR7_ENABLE_SIZE * (regnum)))))
+
+#define DR7_GLOBAL_DISABLE(val, regnum) \
+	(val &= ~(3 << (DR7_ENABLE_SIZE * (regnum))))
+
+#define DR7_BP_FREE(val, regnum) \
+	((val & (3 << (DR7_ENABLE_SIZE * (regnum)))) == 0)
+
+#define DR7_RESET_RWLEN_BITS(val, regnum) \
+	(val &= ~(0x0f << (DR7_RW_SHIFT + DR7_RW_LEN_SIZE * (regnum))))
+
+#define DR7_SET_EXE(val, regnum) \
+	(val &= ~(0x0f << (DR7_RW_SHIFT + DR7_RW_LEN_SIZE * (regnum))))
+
+#define DR7_SET_WRITE(val, regnum) \
+	(val |= (DR7_BP_WRITE << (DR7_RW_SHIFT + DR7_RW_LEN_SIZE * (regnum))))
+
+#define DR7_SET_IO(val, regnum) \
+	(val |= (DR7_RW_IO << (DR7_RW_SHIFT + DR7_RW_LEN_SIZE * (regnum))))
+
+#define DR7_SET_ACCESS(val, regnum) \
+	(val |= (DR7_BP_READWRITE << (DR7_RW_SHIFT + DR7_RW_LEN_SIZE * (regnum))))
+
+#define DR7_SET_LENGTH(val, regnum, len) \
+	(val |= (len == 1) ? (DR7_BP_LENGTH_1 << (DR7_LENGTH_SHIFT + DR7_RW_LEN_SIZE * (regnum))) : \
+	(len == 2) ? (DR7_BP_LENGTH_2 << (DR7_LENGTH_SHIFT + DR7_RW_LEN_SIZE * (regnum))) : \
+	(DR7_BP_LENGTH_4 << (DR7_LENGTH_SHIFT + DR7_RW_LEN_SIZE * (regnum))))
+
+/* public interface */
+int x86_32_get_gdb_reg_list(struct target *t,
+			struct reg **reg_list[], int *reg_list_size,
+			enum target_register_class reg_class);
+int x86_32_common_init_arch_info(struct target *target,
+			struct x86_32_common *x86_32);
+int x86_32_common_mmu(struct target *t, int *enabled);
+int x86_32_common_virt2phys(struct target *t, uint32_t address, uint32_t *physical);
+int x86_32_common_read_phys_mem(struct target *t, uint32_t phys_address,
+			uint32_t size, uint32_t count, uint8_t *buffer);
+int x86_32_common_write_phys_mem(struct target *t, uint32_t phys_address,
+			uint32_t size, uint32_t count, const uint8_t *buffer);
+int x86_32_common_read_memory(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, uint8_t *buf);
+int x86_32_common_write_memory(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, const uint8_t *buf);
+int x86_32_common_read_io(struct target *t, uint32_t addr,
+			uint32_t size, uint8_t *buf);
+int x86_32_common_write_io(struct target *t, uint32_t addr,
+			uint32_t size, const uint8_t *buf);
+int x86_32_common_add_breakpoint(struct target *t, struct breakpoint *bp);
+int x86_32_common_remove_breakpoint(struct target *t, struct breakpoint *bp);
+int x86_32_common_add_watchpoint(struct target *t, struct watchpoint *wp);
+int x86_32_common_remove_watchpoint(struct target *t, struct watchpoint *wp);
+void x86_32_common_reset_breakpoints_watchpoints(struct target *t);
+
+#endif /* X86_32_COMMON_H */
diff --git a/tcl/board/quark_d2000.cfg b/tcl/board/quark_d2000.cfg
new file mode 100644
index 0000000..0a789a9
--- /dev/null
+++ b/tcl/board/quark_d2000.cfg
@@ -0,0 +1,9 @@
+## Generic Quark D2000 board (Quark D2000 SoC)
+
+source [find target/quark_d2000.cfg]
+
+# default frequency but this can be adjusted at runtime
+adapter_khz 1000
+
+reset_config trst_only
+
diff --git a/tcl/board/quark_d2000_onboard.cfg b/tcl/board/quark_d2000_onboard.cfg
new file mode 100644
index 0000000..fbc2306
--- /dev/null
+++ b/tcl/board/quark_d2000_onboard.cfg
@@ -0,0 +1,18 @@
+## Quark D2000 Customer Reference Board
+
+## Onboard FT232H Configuration
+interface ftdi
+ftdi_vid_pid 0x0403 0x6014
+ftdi_channel 0
+
+ftdi_layout_init 0x0000 0x030b
+ftdi_layout_signal nTRST -data 0x0100 -noe 0x0100
+ftdi_layout_signal nSRST -data 0x0200 -oe 0x0200
+
+source [find target/quark_d2000.cfg]
+
+# default frequency but this can be adjusted at runtime
+adapter_khz 1000
+
+reset_config trst_only
+
diff --git a/tcl/board/quark_se.cfg b/tcl/board/quark_se.cfg
new file mode 100644
index 0000000..e8e3244
--- /dev/null
+++ b/tcl/board/quark_se.cfg
@@ -0,0 +1,12 @@
+# Generic Quark SE board (Quark SE SoC)
+
+source [find target/quark_se.cfg]
+
+# default frequency but this can be adjusted at runtime
+adapter_khz 1000
+
+reset_config trst_only
+
+# might need a delay before the initial discovery scan can succeed
+jtag_ntrst_delay 300
+
diff --git a/tcl/board/quark_x10xx_board.cfg b/tcl/board/quark_x10xx_board.cfg
new file mode 100644
index 0000000..8dc600b
--- /dev/null
+++ b/tcl/board/quark_x10xx_board.cfg
@@ -0,0 +1,9 @@
+# There are many Quark boards that can host the quark_x10xx SoC
+# Galileo is an example board
+
+source [find target/quark_x10xx.cfg]
+
+#default frequency but this can be adjusted at runtime
+adapter_khz 4000
+
+reset_config trst_only
diff --git a/tcl/board/snps_axs101.cfg b/tcl/board/snps_axs101.cfg
new file mode 100644
index 0000000..c2e6966
--- /dev/null
+++ b/tcl/board/snps_axs101.cfg
@@ -0,0 +1,25 @@
+#
+# Synopsys DesignWare ARC AXS101 Software Development Platform
+#
+
+# Configure JTAG cable
+# SDP has built-in FT2232 chip, which is similiar to Digilent HS-1, except that
+# it uses channgel B for JTAG, instead of channel A.
+
+# On Windows we are stuck with an old FT2232 interface, while on Linux we use
+# newer FTDI interface.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    source [find interface/snps_sdp.cfg]
+} else {
+    source [find interface/ftdi/snps_sdp.cfg]
+}
+adapter_khz 10000
+
+# Configure SoC
+source [find target/snps_axc001.cfg]
+
+# Initialize
+init
+halt
+reset halt
+
diff --git a/tcl/board/snps_axs102.cfg b/tcl/board/snps_axs102.cfg
new file mode 100644
index 0000000..002fef2
--- /dev/null
+++ b/tcl/board/snps_axs102.cfg
@@ -0,0 +1,25 @@
+#
+# Synopsys DesignWare ARC AXS102 Software Development Platform
+#
+
+# Configure JTAG cable
+# SDP has built-in FT2232 chip, which is similiar to Digilent HS-1, except that
+# it uses channgel B for JTAG, instead of channel A.
+
+# On Windows we are stuck with an old FT2232 interface, while on Linux we use
+# newer FTDI interface.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    source [find interface/snps_sdp.cfg]
+} else {
+    source [find interface/ftdi/snps_sdp.cfg]
+}
+adapter_khz 10000
+
+# Configure SoC
+source [find target/snps_axc002.cfg]
+
+# Initialize
+init
+halt
+reset halt
+
diff --git a/tcl/board/snps_em_sk.cfg b/tcl/board/snps_em_sk.cfg
new file mode 100644
index 0000000..f12f935
--- /dev/null
+++ b/tcl/board/snps_em_sk.cfg
@@ -0,0 +1,24 @@
+#
+# Synopsys DesignWare ARC EM Starter Kit
+#
+
+# Configure JTAG cable
+# EM Starter Kit has built-in FT2232 chip, which is similiar to Digilent HS-1.
+
+# On Windows we are stuck with an old FT2232 interface, while on Linux we use
+# newer FTDI interface.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    source "[find interface/digilent-hs1.cfg]
+} else {
+    source [find interface/ftdi/digilent-hs1.cfg]
+}
+adapter_khz 10000
+
+# Configure SoC
+source [find target/snps_em_sk-lx45.cfg]
+
+# Initialize
+init
+halt
+reset halt
+
diff --git a/tcl/board/synopsys_amla3.cfg b/tcl/board/synopsys_amla3.cfg
new file mode 100644
index 0000000..d4fd41a
--- /dev/null
+++ b/tcl/board/synopsys_amla3.cfg
@@ -0,0 +1,14 @@
+# Synopsys clone of AML Apollo A3 board
+#  http://www.synopsys.com
+
+# The JTAG interface is built directly on the board.
+interface ft2232
+ft2232_device_desc "Digilent Adept USB Device"
+ft2232_layout digilent-hs1
+ft2232_vid_pid 0x0403 0x6010
+
+adapter_khz 500
+
+source [find target/snps_aml8626x.cfg]
+
+reset_config trst_and_srst
diff --git a/tcl/board/synopsys_angel4.cfg b/tcl/board/synopsys_angel4.cfg
new file mode 100644
index 0000000..290e11c
--- /dev/null
+++ b/tcl/board/synopsys_angel4.cfg
@@ -0,0 +1,14 @@
+# Synopsys Angel4 FPGA board
+#  http://www.synopsys.com
+
+# The JTAG interface is built directly on the board.
+interface ft2232
+ft2232_device_desc "Digilent Adept USB Device"
+ft2232_layout digilent-hs1
+ft2232_vid_pid 0x0403 0x6010
+
+adapter_khz 500
+
+source [find target/snps_angel4.cfg]
+
+reset_config trst_and_srst
diff --git a/tcl/board/synopsys_haps51.cfg b/tcl/board/synopsys_haps51.cfg
new file mode 100644
index 0000000..cea251b
--- /dev/null
+++ b/tcl/board/synopsys_haps51.cfg
@@ -0,0 +1,14 @@
+# Synopsys HAPS51 FPGA board
+#  http://www.synopsys.com
+
+# The JTAG interface is built directly on the board.
+interface ft2232
+ft2232_device_desc "Digilent Adept USB Device"
+ft2232_layout digilent-hs1
+ft2232_vid_pid 0x0403 0x6010
+
+adapter_khz 500
+
+source [find target/snps_haps51.cfg]
+
+reset_config trst_and_srst
diff --git a/tcl/board/synopsys_ml509.cfg b/tcl/board/synopsys_ml509.cfg
new file mode 100644
index 0000000..f33685c
--- /dev/null
+++ b/tcl/board/synopsys_ml509.cfg
@@ -0,0 +1,14 @@
+# Synopsys Xilinx ML509 FPGA board
+#  http://www.synopsys.com
+
+# The JTAG interface is built directly on the board.
+interface ft2232
+ft2232_device_desc "Digilent Adept USB Device"
+ft2232_layout digilent-hs1
+ft2232_vid_pid 0x0403 0x6010
+
+adapter_khz 500
+
+source [find target/snps_ml509.cfg]
+
+reset_config trst_and_srst
diff --git a/tcl/cpu/arc/arc600.tcl b/tcl/cpu/arc/arc600.tcl
new file mode 100644
index 0000000..f21275d
--- /dev/null
+++ b/tcl/cpu/arc/arc600.tcl
@@ -0,0 +1,5 @@
+set CPU_TYPE   arc
+set CPU_NAME   arc600
+set CPU_ARCH   arcompact
+set CPU_MAX_ADDRESS 0xFFFFFFFF
+set CPU_NBITS  32
diff --git a/tcl/cpu/arc/arc700.tcl b/tcl/cpu/arc/arc700.tcl
new file mode 100644
index 0000000..bbf3dd5
--- /dev/null
+++ b/tcl/cpu/arc/arc700.tcl
@@ -0,0 +1,5 @@
+set CPU_TYPE   arc
+set CPU_NAME   arc700
+set CPU_ARCH   arcompact
+set CPU_MAX_ADDRESS 0xFFFFFFFF
+set CPU_NBITS  32
diff --git a/tcl/cpu/arc/arc750.tcl b/tcl/cpu/arc/arc750.tcl
new file mode 100644
index 0000000..39db4bc
--- /dev/null
+++ b/tcl/cpu/arc/arc750.tcl
@@ -0,0 +1,5 @@
+set CPU_TYPE   arc
+set CPU_NAME   arc750
+set CPU_ARCH   arcompact
+set CPU_MAX_ADDRESS 0xFFFFFFFF
+set CPU_NBITS  32
diff --git a/tcl/cpu/arc/arc770.tcl b/tcl/cpu/arc/arc770.tcl
new file mode 100644
index 0000000..21842bc
--- /dev/null
+++ b/tcl/cpu/arc/arc770.tcl
@@ -0,0 +1,5 @@
+set CPU_TYPE   arc
+set CPU_NAME   arc770
+set CPU_ARCH   arcompact
+set CPU_MAX_ADDRESS 0xFFFFFFFF
+set CPU_NBITS  32
diff --git a/tcl/interface/digilent-hs2.cfg b/tcl/interface/digilent-hs2.cfg
new file mode 100644
index 0000000..54038cb
--- /dev/null
+++ b/tcl/interface/digilent-hs2.cfg
@@ -0,0 +1,17 @@
+#
+# Digilent HS2
+#
+# The Digilent HS2 is a high-speed FT232H-based adapter, compliant with the
+# Xilinx JTAG 14-pin pinout.
+# It does not support ARM reset signals (SRST and TRST) but can still be used for
+# hardware debugging, with some limitations.
+#
+# http://www.digilentinc.com/Products/Detail.cfm?Prod=JTAG-HS2
+#
+# It has a different layout initialization in comparison with HS1 and another PID.
+#
+
+interface ft2232
+ft2232_layout digilent-hs2
+ft2232_vid_pid 0x0403 0x6014
+
diff --git a/tcl/interface/ftdi/digilent-hs1.cfg b/tcl/interface/ftdi/digilent-hs1.cfg
new file mode 100644
index 0000000..7dc7e4f
--- /dev/null
+++ b/tcl/interface/ftdi/digilent-hs1.cfg
@@ -0,0 +1,15 @@
+#
+# Digilent HS1
+#
+# The Digilent HS1 is a high-speed FT2232H-based adapter, compliant with the
+# Xilinx JTAG 14-pin pinout.
+# It does not support ARM reset signals (SRST and TRST) but can still be used for
+# hardware debugging, with some limitations.
+#
+# http://www.digilentinc.com/Products/Detail.cfm?NavPath=2,395,922&Prod=JTAG-HS1
+#
+
+interface ftdi
+ftdi_vid_pid 0x0403 0x6010
+ftdi_layout_init 0x0088 0x008b
+
diff --git a/tcl/interface/ftdi/digilent-hs2.cfg b/tcl/interface/ftdi/digilent-hs2.cfg
new file mode 100644
index 0000000..7a732ac
--- /dev/null
+++ b/tcl/interface/ftdi/digilent-hs2.cfg
@@ -0,0 +1,17 @@
+#
+# Digilent HS2
+#
+# The Digilent HS2 is a high-speed FT232H-based adapter, compliant with the
+# Xilinx JTAG 14-pin pinout.
+# It does not support ARM reset signals (SRST and TRST) but can still be used for
+# hardware debugging, with some limitations.
+#
+# http://www.digilentinc.com/Products/Detail.cfm?Prod=JTAG-HS2
+#
+# It has a different layout initialization in comparison with HS1 and another PID.
+#
+
+interface ftdi
+ftdi_vid_pid 0x0403 0x6014
+ftdi_layout_init 0x00e8 0x00eb
+
diff --git a/tcl/interface/ftdi/snps_sdp.cfg b/tcl/interface/ftdi/snps_sdp.cfg
new file mode 100644
index 0000000..5fdd47b
--- /dev/null
+++ b/tcl/interface/ftdi/snps_sdp.cfg
@@ -0,0 +1,10 @@
+# Synopsys SDP Mainboard has embdded FT2232 chip, which is similiar to Digilent
+# HS-1, except that it uses channel B for JTAG communication, instead of
+# channel A.
+
+interface ftdi
+ftdi_vid_pid 0x0403 0x6010
+ftdi_layout_init 0x0088 0x008b
+ftdi_channel 1
+
+
diff --git a/tcl/interface/snps_sdp.cfg b/tcl/interface/snps_sdp.cfg
new file mode 100644
index 0000000..211067f
--- /dev/null
+++ b/tcl/interface/snps_sdp.cfg
@@ -0,0 +1,17 @@
+# Synopsys SDP Mainboard has embdded FT2232 chip, which is similiar to Digilent
+# HS-1, except that it uses channel B for JTAG communication, instead of
+# channel A.
+
+interface ft2232
+# On Windows we have two devices instead of one device with two channels, so
+# device_desc has to adjusted accordingly.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    ft2232_device_desc "Digilent USB Device B"
+} else {
+    ft2232_device_desc "Digilent USB Device"
+}
+ft2232_layout digilent-hs1
+ft2232_vid_pid 0x0403 0x6010
+ft2232_channel 1
+
+
diff --git a/tcl/target/1986BE1T.cfg b/tcl/target/1986BE1T.cfg
new file mode 100644
index 0000000..98d5103
--- /dev/null
+++ b/tcl/target/1986BE1T.cfg
@@ -0,0 +1,52 @@
+# 1986Ð’Ð•1Ð¢
+# http://milandr.ru/index.php?mact=Products,cntnt01,details,0&cntnt01productid=236&cntnt01returnid=68
+
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME 1986Ð²Ðµ1Ñ‚
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+# Work-area is a space in RAM used for flash programming
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x4000
+}
+
+# JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
+adapter_khz 1000
+
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+
+#jtag scan chain
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x4ba00477
+}
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m -endian $_ENDIAN -chain-position $_TARGETNAME
+
+# use AHB-Lite SRAM for work area
+$_TARGETNAME configure -work-area-phys 0x20100000 -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+# can't handle overlapping memory regions
+if { [info exists IMEMORY] && [string equal $IMEMORY true] } {
+   flash bank ${_CHIPNAME}_info.flash mdr 0x00000000 0x01000 0 0 $_TARGETNAME 1 1 4
+} else {
+   flash bank $_CHIPNAME.flash mdr 0x00000000 0x20000 0 0 $_TARGETNAME 0 32 4
+}
+
+# if srst is not fitted use SYSRESETREQ to
+# perform a soft reset
+cortex_m reset_config sysresetreq
diff --git a/tcl/target/quark_d2000.cfg b/tcl/target/quark_d2000.cfg
new file mode 100644
index 0000000..e1cfb1b
--- /dev/null
+++ b/tcl/target/quark_d2000.cfg
@@ -0,0 +1,136 @@
+# scan_chain
+jtag newtap quark_d2000 lmt    -irlen 8  -irmask 0xff  -expected-id   0x38289013  -disable
+jtag newtap quark_d2000 cltap  -irlen 8  -irmask 0xff  -expected-id   0x0e786013  -enable
+
+# targets
+target create lmt.cpu quark_d2000 -endian little -chain-position quark_d2000.lmt
+
+lmt.cpu configure -event gdb-attach { halt }
+
+# openocd puts tap at front of chain not end of chain
+# to enable the lmt core we need to set bits [1:0] to 0x1
+proc quark_d2000_lmt_tapenable {} {
+	echo "Enabling lmt core tap"
+	set val [ eval { irscan quark_d2000.cltap 0x11 ; drscan quark_d2000.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( ( 0x$val & 0xffc ) | 0x01 ) ] ]
+	irscan quark_d2000.cltap 0x11
+	drscan quark_d2000.cltap 12 $val
+	runtest 10
+}
+
+# to disable the lmt core we need to set bits [1:0] to 0x0
+proc quark_d2000_lmt_tapdisable {} {
+	echo "Disabling lmt core tap"
+	set val [ eval { irscan quark_d2000.cltap 0x11 ; drscan quark_d2000.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( 0x$val & 0xffc ) ] ]
+	irscan quark_d2000.cltap 0x11
+	drscan quark_d2000.cltap 12 $val
+	runtest 10
+}
+
+proc quark_d2000_setup {} {
+	jtag tapenable quark_d2000.lmt
+}
+
+jtag configure quark_d2000.lmt -event tap-enable "quark_d2000_lmt_tapenable"
+jtag configure quark_d2000.lmt -event tap-disable "quark_d2000_lmt_tapdisable"
+
+jtag configure quark_d2000.cltap -event setup "quark_d2000_setup"
+
+#default frequency but this can be adjusted at runtime
+adapter_khz 1000
+
+reset_config trst_only
+
+## Utility functions
+
+# utility functions to delete OTPD and FLASH
+proc del_flash0 {} { mww 0xB0100018 0x80 ; sleep 2000 ; mdw 0xB0100014 }
+# utility function to delete OTPC, OTPD and FLASH
+proc mass_erase {} {
+ if { [ info exists ::QUARK_D2000_OTPC_DATA_WRITE_ENABLED ] &&
+    [ expr $::QUARK_D2000_OTPC_DATA_WRITE_ENABLED ] } then {
+	echo "Deleting  OTPC, OTPD and FLASH regions"
+	mww 0xB0100018 0xC0 ; sleep 2000 ; mdw 0xB0100014
+ } else {
+	echo "No operation was performed"
+	echo "mass_erase command deletes also the OTPC DATA protected region, but this behavior is disabled by default."
+	echo "The following command will allow it: set QUARK_D2000_OTPC_DATA_WRITE_ENABLED 1"
+	echo "To mass erase only the OTPD and FLASH regions use the 'del_flash0' command instead."
+ }
+}
+
+# utility function to set SoC clock to 32MHz Si
+proc clk32M { {jtag_khz 1000} } {
+	# slow speed to make sure we can write mem
+	adapter_khz 3
+	# LMT halt
+	irscan quark_d2000.cltap 0x70 ; drscan quark_d2000.cltap 8 0x1
+	# set the SoC clock to the 32 MHz Silicon one
+	mww 0xB0800008 0x2
+	mww 0xB0800038 0x7
+	mww 0xB0800038 0x87
+	# set the JTAG clock to the desired one
+	adapter_khz $jtag_khz
+	# clear halt flag and reset the SoC
+	irscan quark_d2000.cltap 0x70 ; drscan quark_d2000.cltap 8 0x0
+	reset halt
+}
+
+# utility function to recover JTAG
+# delay parameter is critical to stop the FW as soon as possible, the value
+# varies from board to board, typical values are between 114 and 130 ms
+proc jtag_recovery { {delay_ms 117} } {
+	# disable polling, it'll just get in the way
+	poll off
+
+	# disable the lmt tap if not disabled already
+	if { [jtag tapisenabled quark_d2000.lmt] } then { jtag tapdisable quark_d2000.lmt }
+
+	# trigger a reset
+	ftdi_set_signal nSRST 1
+	sleep 500
+	ftdi_set_signal nSRST 0
+
+	# here we should wait 4 uS after reset is deasserted and reaches a logic 1
+	# to have the tap available, but the reset needs some time to reach that
+	# level as there are capacitances involved.
+	# even if we switched the reset pin back to input we couldn't poll it fast
+	# enough to get the right timing, so we need to measure experimentally the
+	# rise time and determine the right openocd delay.
+	#
+	# granularity on the tcl command line in openocd is 1 ms.
+	# if this is too coarse add a specific reset and delay command in C.
+	sleep $delay_ms
+
+	# re-initialize the jtag scanchain
+	jtag arp_init
+
+	# assert vpreq (it's cleared on reset)
+	irscan quark_d2000.cltap 0x70 ; drscan quark_d2000.cltap 8 0x3
+
+	# wait until we actually stop, we should actually poll vprdy but if we did
+	# not stop after another 500 ms something went terribly wrong and polling
+	# wouldn't help anyway
+	sleep 500
+
+	# re-initialize the jtag scanchain
+	jtag arp_init
+
+	# enable polling again
+	poll on
+}
+
+# utility function to flash ROM
+proc flash_rom { rom_file { address 0x0 } } {
+	init
+	echo "Setup clock"
+	clk32M
+	echo "Start flash"
+	load_image $rom_file $address
+	echo "Start verify"
+	verify_image_offset $rom_file $address 0x150
+	echo "Reset target"
+	reset halt
+	echo "All done"
+}
diff --git a/tcl/target/quark_se.cfg b/tcl/target/quark_se.cfg
new file mode 100644
index 0000000..fa00108
--- /dev/null
+++ b/tcl/target/quark_se.cfg
@@ -0,0 +1,108 @@
+# scan_chain
+jtag newtap quark_se arc-em -irlen 4  -irmask 0x0f  -expected-id   0x200044b1  -disable
+jtag newtap quark_se quark  -irlen 8  -irmask 0xff  -expected-id   0x38289013  -disable
+jtag newtap quark_se cltap  -irlen 8  -irmask 0xff  -expected-id   0x0e765013  -enable
+
+# targets
+target create quark_se.quark  quark_se -endian little -chain-position quark_se.quark
+target create quark_se.arc-em arc32    -endian little -chain-position quark_se.arc-em
+
+quark_se.quark configure -event gdb-attach { targets quark_se.quark ; halt }
+
+# openocd puts tap at front of chain not end of chain
+# to enable the quark core we need to set bits [1:0] to 0x1
+proc quark_se_quark_tapenable {} {
+	echo "Enabling quark core tap"
+	set val [ eval { irscan quark_se.cltap 0x11 ; drscan quark_se.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( ( 0x$val & 0xffc ) | 0x01 ) ] ]
+	irscan quark_se.cltap 0x11
+	drscan quark_se.cltap 12 $val
+	runtest 10
+}
+
+# to disable the quark core we need to set bits [1:0] to 0x0
+proc quark_se_quark_tapdisable {} {
+	echo "Disabling quark core tap"
+	set val [ eval { irscan quark_se.cltap 0x11 ; drscan quark_se.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( 0x$val & 0xffc ) ] ]
+	irscan quark_se.cltap 0x11
+	drscan quark_se.cltap 12 $val
+	runtest 10
+}
+
+# to enable the arc core we need to set bits [3:2] to 0x1
+proc quark_se_arc_tapenable {} {
+	echo "Enabling arc core tap"
+	set val [ eval { irscan quark_se.cltap 0x11 ; drscan quark_se.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( ( 0x$val & 0xff3 ) | 0x04 )] ]
+	irscan quark_se.cltap 0x11
+	drscan quark_se.cltap 12 $val
+	runtest 10
+}
+
+# to disable the arc core we need to set bits [3:2] to 0x0
+proc quark_se_arc_tapdisable {} {
+	echo "Disabling arc core tap"
+	set val [ eval { irscan quark_se.cltap 0x11 ; drscan quark_se.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( 0x$val & 0xff3 ) ] ]
+	irscan quark_se.cltap 0x11
+	drscan quark_se.cltap 12 $val
+	runtest 10
+}
+
+proc quark_se_setup {} {
+	poll off
+	jtag tapenable quark_se.arc-em
+	jtag tapenable quark_se.quark
+	poll on
+}
+
+jtag configure quark_se.quark -event tap-enable "quark_se_quark_tapenable"
+jtag configure quark_se.quark -event tap-disable "quark_se_quark_tapdisable"
+
+jtag configure quark_se.arc-em -event tap-enable "quark_se_arc_tapenable"
+jtag configure quark_se.arc-em -event tap-disable "quark_se_arc_tapdisable"
+
+jtag configure quark_se.cltap -event setup "quark_se_setup"
+
+
+# utility functions for cross triggering
+proc enable_x_arc2quark_trigger {} { irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x40 }
+proc enable_x_quark2arc_trigger {} { irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x80 }
+proc enable_x_dual_trigger {} { irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0xc0 }
+proc disable_x_trigger {} { irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x0 }
+proc resume_all {} {
+	set currentt [ ocd_target current ]
+	set q_state [ quark_se.quark curstate ]
+	set a_state [ quark_se.arc-em curstate ]
+	if { [ string first halt $a_state ] != -1 } { targets 1 ; resume }
+	if { [ string first halt $q_state ] != -1 } { targets 0 ; resume }
+	targets $currentt
+}
+
+# utility functions to delete flash
+proc del_flash0 {} { mww 0xB0100018 0x80 ; sleep 2000 ; mdw 0xB0100014 }
+proc del_flash1 {} { mww 0xB0200018 0x80 ; sleep 2000 ; mdw 0xB0200014 }
+# utility function to delete ROM, flash0 and flash1
+proc mass_erase {} { mww 0xB0100018 0xC0 ; mww 0xB0200018 0xC0 ; sleep 2000 ; mdw 0xB0100014 ; mdw 0xB0200014 }
+
+# utility function to set SoC clock to 32MHz Si
+proc clk32M { {jtag_khz 1000} } {
+	# slow speed to make sure we can write mem
+	adapter_khz 3
+	# quark halt
+	irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x1
+	# arc halt
+	irscan quark_se.cltap 0x69 ; drscan quark_se.cltap 4 0x1
+	# set the SoC clock to the 32 MHz Silicon one
+	mww 0xB0800008 0x2
+	mww 0xB0800038 0x7
+	mww 0xB0800038 0x87
+	# set the JTAG clock to the desired one
+	adapter_khz $jtag_khz
+	# clear halt flags and reset the SoC
+	irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x0
+	irscan quark_se.cltap 0x69 ; drscan quark_se.cltap 4 0x0
+	reset halt
+}
+
diff --git a/tcl/target/quark_x10xx.cfg b/tcl/target/quark_x10xx.cfg
new file mode 100644
index 0000000..a5bbfb4
--- /dev/null
+++ b/tcl/target/quark_x10xx.cfg
@@ -0,0 +1,52 @@
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME quark_x10xx
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x18289013
+}
+
+jtag newtap quark_x10xx cpu   -irlen 8  -irmask 0xff  -expected-id   $_CPUTAPID  -disable
+jtag newtap quark_x10xx cltap -irlen 8  -irmask 0xff  -expected-id   0x0e681013  -enable
+
+#openocd puts tap at front of chain not end of chain
+proc quark_x10xx_tapenable {} {
+	echo "enabling core tap"
+	irscan quark_x10xx.cltap 0x11
+	drscan quark_x10xx.cltap 64 1
+	runtest 10
+}
+
+proc quark_x10xx_tapdisable {} {
+	echo "disabling core tap"
+	irscan quark_x10xx.cltap 0x11
+	drscan quark_x10xx.cltap 64 0
+	runtest 10
+}
+
+proc quark_x10xx_setup {} {
+	jtag tapenable quark_x10xx.cpu
+}
+
+jtag configure $_CHIPNAME.cpu -event tap-enable \
+   "quark_x10xx_tapenable"
+
+jtag configure $_CHIPNAME.cpu -event tap-disable \
+   "quark_x10xx_tapdisable"
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create quark_x10xx.cpu quark_x10xx -endian $_ENDIAN -chain-position quark_x10xx.cpu
+
+jtag configure $_CHIPNAME.cpu -event setup \
+   "quark_x10xx_setup"
diff --git a/tcl/target/snps_axc001.cfg b/tcl/target/snps_axc001.cfg
new file mode 100644
index 0000000..f34ea81
--- /dev/null
+++ b/tcl/target/snps_axc001.cfg
@@ -0,0 +1,89 @@
+#
+# AXC001 CPU card for the AXS101.
+#
+# Contains: ARC770D, ARC EM6, ARC AS221BD (two ARC 600 cores, can be treated as
+# a single core ARC 600).
+#
+
+# _CHIPNAME really should be same for all cores and be something like AXC001,
+# however at the moment ARC OpenOCD will use chip name to decide whether it is
+# ARC 600, ARC 700 or ARC EM. Therefore we need to set it each time for each
+# core. This crutch can be removed after the way how OpenOCD distinguishes
+# different ARCs will be fixed and CHIPNAME will be just a chip name.
+
+# AXC001 contains 4 cores: two ARC 600's (united as AS221), EM6 and ARC 770D.
+# Four JTAG combinations are possible, depending on configuration of TSEL
+# jumpers:
+# 1. All cores are in chain
+# 2. Both ARC 600's are in
+# 3. Only ARC EM is in
+# 4. Only ARC 700 is in.
+# Default is "all in". Caller may use HAS_[EM6|770|AS221] to override.
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+set _sram_addr 0x20000000
+set _sram_size 0x20000
+
+if { ![info exists HAS_EM6] } {
+    set HAS_EM6 1
+}
+if { ![info exists HAS_770] } {
+    set HAS_770 1
+}
+if { ![info exists HAS_AS221] } {
+    set HAS_AS221 1
+}
+
+# For some reasons OpenOCD discovers JTAG TAPs in reverse order.
+
+if { $HAS_770 } {
+    # ARC 700 on ML 509: 0x200034b1
+    # ARC 700 on AXC001: 0x201034b1
+    set _CHIPNAME arc700
+    set _TARGETNAME $_CHIPNAME.cpu
+    jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200034b1 -expected-id 0x201034b1
+
+    target create $_TARGETNAME arc32 -chain-position $_TARGETNAME
+    $_TARGETNAME configure -coreid $_coreid
+    $_TARGETNAME configure -dbgbase $_dbgbase
+    $_TARGETNAME configure -work-area-phys $_sram_addr -work-area-size $_sram_size
+    set _coreid [expr $_coreid + 1]
+    set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+}
+
+if { $HAS_EM6 } {
+    # EM SK 0x200444b1
+    # SDP:EM6 0x200c44b1
+    set _CHIPNAME arc-em
+    set _TARGETNAME $_CHIPNAME.cpu
+    jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200444b1 -expected-id 0x200c44b1
+
+    target create $_TARGETNAME arc32 -chain-position $_TARGETNAME
+    $_TARGETNAME configure -coreid $_coreid
+    $_TARGETNAME configure -dbgbase $_dbgbase
+    $_TARGETNAME configure -work-area-phys $_sram_addr -work-area-size $_sram_size
+    set _coreid [expr $_coreid + 1]
+    set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+}
+
+if { $HAS_AS221 } {
+    set _CHIPNAME arc600
+
+    set _TARGETNAME $_CHIPNAME.cpu2
+    jtag newtap $_CHIPNAME cpu2 -irlen 4 -ircapture 0x1 -expected-id 0x200424b1 -expected-id 0x200824b1
+    target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+	-coreid $_coreid -dbgbase $_dbgbase
+    $_TARGETNAME configure -work-area-phys $_sram_addr -work-area-size $_sram_size
+    set _coreid [expr $_coreid + 1]
+    set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+    set _TARGETNAME $_CHIPNAME.cpu1
+    jtag newtap $_CHIPNAME cpu1 -irlen 4 -ircapture 0x1 -expected-id 0x200424b1 -expected-id 0x200824b1
+    target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+	-coreid $_coreid -dbgbase $_dbgbase
+    $_TARGETNAME configure -work-area-phys $_sram_addr -work-area-size $_sram_size
+    set _coreid [expr $_coreid + 1]
+    set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+}
diff --git a/tcl/target/snps_axc002.cfg b/tcl/target/snps_axc002.cfg
new file mode 100644
index 0000000..aab2961
--- /dev/null
+++ b/tcl/target/snps_axc002.cfg
@@ -0,0 +1,62 @@
+#
+# AXC002 CPU card for the AXS101.
+#
+# Contains ARC HS34 and ARC HS 36.
+#
+
+# _CHIPNAME really should be same for all cores and be something like AXC001,
+# however at the moment ARC OpenOCD will use chip name to decide whether it is
+# ARC 600, ARC 700 or ARC EM. Therefore we need to set it each time for each
+# core. This crutch can be removed after the way how OpenOCD distinguishes
+# different ARCs will be fixed and CHIPNAME will be just a chip name.
+
+# AXC002 contains 2 cores: ARC HS34 and ARC HS36. Three JTAG combinations are
+# possible, depending on configuration of TSEL jumpers:
+# 1. All cores are in chain;
+# 2. Only ARC HS34 is in the chain;
+# 3. Only ARC HS36 is in the chain.
+# Default is "all in". Caller may use variables HAS_[HS34|HS36] to override.
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+# On-chip SRAM has size of 256KiB, mapped to 0x2000_0000.
+set _sram_addr 0x20000000
+set _sram_size 0x40000
+
+if { ![info exists HAS_HS34] } {
+    set HAS_HS34 1
+}
+if { ![info exists HAS_HS36] } {
+    set HAS_HS36 1
+}
+
+# CHIPNAME will be used to choose core family (600, 700 or EM). As far as
+# OpenOCD is concerned EM and HS are identical.
+set _CHIPNAME arc-em
+
+# For some reasons OpenOCD discovers JTAG TAPs in reverse order.
+
+if { $HAS_HS36 } {
+    set _TARGETNAME $_CHIPNAME.cpu2
+    jtag newtap $_CHIPNAME cpu2 -irlen 4 -ircapture 0x1 -expected-id 0x200824b1
+    puts "$_TARGETNAME"
+    puts "target create $_TARGETNAME arc32 -chain-position $_TARGETNAME"
+    target create $_TARGETNAME arc32 -chain-position $_TARGETNAME
+    $_TARGETNAME configure -coreid $_coreid
+    $_TARGETNAME configure -dbgbase $_dbgbase
+    $_TARGETNAME configure -work-area-phys $_sram_addr -work-area-size $_sram_size
+    set _coreid [expr $_coreid + 1]
+    set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+}
+if { $HAS_HS34 } {
+    set _TARGETNAME $_CHIPNAME.cpu1
+    jtag newtap $_CHIPNAME cpu1 -irlen 4 -ircapture 0x1 -expected-id 0x200424b1
+
+    target create $_TARGETNAME arc32 -chain-position $_TARGETNAME
+    $_TARGETNAME configure -coreid $_coreid
+    $_TARGETNAME configure -dbgbase $_dbgbase
+    $_TARGETNAME configure -work-area-phys $_sram_addr -work-area-size $_sram_size
+    set _coreid [expr $_coreid + 1]
+    set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+}
diff --git a/tcl/target/snps_em_sk_lx45.cfg b/tcl/target/snps_em_sk_lx45.cfg
new file mode 100644
index 0000000..ea1850f
--- /dev/null
+++ b/tcl/target/snps_em_sk_lx45.cfg
@@ -0,0 +1,20 @@
+#
+# Xilinx Spartan-6 XC6SLX45 FPGA on EM Starter Kit.
+#
+
+set _CHIPNAME arc-em
+set _TARGETNAME $_CHIPNAME.cpu
+
+# EM SK IDENTITY is 0x200444b1
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200444b1
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+  -coreid 0 -dbgbase $_dbgbase -endian little
+
+# SRAM: 56KiB at 0x4030.0000
+#$_TARGETNAME configure -work-area-phys 0x00000000 \
+#	-work-area-virt 0x00000000 -work-area-size 0x10000000
+
diff --git a/tcl/target/snps_ml509_arc600.cfg b/tcl/target/snps_ml509_arc600.cfg
new file mode 100644
index 0000000..62becb4
--- /dev/null
+++ b/tcl/target/snps_ml509_arc600.cfg
@@ -0,0 +1,43 @@
+#
+# ARC 600 setup for the Xilinx ML509
+#
+
+set _CHIPNAME arc600
+set _TARGETNAME $_CHIPNAME.cpu
+
+#
+# daemon configuration
+telnet_port 4444
+gdb_port 3333
+
+# Configure JTAG cable
+
+# There are two reasons why we need separate configuration for Windows:
+# 1. On Windows we are stuck with old FT2232 interface, while on Linux we user
+# newer FTDI interface.
+# 2. On Linux people usually configura/build/install themselves, so there is no
+# problem from using absolute paths, but when distributing files for Window we
+# get a problem that directory to search for scripts is hardcoded as an
+# absolute path into OpenOCD. It is possible to supply it with option -s when
+# calling from IDE, but that might not work in all cases. So it is better to
+# provide path that is relative to the current script file.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    source "[file dirname [info script]]/../interface/digilent-hs1.cfg"
+} else {
+    source [find interface/ftdi/digilent-hs1.cfg]
+}
+
+# jtag speed
+adapter_khz 10000
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200424b1
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+  -coreid 0 -dbgbase $_dbgbase -endian little
+
+# SDRAM: 256MiB at 0x0000.0000
+$_TARGETNAME configure -work-area-phys 0x00000000 \
+	-work-area-virt 0x00000000 -work-area-size 0x10000000
diff --git a/tcl/target/snps_ml509_arc700.cfg b/tcl/target/snps_ml509_arc700.cfg
new file mode 100644
index 0000000..b4ffab2
--- /dev/null
+++ b/tcl/target/snps_ml509_arc700.cfg
@@ -0,0 +1,43 @@
+#
+# ARC 700 setup for the Xilinx ML509
+#
+
+set _CHIPNAME arc700
+set _TARGETNAME $_CHIPNAME.cpu
+
+#
+# daemon configuration
+telnet_port 4444
+gdb_port 3333
+
+# Configure JTAG cable
+
+# There are two reasons why we need separate configuration for Windows:
+# 1. On Windows we are stuck with old FT2232 interface, while on Linux we user
+# newer FTDI interface.
+# 2. On Linux people usually configura/build/install themselves, so there is no
+# problem from using absolute paths, but when distributing files for Window we
+# get a problem that directory to search for scripts is hardcoded as an
+# absolute path into OpenOCD. It is possible to supply it with option -s when
+# calling from IDE, but that might not work in all cases. So it is better to
+# provide path that is relative to the current script file.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    source "[file dirname [info script]]/../interface/digilent-hs1.cfg"
+} else {
+    source [find interface/ftdi/digilent-hs1.cfg]
+}
+
+# jtag speed
+adapter_khz 10000
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200034b1
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+  -coreid 0 -dbgbase $_dbgbase -endian little
+
+# SDRAM: 256MiB at 0x0000.0000
+$_TARGETNAME configure -work-area-phys 0x00000000 \
+	-work-area-virt 0x00000000 -work-area-size 0x10000000
diff --git a/tcl/target/snps_starter_kit_arc-em.cfg b/tcl/target/snps_starter_kit_arc-em.cfg
new file mode 100644
index 0000000..f276ce7
--- /dev/null
+++ b/tcl/target/snps_starter_kit_arc-em.cfg
@@ -0,0 +1,46 @@
+#
+# ARC EM setup for the EM Starter Kit
+#
+
+puts "WARNING: You are using obsolete EM Starter Kit configuration file."
+puts "Use board/snps_em_sk.cfg instead."
+
+set _CHIPNAME arc-em
+set _TARGETNAME $_CHIPNAME.cpu
+
+#
+# daemon configuration
+telnet_port 4444
+gdb_port 3333
+
+# Configure JTAG cable
+
+# There are two reasons why we need separate configuration for Windows:
+# 1. On Windows we are stuck with old FT2232 interface, while on Linux we user
+# newer FTDI interface.
+# 2. On Linux people usually configura/build/install themselves, so there is no
+# problem from using absolute paths, but when distributing files for Window we
+# get a problem that directory to search for scripts is hardcoded as an
+# absolute path into OpenOCD. It is possible to supply it with option -s when
+# calling from IDE, but that might not work in all cases. So it is better to
+# provide path that is relative to the current script file.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    source "[file dirname [info script]]/../interface/digilent-hs1.cfg"
+} else {
+    source [find interface/ftdi/digilent-hs1.cfg]
+}
+
+# jtag speed
+adapter_khz 10000
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200444b1
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+  -coreid 0 -dbgbase $_dbgbase -endian little
+
+# SRAM: 56KiB at 0x4030.0000
+$_TARGETNAME configure -work-area-phys 0x00000000 \
+	-work-area-virt 0x00000000 -work-area-size 0x10000000
diff --git a/tcl/target/snps_starter_kit_arc-em_eb.cfg b/tcl/target/snps_starter_kit_arc-em_eb.cfg
new file mode 100644
index 0000000..0416134
--- /dev/null
+++ b/tcl/target/snps_starter_kit_arc-em_eb.cfg
@@ -0,0 +1,43 @@
+#
+# ARC EM setup for the EM Starter Kit (with big endian core)
+#
+
+set _CHIPNAME arc-em
+set _TARGETNAME $_CHIPNAME.cpu
+
+#
+# daemon configuration
+telnet_port 4444
+gdb_port 3333
+
+# Configure JTAG cable
+
+# There are two reasons why we need separate configuration for Windows:
+# 1. On Windows we are stuck with old FT2232 interface, while on Linux we user
+# newer FTDI interface.
+# 2. On Linux people usually configura/build/install themselves, so there is no
+# problem from using absolute paths, but when distributing files for Window we
+# get a problem that directory to search for scripts is hardcoded as an
+# absolute path into OpenOCD. It is possible to supply it with option -s when
+# calling from IDE, but that might not work in all cases. So it is better to
+# provide path that is relative to the current script file.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    source "[file dirname [info script]]/../interface/digilent-hs1.cfg"
+} else {
+    source [find interface/ftdi/digilent-hs1.cfg]
+}
+
+# jtag speed
+adapter_khz 10000
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200444b1
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+  -coreid 0 -dbgbase $_dbgbase -endian big
+
+# SRAM: 56KiB at 0x4030.0000
+$_TARGETNAME configure -work-area-phys 0x00000000 \
+	-work-area-virt 0x00000000 -work-area-size 0x10000000
